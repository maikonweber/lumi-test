
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "user"
  objects: {
    passwordhash: passwordhashPayload<ExtArgs> | null
    cookies: cookiePayload<ExtArgs>[]
    permission: permissionPayload<ExtArgs>[]
    userlog: userlogPayload<ExtArgs>[]
    wallet: walletPayload<ExtArgs> | null
    product: productPayload<ExtArgs>[]
    order: orderPayload<ExtArgs>[]
    profile: users_profilePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    username: string
    email: string
    usecase: usecase
    createdat: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model user
 * 
 */
export type user = runtime.Types.DefaultSelection<userPayload>
export type statistics_teamPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "statistics_team"
  objects: {
    league_teamid: league_teamsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    league_team_id: number
    fixtures: Prisma.JsonValue
    biggest: Prisma.JsonValue
    goals: Prisma.JsonValue
    clean_sheet: Prisma.JsonValue
    failed_to_score: Prisma.JsonValue
    penalty: Prisma.JsonValue
    lineups: Prisma.JsonValue
    cards: Prisma.JsonValue
  }, ExtArgs["result"]["statistics_team"]>
  composites: {}
}

/**
 * Model statistics_team
 * 
 */
export type statistics_team = runtime.Types.DefaultSelection<statistics_teamPayload>
export type fixture_roundPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "fixture_round"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    round: string
    seasson: number
    league: Prisma.JsonValue
    leagues_teams_id: number
    status: Prisma.JsonValue
    venus: Prisma.JsonValue
    date: Date
    goals: Prisma.JsonValue
    score: Prisma.JsonValue
    fulltime: Prisma.JsonValue
    extratime: Prisma.JsonValue
    penalty: Prisma.JsonValue
  }, ExtArgs["result"]["fixture_round"]>
  composites: {}
}

/**
 * Model fixture_round
 * 
 */
export type fixture_round = runtime.Types.DefaultSelection<fixture_roundPayload>
export type football_playersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "football_players"
  objects: {
    team_player: team_playerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    lastname: string
    age: number
    birth: Prisma.JsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: Prisma.JsonValue
  }, ExtArgs["result"]["football_players"]>
  composites: {}
}

/**
 * Model football_players
 * 
 */
export type football_players = runtime.Types.DefaultSelection<football_playersPayload>
export type team_playerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "team_player"
  objects: {
    teamid: teamPayload<ExtArgs>
    playerid: football_playersPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    team_id: number
    player_id: number
  }, ExtArgs["result"]["team_player"]>
  composites: {}
}

/**
 * Model team_player
 * 
 */
export type team_player = runtime.Types.DefaultSelection<team_playerPayload>
export type productPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "product"
  objects: {
    user: userPayload<ExtArgs>
    orders: orderPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    description: string
    price: number
    userid: number
    createdat: Date
  }, ExtArgs["result"]["product"]>
  composites: {}
}

/**
 * Model product
 * 
 */
export type product = runtime.Types.DefaultSelection<productPayload>
export type orderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "order"
  objects: {
    product: productPayload<ExtArgs>
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    productid: number
    userid: number
    quantity: number
    total: number
    createdat: Date
  }, ExtArgs["result"]["order"]>
  composites: {}
}

/**
 * Model order
 * 
 */
export type order = runtime.Types.DefaultSelection<orderPayload>
export type walletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "wallet"
  objects: {
    user: userPayload<ExtArgs>
    walletmovement: walletmovementPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    balance: number
    userid: number
    createdat: Date
  }, ExtArgs["result"]["wallet"]>
  composites: {}
}

/**
 * Model wallet
 * 
 */
export type wallet = runtime.Types.DefaultSelection<walletPayload>
export type walletmovementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "walletmovement"
  objects: {
    wallet: walletPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    walletid: number
    amount: number
    movementtype: movementtype
    createdat: Date
  }, ExtArgs["result"]["walletmovement"]>
  composites: {}
}

/**
 * Model walletmovement
 * 
 */
export type walletmovement = runtime.Types.DefaultSelection<walletmovementPayload>
export type leaguesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "leagues"
  objects: {
    league_teams: league_teamsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
  }, ExtArgs["result"]["leagues"]>
  composites: {}
}

/**
 * Model leagues
 * 
 */
export type leagues = runtime.Types.DefaultSelection<leaguesPayload>
export type league_teamsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "league_teams"
  objects: {
    leagues: leaguesPayload<ExtArgs>
    teamid: teamPayload<ExtArgs>
    statistics_team: statistics_teamPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    league_id: number
    team_id: number
  }, ExtArgs["result"]["league_teams"]>
  composites: {}
}

/**
 * Model league_teams
 * 
 */
export type league_teams = runtime.Types.DefaultSelection<league_teamsPayload>
export type countryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "country"
  objects: {}
  scalars: $Extensions.GetResult<{
    name: string
    code: string
    flag: string
  }, ExtArgs["result"]["country"]>
  composites: {}
}

/**
 * Model country
 * 
 */
export type country = runtime.Types.DefaultSelection<countryPayload>
export type teamPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "team"
  objects: {
    league_teams: league_teamsPayload<ExtArgs>[]
    player_team: team_playerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: Prisma.JsonValue
  }, ExtArgs["result"]["team"]>
  composites: {}
}

/**
 * Model team
 * 
 */
export type team = runtime.Types.DefaultSelection<teamPayload>
export type leadPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "lead"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    firstname: string
    lastname: string
    email: string
    phone: string | null
    description: string
    createdat: Date
  }, ExtArgs["result"]["lead"]>
  composites: {}
}

/**
 * Model lead
 * 
 */
export type lead = runtime.Types.DefaultSelection<leadPayload>
export type passwordhashPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "passwordhash"
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number
    hash: string
    salt: string
    createdat: Date
  }, ExtArgs["result"]["passwordhash"]>
  composites: {}
}

/**
 * Model passwordhash
 * 
 */
export type passwordhash = runtime.Types.DefaultSelection<passwordhashPayload>
export type permissionlogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "permissionlog"
  objects: {
    permision: permissionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    permissionid: number
    action: string
    createdat: Date
  }, ExtArgs["result"]["permissionlog"]>
  composites: {}
}

/**
 * Model permissionlog
 * 
 */
export type permissionlog = runtime.Types.DefaultSelection<permissionlogPayload>
export type userlogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "userlog"
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number
    action: string
    createat: Date
  }, ExtArgs["result"]["userlog"]>
  composites: {}
}

/**
 * Model userlog
 * 
 */
export type userlog = runtime.Types.DefaultSelection<userlogPayload>
export type permissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "permission"
  objects: {
    permission: userPayload<ExtArgs>
    permissionlog: permissionlogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    description: string
    userid: number
    createdat: Date
  }, ExtArgs["result"]["permission"]>
  composites: {}
}

/**
 * Model permission
 * 
 */
export type permission = runtime.Types.DefaultSelection<permissionPayload>
export type users_profilePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "users_profile"
  objects: {
    profile: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
    userid: number
  }, ExtArgs["result"]["users_profile"]>
  composites: {}
}

/**
 * Model users_profile
 * 
 */
export type users_profile = runtime.Types.DefaultSelection<users_profilePayload>
export type cookiePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "cookie"
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    value: string
    userid: number
    createdat: Date
  }, ExtArgs["result"]["cookie"]>
  composites: {}
}

/**
 * Model cookie
 * 
 */
export type cookie = runtime.Types.DefaultSelection<cookiePayload>

/**
 * Enums
 */

export const usecase: {
  unkown: 'unkown',
  admin: 'admin',
  moderator: 'moderator',
  member: 'member',
  bank: 'bank'
};

export type usecase = (typeof usecase)[keyof typeof usecase]


export const movementtype: {
  deposit: 'deposit',
  withdrawal: 'withdrawal'
};

export type movementtype = (typeof movementtype)[keyof typeof movementtype]


export const typecup: {
  Cup: 'Cup',
  Champion: 'Champion'
};

export type typecup = (typeof typecup)[keyof typeof typecup]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.statistics_team`: Exposes CRUD operations for the **statistics_team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statistics_teams
    * const statistics_teams = await prisma.statistics_team.findMany()
    * ```
    */
  get statistics_team(): Prisma.statistics_teamDelegate<ExtArgs>;

  /**
   * `prisma.fixture_round`: Exposes CRUD operations for the **fixture_round** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fixture_rounds
    * const fixture_rounds = await prisma.fixture_round.findMany()
    * ```
    */
  get fixture_round(): Prisma.fixture_roundDelegate<ExtArgs>;

  /**
   * `prisma.football_players`: Exposes CRUD operations for the **football_players** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Football_players
    * const football_players = await prisma.football_players.findMany()
    * ```
    */
  get football_players(): Prisma.football_playersDelegate<ExtArgs>;

  /**
   * `prisma.team_player`: Exposes CRUD operations for the **team_player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_players
    * const team_players = await prisma.team_player.findMany()
    * ```
    */
  get team_player(): Prisma.team_playerDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.walletDelegate<ExtArgs>;

  /**
   * `prisma.walletmovement`: Exposes CRUD operations for the **walletmovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Walletmovements
    * const walletmovements = await prisma.walletmovement.findMany()
    * ```
    */
  get walletmovement(): Prisma.walletmovementDelegate<ExtArgs>;

  /**
   * `prisma.leagues`: Exposes CRUD operations for the **leagues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leagues
    * const leagues = await prisma.leagues.findMany()
    * ```
    */
  get leagues(): Prisma.leaguesDelegate<ExtArgs>;

  /**
   * `prisma.league_teams`: Exposes CRUD operations for the **league_teams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more League_teams
    * const league_teams = await prisma.league_teams.findMany()
    * ```
    */
  get league_teams(): Prisma.league_teamsDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.countryDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.leadDelegate<ExtArgs>;

  /**
   * `prisma.passwordhash`: Exposes CRUD operations for the **passwordhash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passwordhashes
    * const passwordhashes = await prisma.passwordhash.findMany()
    * ```
    */
  get passwordhash(): Prisma.passwordhashDelegate<ExtArgs>;

  /**
   * `prisma.permissionlog`: Exposes CRUD operations for the **permissionlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissionlogs
    * const permissionlogs = await prisma.permissionlog.findMany()
    * ```
    */
  get permissionlog(): Prisma.permissionlogDelegate<ExtArgs>;

  /**
   * `prisma.userlog`: Exposes CRUD operations for the **userlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userlogs
    * const userlogs = await prisma.userlog.findMany()
    * ```
    */
  get userlog(): Prisma.userlogDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<ExtArgs>;

  /**
   * `prisma.users_profile`: Exposes CRUD operations for the **users_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_profiles
    * const users_profiles = await prisma.users_profile.findMany()
    * ```
    */
  get users_profile(): Prisma.users_profileDelegate<ExtArgs>;

  /**
   * `prisma.cookie`: Exposes CRUD operations for the **cookie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cookies
    * const cookies = await prisma.cookie.findMany()
    * ```
    */
  get cookie(): Prisma.cookieDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    statistics_team: 'statistics_team',
    fixture_round: 'fixture_round',
    football_players: 'football_players',
    team_player: 'team_player',
    product: 'product',
    order: 'order',
    wallet: 'wallet',
    walletmovement: 'walletmovement',
    leagues: 'leagues',
    league_teams: 'league_teams',
    country: 'country',
    team: 'team',
    lead: 'lead',
    passwordhash: 'passwordhash',
    permissionlog: 'permissionlog',
    userlog: 'userlog',
    permission: 'permission',
    users_profile: 'users_profile',
    cookie: 'cookie'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'statistics_team' | 'fixture_round' | 'football_players' | 'team_player' | 'product' | 'order' | 'wallet' | 'walletmovement' | 'leagues' | 'league_teams' | 'country' | 'team' | 'lead' | 'passwordhash' | 'permissionlog' | 'userlog' | 'permission' | 'users_profile' | 'cookie'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      user: {
        payload: userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      statistics_team: {
        payload: statistics_teamPayload<ExtArgs>
        fields: Prisma.statistics_teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statistics_teamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statistics_teamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>
          }
          findFirst: {
            args: Prisma.statistics_teamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statistics_teamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>
          }
          findMany: {
            args: Prisma.statistics_teamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>[]
          }
          create: {
            args: Prisma.statistics_teamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>
          }
          createMany: {
            args: Prisma.statistics_teamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.statistics_teamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>
          }
          update: {
            args: Prisma.statistics_teamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>
          }
          deleteMany: {
            args: Prisma.statistics_teamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.statistics_teamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.statistics_teamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<statistics_teamPayload>
          }
          aggregate: {
            args: Prisma.Statistics_teamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStatistics_team>
          }
          groupBy: {
            args: Prisma.statistics_teamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Statistics_teamGroupByOutputType>[]
          }
          count: {
            args: Prisma.statistics_teamCountArgs<ExtArgs>,
            result: $Utils.Optional<Statistics_teamCountAggregateOutputType> | number
          }
        }
      }
      fixture_round: {
        payload: fixture_roundPayload<ExtArgs>
        fields: Prisma.fixture_roundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fixture_roundFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fixture_roundFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>
          }
          findFirst: {
            args: Prisma.fixture_roundFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fixture_roundFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>
          }
          findMany: {
            args: Prisma.fixture_roundFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>[]
          }
          create: {
            args: Prisma.fixture_roundCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>
          }
          createMany: {
            args: Prisma.fixture_roundCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fixture_roundDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>
          }
          update: {
            args: Prisma.fixture_roundUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>
          }
          deleteMany: {
            args: Prisma.fixture_roundDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fixture_roundUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fixture_roundUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixture_roundPayload>
          }
          aggregate: {
            args: Prisma.Fixture_roundAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFixture_round>
          }
          groupBy: {
            args: Prisma.fixture_roundGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fixture_roundGroupByOutputType>[]
          }
          count: {
            args: Prisma.fixture_roundCountArgs<ExtArgs>,
            result: $Utils.Optional<Fixture_roundCountAggregateOutputType> | number
          }
        }
      }
      football_players: {
        payload: football_playersPayload<ExtArgs>
        fields: Prisma.football_playersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.football_playersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.football_playersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>
          }
          findFirst: {
            args: Prisma.football_playersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.football_playersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>
          }
          findMany: {
            args: Prisma.football_playersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>[]
          }
          create: {
            args: Prisma.football_playersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>
          }
          createMany: {
            args: Prisma.football_playersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.football_playersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>
          }
          update: {
            args: Prisma.football_playersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>
          }
          deleteMany: {
            args: Prisma.football_playersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.football_playersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.football_playersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<football_playersPayload>
          }
          aggregate: {
            args: Prisma.Football_playersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFootball_players>
          }
          groupBy: {
            args: Prisma.football_playersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Football_playersGroupByOutputType>[]
          }
          count: {
            args: Prisma.football_playersCountArgs<ExtArgs>,
            result: $Utils.Optional<Football_playersCountAggregateOutputType> | number
          }
        }
      }
      team_player: {
        payload: team_playerPayload<ExtArgs>
        fields: Prisma.team_playerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_playerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_playerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>
          }
          findFirst: {
            args: Prisma.team_playerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_playerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>
          }
          findMany: {
            args: Prisma.team_playerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>[]
          }
          create: {
            args: Prisma.team_playerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>
          }
          createMany: {
            args: Prisma.team_playerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.team_playerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>
          }
          update: {
            args: Prisma.team_playerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>
          }
          deleteMany: {
            args: Prisma.team_playerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.team_playerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.team_playerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<team_playerPayload>
          }
          aggregate: {
            args: Prisma.Team_playerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam_player>
          }
          groupBy: {
            args: Prisma.team_playerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Team_playerGroupByOutputType>[]
          }
          count: {
            args: Prisma.team_playerCountArgs<ExtArgs>,
            result: $Utils.Optional<Team_playerCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      order: {
        payload: orderPayload<ExtArgs>
        fields: Prisma.orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>
          }
          findFirst: {
            args: Prisma.orderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>
          }
          findMany: {
            args: Prisma.orderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>[]
          }
          create: {
            args: Prisma.orderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>
          }
          createMany: {
            args: Prisma.orderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>
          }
          update: {
            args: Prisma.orderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>
          }
          deleteMany: {
            args: Prisma.orderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<orderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.orderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      wallet: {
        payload: walletPayload<ExtArgs>
        fields: Prisma.walletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          findFirst: {
            args: Prisma.walletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          findMany: {
            args: Prisma.walletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>[]
          }
          create: {
            args: Prisma.walletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          createMany: {
            args: Prisma.walletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.walletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          update: {
            args: Prisma.walletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          deleteMany: {
            args: Prisma.walletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.walletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.walletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.walletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletCountArgs<ExtArgs>,
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      walletmovement: {
        payload: walletmovementPayload<ExtArgs>
        fields: Prisma.walletmovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletmovementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletmovementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>
          }
          findFirst: {
            args: Prisma.walletmovementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletmovementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>
          }
          findMany: {
            args: Prisma.walletmovementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>[]
          }
          create: {
            args: Prisma.walletmovementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>
          }
          createMany: {
            args: Prisma.walletmovementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.walletmovementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>
          }
          update: {
            args: Prisma.walletmovementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>
          }
          deleteMany: {
            args: Prisma.walletmovementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.walletmovementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.walletmovementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletmovementPayload>
          }
          aggregate: {
            args: Prisma.WalletmovementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWalletmovement>
          }
          groupBy: {
            args: Prisma.walletmovementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WalletmovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletmovementCountArgs<ExtArgs>,
            result: $Utils.Optional<WalletmovementCountAggregateOutputType> | number
          }
        }
      }
      leagues: {
        payload: leaguesPayload<ExtArgs>
        fields: Prisma.leaguesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leaguesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leaguesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>
          }
          findFirst: {
            args: Prisma.leaguesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leaguesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>
          }
          findMany: {
            args: Prisma.leaguesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>[]
          }
          create: {
            args: Prisma.leaguesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>
          }
          createMany: {
            args: Prisma.leaguesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.leaguesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>
          }
          update: {
            args: Prisma.leaguesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>
          }
          deleteMany: {
            args: Prisma.leaguesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.leaguesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.leaguesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leaguesPayload>
          }
          aggregate: {
            args: Prisma.LeaguesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeagues>
          }
          groupBy: {
            args: Prisma.leaguesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeaguesGroupByOutputType>[]
          }
          count: {
            args: Prisma.leaguesCountArgs<ExtArgs>,
            result: $Utils.Optional<LeaguesCountAggregateOutputType> | number
          }
        }
      }
      league_teams: {
        payload: league_teamsPayload<ExtArgs>
        fields: Prisma.league_teamsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.league_teamsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.league_teamsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>
          }
          findFirst: {
            args: Prisma.league_teamsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.league_teamsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>
          }
          findMany: {
            args: Prisma.league_teamsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>[]
          }
          create: {
            args: Prisma.league_teamsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>
          }
          createMany: {
            args: Prisma.league_teamsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.league_teamsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>
          }
          update: {
            args: Prisma.league_teamsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>
          }
          deleteMany: {
            args: Prisma.league_teamsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.league_teamsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.league_teamsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<league_teamsPayload>
          }
          aggregate: {
            args: Prisma.League_teamsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeague_teams>
          }
          groupBy: {
            args: Prisma.league_teamsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<League_teamsGroupByOutputType>[]
          }
          count: {
            args: Prisma.league_teamsCountArgs<ExtArgs>,
            result: $Utils.Optional<League_teamsCountAggregateOutputType> | number
          }
        }
      }
      country: {
        payload: countryPayload<ExtArgs>
        fields: Prisma.countryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.countryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.countryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>
          }
          findFirst: {
            args: Prisma.countryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.countryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>
          }
          findMany: {
            args: Prisma.countryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>[]
          }
          create: {
            args: Prisma.countryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>
          }
          createMany: {
            args: Prisma.countryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.countryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>
          }
          update: {
            args: Prisma.countryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>
          }
          deleteMany: {
            args: Prisma.countryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.countryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.countryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<countryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.countryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.countryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      team: {
        payload: teamPayload<ExtArgs>
        fields: Prisma.teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          findFirst: {
            args: Prisma.teamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          findMany: {
            args: Prisma.teamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>[]
          }
          create: {
            args: Prisma.teamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          createMany: {
            args: Prisma.teamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.teamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          update: {
            args: Prisma.teamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          deleteMany: {
            args: Prisma.teamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.teamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.teamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.teamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      lead: {
        payload: leadPayload<ExtArgs>
        fields: Prisma.leadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>
          }
          findFirst: {
            args: Prisma.leadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>
          }
          findMany: {
            args: Prisma.leadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>[]
          }
          create: {
            args: Prisma.leadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>
          }
          createMany: {
            args: Prisma.leadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.leadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>
          }
          update: {
            args: Prisma.leadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>
          }
          deleteMany: {
            args: Prisma.leadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.leadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.leadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<leadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.leadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.leadCountArgs<ExtArgs>,
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      passwordhash: {
        payload: passwordhashPayload<ExtArgs>
        fields: Prisma.passwordhashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.passwordhashFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.passwordhashFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>
          }
          findFirst: {
            args: Prisma.passwordhashFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.passwordhashFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>
          }
          findMany: {
            args: Prisma.passwordhashFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>[]
          }
          create: {
            args: Prisma.passwordhashCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>
          }
          createMany: {
            args: Prisma.passwordhashCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.passwordhashDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>
          }
          update: {
            args: Prisma.passwordhashUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>
          }
          deleteMany: {
            args: Prisma.passwordhashDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.passwordhashUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.passwordhashUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<passwordhashPayload>
          }
          aggregate: {
            args: Prisma.PasswordhashAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePasswordhash>
          }
          groupBy: {
            args: Prisma.passwordhashGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PasswordhashGroupByOutputType>[]
          }
          count: {
            args: Prisma.passwordhashCountArgs<ExtArgs>,
            result: $Utils.Optional<PasswordhashCountAggregateOutputType> | number
          }
        }
      }
      permissionlog: {
        payload: permissionlogPayload<ExtArgs>
        fields: Prisma.permissionlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionlogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionlogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>
          }
          findFirst: {
            args: Prisma.permissionlogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionlogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>
          }
          findMany: {
            args: Prisma.permissionlogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>[]
          }
          create: {
            args: Prisma.permissionlogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>
          }
          createMany: {
            args: Prisma.permissionlogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.permissionlogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>
          }
          update: {
            args: Prisma.permissionlogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>
          }
          deleteMany: {
            args: Prisma.permissionlogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.permissionlogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.permissionlogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionlogPayload>
          }
          aggregate: {
            args: Prisma.PermissionlogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermissionlog>
          }
          groupBy: {
            args: Prisma.permissionlogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermissionlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionlogCountArgs<ExtArgs>,
            result: $Utils.Optional<PermissionlogCountAggregateOutputType> | number
          }
        }
      }
      userlog: {
        payload: userlogPayload<ExtArgs>
        fields: Prisma.userlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userlogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userlogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>
          }
          findFirst: {
            args: Prisma.userlogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userlogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>
          }
          findMany: {
            args: Prisma.userlogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>[]
          }
          create: {
            args: Prisma.userlogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>
          }
          createMany: {
            args: Prisma.userlogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userlogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>
          }
          update: {
            args: Prisma.userlogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>
          }
          deleteMany: {
            args: Prisma.userlogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userlogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userlogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userlogPayload>
          }
          aggregate: {
            args: Prisma.UserlogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserlog>
          }
          groupBy: {
            args: Prisma.userlogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.userlogCountArgs<ExtArgs>,
            result: $Utils.Optional<UserlogCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: permissionPayload<ExtArgs>
        fields: Prisma.permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.permissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>,
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      users_profile: {
        payload: users_profilePayload<ExtArgs>
        fields: Prisma.users_profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_profileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_profileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>
          }
          findFirst: {
            args: Prisma.users_profileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_profileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>
          }
          findMany: {
            args: Prisma.users_profileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>[]
          }
          create: {
            args: Prisma.users_profileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>
          }
          createMany: {
            args: Prisma.users_profileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.users_profileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>
          }
          update: {
            args: Prisma.users_profileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>
          }
          deleteMany: {
            args: Prisma.users_profileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.users_profileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.users_profileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<users_profilePayload>
          }
          aggregate: {
            args: Prisma.Users_profileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers_profile>
          }
          groupBy: {
            args: Prisma.users_profileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Users_profileGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_profileCountArgs<ExtArgs>,
            result: $Utils.Optional<Users_profileCountAggregateOutputType> | number
          }
        }
      }
      cookie: {
        payload: cookiePayload<ExtArgs>
        fields: Prisma.cookieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cookieFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cookieFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>
          }
          findFirst: {
            args: Prisma.cookieFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cookieFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>
          }
          findMany: {
            args: Prisma.cookieFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>[]
          }
          create: {
            args: Prisma.cookieCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>
          }
          createMany: {
            args: Prisma.cookieCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cookieDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>
          }
          update: {
            args: Prisma.cookieUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>
          }
          deleteMany: {
            args: Prisma.cookieDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cookieUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cookieUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cookiePayload>
          }
          aggregate: {
            args: Prisma.CookieAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCookie>
          }
          groupBy: {
            args: Prisma.cookieGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CookieGroupByOutputType>[]
          }
          count: {
            args: Prisma.cookieCountArgs<ExtArgs>,
            result: $Utils.Optional<CookieCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    cookies: number
    permission: number
    userlog: number
    product: number
    order: number
    profile: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    cookies?: boolean | UserCountOutputTypeCountCookiesArgs
    permission?: boolean | UserCountOutputTypeCountPermissionArgs
    userlog?: boolean | UserCountOutputTypeCountUserlogArgs
    product?: boolean | UserCountOutputTypeCountProductArgs
    order?: boolean | UserCountOutputTypeCountOrderArgs
    profile?: boolean | UserCountOutputTypeCountProfileArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCookiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: cookieWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userlogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: users_profileWhereInput
  }



  /**
   * Count Type Football_playersCountOutputType
   */


  export type Football_playersCountOutputType = {
    team_player: number
  }

  export type Football_playersCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team_player?: boolean | Football_playersCountOutputTypeCountTeam_playerArgs
  }

  // Custom InputTypes

  /**
   * Football_playersCountOutputType without action
   */
  export type Football_playersCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Football_playersCountOutputType
     */
    select?: Football_playersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Football_playersCountOutputType without action
   */
  export type Football_playersCountOutputTypeCountTeam_playerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: team_playerWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    orders: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | ProductCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }



  /**
   * Count Type WalletCountOutputType
   */


  export type WalletCountOutputType = {
    walletmovement: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    walletmovement?: boolean | WalletCountOutputTypeCountWalletmovementArgs
  }

  // Custom InputTypes

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountWalletmovementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: walletmovementWhereInput
  }



  /**
   * Count Type LeaguesCountOutputType
   */


  export type LeaguesCountOutputType = {
    league_teams: number
  }

  export type LeaguesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    league_teams?: boolean | LeaguesCountOutputTypeCountLeague_teamsArgs
  }

  // Custom InputTypes

  /**
   * LeaguesCountOutputType without action
   */
  export type LeaguesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaguesCountOutputType
     */
    select?: LeaguesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LeaguesCountOutputType without action
   */
  export type LeaguesCountOutputTypeCountLeague_teamsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: league_teamsWhereInput
  }



  /**
   * Count Type League_teamsCountOutputType
   */


  export type League_teamsCountOutputType = {
    statistics_team: number
  }

  export type League_teamsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    statistics_team?: boolean | League_teamsCountOutputTypeCountStatistics_teamArgs
  }

  // Custom InputTypes

  /**
   * League_teamsCountOutputType without action
   */
  export type League_teamsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League_teamsCountOutputType
     */
    select?: League_teamsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * League_teamsCountOutputType without action
   */
  export type League_teamsCountOutputTypeCountStatistics_teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: statistics_teamWhereInput
  }



  /**
   * Count Type TeamCountOutputType
   */


  export type TeamCountOutputType = {
    league_teams: number
    player_team: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    league_teams?: boolean | TeamCountOutputTypeCountLeague_teamsArgs
    player_team?: boolean | TeamCountOutputTypeCountPlayer_teamArgs
  }

  // Custom InputTypes

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLeague_teamsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: league_teamsWhereInput
  }


  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlayer_teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: team_playerWhereInput
  }



  /**
   * Count Type PermissionCountOutputType
   */


  export type PermissionCountOutputType = {
    permissionlog: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    permissionlog?: boolean | PermissionCountOutputTypeCountPermissionlogArgs
  }

  // Custom InputTypes

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountPermissionlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: permissionlogWhereInput
  }



  /**
   * Models
   */

  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    usecase: usecase | null
    createdat: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    usecase: usecase | null
    createdat: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    usecase: number
    createdat: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    usecase?: true
    createdat?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    usecase?: true
    createdat?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    usecase?: true
    createdat?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    usecase: usecase
    createdat: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    usecase?: boolean
    createdat?: boolean
    passwordhash?: boolean | user$passwordhashArgs<ExtArgs>
    cookies?: boolean | user$cookiesArgs<ExtArgs>
    permission?: boolean | user$permissionArgs<ExtArgs>
    userlog?: boolean | user$userlogArgs<ExtArgs>
    wallet?: boolean | user$walletArgs<ExtArgs>
    product?: boolean | user$productArgs<ExtArgs>
    order?: boolean | user$orderArgs<ExtArgs>
    profile?: boolean | user$profileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    usecase?: boolean
    createdat?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    passwordhash?: boolean | user$passwordhashArgs<ExtArgs>
    cookies?: boolean | user$cookiesArgs<ExtArgs>
    permission?: boolean | user$permissionArgs<ExtArgs>
    userlog?: boolean | user$userlogArgs<ExtArgs>
    wallet?: boolean | user$walletArgs<ExtArgs>
    product?: boolean | user$productArgs<ExtArgs>
    order?: boolean | user$orderArgs<ExtArgs>
    profile?: boolean | user$profileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type userGetPayload<S extends boolean | null | undefined | userArgs> = $Types.GetResult<userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    passwordhash<T extends user$passwordhashArgs<ExtArgs> = {}>(args?: Subset<T, user$passwordhashArgs<ExtArgs>>): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    cookies<T extends user$cookiesArgs<ExtArgs> = {}>(args?: Subset<T, user$cookiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<cookiePayload<ExtArgs>, T, 'findMany'>| Null>;

    permission<T extends user$permissionArgs<ExtArgs> = {}>(args?: Subset<T, user$permissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findMany'>| Null>;

    userlog<T extends user$userlogArgs<ExtArgs> = {}>(args?: Subset<T, user$userlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userlogPayload<ExtArgs>, T, 'findMany'>| Null>;

    wallet<T extends user$walletArgs<ExtArgs> = {}>(args?: Subset<T, user$walletArgs<ExtArgs>>): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    product<T extends user$productArgs<ExtArgs> = {}>(args?: Subset<T, user$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<productPayload<ExtArgs>, T, 'findMany'>| Null>;

    order<T extends user$orderArgs<ExtArgs> = {}>(args?: Subset<T, user$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<orderPayload<ExtArgs>, T, 'findMany'>| Null>;

    profile<T extends user$profileArgs<ExtArgs> = {}>(args?: Subset<T, user$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly username: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly usecase: FieldRef<"user", 'usecase'>
    readonly createdat: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.passwordhash
   */
  export type user$passwordhashArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    where?: passwordhashWhereInput
  }


  /**
   * user.cookies
   */
  export type user$cookiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    where?: cookieWhereInput
    orderBy?: cookieOrderByWithRelationInput | cookieOrderByWithRelationInput[]
    cursor?: cookieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CookieScalarFieldEnum | CookieScalarFieldEnum[]
  }


  /**
   * user.permission
   */
  export type user$permissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    cursor?: permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * user.userlog
   */
  export type user$userlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    where?: userlogWhereInput
    orderBy?: userlogOrderByWithRelationInput | userlogOrderByWithRelationInput[]
    cursor?: userlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserlogScalarFieldEnum | UserlogScalarFieldEnum[]
  }


  /**
   * user.wallet
   */
  export type user$walletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
  }


  /**
   * user.product
   */
  export type user$productArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * user.order
   */
  export type user$orderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * user.profile
   */
  export type user$profileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    where?: users_profileWhereInput
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    cursor?: users_profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model statistics_team
   */


  export type AggregateStatistics_team = {
    _count: Statistics_teamCountAggregateOutputType | null
    _avg: Statistics_teamAvgAggregateOutputType | null
    _sum: Statistics_teamSumAggregateOutputType | null
    _min: Statistics_teamMinAggregateOutputType | null
    _max: Statistics_teamMaxAggregateOutputType | null
  }

  export type Statistics_teamAvgAggregateOutputType = {
    league_team_id: number | null
  }

  export type Statistics_teamSumAggregateOutputType = {
    league_team_id: number | null
  }

  export type Statistics_teamMinAggregateOutputType = {
    league_team_id: number | null
  }

  export type Statistics_teamMaxAggregateOutputType = {
    league_team_id: number | null
  }

  export type Statistics_teamCountAggregateOutputType = {
    league_team_id: number
    fixtures: number
    biggest: number
    goals: number
    clean_sheet: number
    failed_to_score: number
    penalty: number
    lineups: number
    cards: number
    _all: number
  }


  export type Statistics_teamAvgAggregateInputType = {
    league_team_id?: true
  }

  export type Statistics_teamSumAggregateInputType = {
    league_team_id?: true
  }

  export type Statistics_teamMinAggregateInputType = {
    league_team_id?: true
  }

  export type Statistics_teamMaxAggregateInputType = {
    league_team_id?: true
  }

  export type Statistics_teamCountAggregateInputType = {
    league_team_id?: true
    fixtures?: true
    biggest?: true
    goals?: true
    clean_sheet?: true
    failed_to_score?: true
    penalty?: true
    lineups?: true
    cards?: true
    _all?: true
  }

  export type Statistics_teamAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which statistics_team to aggregate.
     */
    where?: statistics_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics_teams to fetch.
     */
    orderBy?: statistics_teamOrderByWithRelationInput | statistics_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statistics_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statistics_teams
    **/
    _count?: true | Statistics_teamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Statistics_teamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Statistics_teamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Statistics_teamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Statistics_teamMaxAggregateInputType
  }

  export type GetStatistics_teamAggregateType<T extends Statistics_teamAggregateArgs> = {
        [P in keyof T & keyof AggregateStatistics_team]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatistics_team[P]>
      : GetScalarType<T[P], AggregateStatistics_team[P]>
  }




  export type statistics_teamGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: statistics_teamWhereInput
    orderBy?: statistics_teamOrderByWithAggregationInput | statistics_teamOrderByWithAggregationInput[]
    by: Statistics_teamScalarFieldEnum[] | Statistics_teamScalarFieldEnum
    having?: statistics_teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Statistics_teamCountAggregateInputType | true
    _avg?: Statistics_teamAvgAggregateInputType
    _sum?: Statistics_teamSumAggregateInputType
    _min?: Statistics_teamMinAggregateInputType
    _max?: Statistics_teamMaxAggregateInputType
  }


  export type Statistics_teamGroupByOutputType = {
    league_team_id: number
    fixtures: JsonValue
    biggest: JsonValue
    goals: JsonValue
    clean_sheet: JsonValue
    failed_to_score: JsonValue
    penalty: JsonValue
    lineups: JsonValue
    cards: JsonValue
    _count: Statistics_teamCountAggregateOutputType | null
    _avg: Statistics_teamAvgAggregateOutputType | null
    _sum: Statistics_teamSumAggregateOutputType | null
    _min: Statistics_teamMinAggregateOutputType | null
    _max: Statistics_teamMaxAggregateOutputType | null
  }

  type GetStatistics_teamGroupByPayload<T extends statistics_teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Statistics_teamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Statistics_teamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Statistics_teamGroupByOutputType[P]>
            : GetScalarType<T[P], Statistics_teamGroupByOutputType[P]>
        }
      >
    >


  export type statistics_teamSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    league_team_id?: boolean
    fixtures?: boolean
    biggest?: boolean
    goals?: boolean
    clean_sheet?: boolean
    failed_to_score?: boolean
    penalty?: boolean
    lineups?: boolean
    cards?: boolean
    league_teamid?: boolean | league_teamsArgs<ExtArgs>
  }, ExtArgs["result"]["statistics_team"]>

  export type statistics_teamSelectScalar = {
    league_team_id?: boolean
    fixtures?: boolean
    biggest?: boolean
    goals?: boolean
    clean_sheet?: boolean
    failed_to_score?: boolean
    penalty?: boolean
    lineups?: boolean
    cards?: boolean
  }

  export type statistics_teamInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    league_teamid?: boolean | league_teamsArgs<ExtArgs>
  }


  type statistics_teamGetPayload<S extends boolean | null | undefined | statistics_teamArgs> = $Types.GetResult<statistics_teamPayload, S>

  type statistics_teamCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<statistics_teamFindManyArgs, 'select' | 'include'> & {
      select?: Statistics_teamCountAggregateInputType | true
    }

  export interface statistics_teamDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statistics_team'], meta: { name: 'statistics_team' } }
    /**
     * Find zero or one Statistics_team that matches the filter.
     * @param {statistics_teamFindUniqueArgs} args - Arguments to find a Statistics_team
     * @example
     * // Get one Statistics_team
     * const statistics_team = await prisma.statistics_team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends statistics_teamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, statistics_teamFindUniqueArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Statistics_team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {statistics_teamFindUniqueOrThrowArgs} args - Arguments to find a Statistics_team
     * @example
     * // Get one Statistics_team
     * const statistics_team = await prisma.statistics_team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends statistics_teamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, statistics_teamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Statistics_team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistics_teamFindFirstArgs} args - Arguments to find a Statistics_team
     * @example
     * // Get one Statistics_team
     * const statistics_team = await prisma.statistics_team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends statistics_teamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, statistics_teamFindFirstArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Statistics_team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistics_teamFindFirstOrThrowArgs} args - Arguments to find a Statistics_team
     * @example
     * // Get one Statistics_team
     * const statistics_team = await prisma.statistics_team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends statistics_teamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, statistics_teamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Statistics_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistics_teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statistics_teams
     * const statistics_teams = await prisma.statistics_team.findMany()
     * 
     * // Get first 10 Statistics_teams
     * const statistics_teams = await prisma.statistics_team.findMany({ take: 10 })
     * 
     * // Only select the `league_team_id`
     * const statistics_teamWithLeague_team_idOnly = await prisma.statistics_team.findMany({ select: { league_team_id: true } })
     * 
    **/
    findMany<T extends statistics_teamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, statistics_teamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Statistics_team.
     * @param {statistics_teamCreateArgs} args - Arguments to create a Statistics_team.
     * @example
     * // Create one Statistics_team
     * const Statistics_team = await prisma.statistics_team.create({
     *   data: {
     *     // ... data to create a Statistics_team
     *   }
     * })
     * 
    **/
    create<T extends statistics_teamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, statistics_teamCreateArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Statistics_teams.
     *     @param {statistics_teamCreateManyArgs} args - Arguments to create many Statistics_teams.
     *     @example
     *     // Create many Statistics_teams
     *     const statistics_team = await prisma.statistics_team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends statistics_teamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, statistics_teamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Statistics_team.
     * @param {statistics_teamDeleteArgs} args - Arguments to delete one Statistics_team.
     * @example
     * // Delete one Statistics_team
     * const Statistics_team = await prisma.statistics_team.delete({
     *   where: {
     *     // ... filter to delete one Statistics_team
     *   }
     * })
     * 
    **/
    delete<T extends statistics_teamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, statistics_teamDeleteArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Statistics_team.
     * @param {statistics_teamUpdateArgs} args - Arguments to update one Statistics_team.
     * @example
     * // Update one Statistics_team
     * const statistics_team = await prisma.statistics_team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends statistics_teamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, statistics_teamUpdateArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Statistics_teams.
     * @param {statistics_teamDeleteManyArgs} args - Arguments to filter Statistics_teams to delete.
     * @example
     * // Delete a few Statistics_teams
     * const { count } = await prisma.statistics_team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends statistics_teamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, statistics_teamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statistics_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistics_teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statistics_teams
     * const statistics_team = await prisma.statistics_team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends statistics_teamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, statistics_teamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Statistics_team.
     * @param {statistics_teamUpsertArgs} args - Arguments to update or create a Statistics_team.
     * @example
     * // Update or create a Statistics_team
     * const statistics_team = await prisma.statistics_team.upsert({
     *   create: {
     *     // ... data to create a Statistics_team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statistics_team we want to update
     *   }
     * })
    **/
    upsert<T extends statistics_teamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, statistics_teamUpsertArgs<ExtArgs>>
    ): Prisma__statistics_teamClient<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Statistics_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistics_teamCountArgs} args - Arguments to filter Statistics_teams to count.
     * @example
     * // Count the number of Statistics_teams
     * const count = await prisma.statistics_team.count({
     *   where: {
     *     // ... the filter for the Statistics_teams we want to count
     *   }
     * })
    **/
    count<T extends statistics_teamCountArgs>(
      args?: Subset<T, statistics_teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Statistics_teamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statistics_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Statistics_teamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Statistics_teamAggregateArgs>(args: Subset<T, Statistics_teamAggregateArgs>): Prisma.PrismaPromise<GetStatistics_teamAggregateType<T>>

    /**
     * Group by Statistics_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statistics_teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statistics_teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statistics_teamGroupByArgs['orderBy'] }
        : { orderBy?: statistics_teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statistics_teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatistics_teamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statistics_team model
   */
  readonly fields: statistics_teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statistics_team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__statistics_teamClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    league_teamid<T extends league_teamsArgs<ExtArgs> = {}>(args?: Subset<T, league_teamsArgs<ExtArgs>>): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the statistics_team model
   */ 
  interface statistics_teamFieldRefs {
    readonly league_team_id: FieldRef<"statistics_team", 'Int'>
    readonly fixtures: FieldRef<"statistics_team", 'Json'>
    readonly biggest: FieldRef<"statistics_team", 'Json'>
    readonly goals: FieldRef<"statistics_team", 'Json'>
    readonly clean_sheet: FieldRef<"statistics_team", 'Json'>
    readonly failed_to_score: FieldRef<"statistics_team", 'Json'>
    readonly penalty: FieldRef<"statistics_team", 'Json'>
    readonly lineups: FieldRef<"statistics_team", 'Json'>
    readonly cards: FieldRef<"statistics_team", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * statistics_team findUnique
   */
  export type statistics_teamFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * Filter, which statistics_team to fetch.
     */
    where: statistics_teamWhereUniqueInput
  }


  /**
   * statistics_team findUniqueOrThrow
   */
  export type statistics_teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * Filter, which statistics_team to fetch.
     */
    where: statistics_teamWhereUniqueInput
  }


  /**
   * statistics_team findFirst
   */
  export type statistics_teamFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * Filter, which statistics_team to fetch.
     */
    where?: statistics_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics_teams to fetch.
     */
    orderBy?: statistics_teamOrderByWithRelationInput | statistics_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statistics_teams.
     */
    cursor?: statistics_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statistics_teams.
     */
    distinct?: Statistics_teamScalarFieldEnum | Statistics_teamScalarFieldEnum[]
  }


  /**
   * statistics_team findFirstOrThrow
   */
  export type statistics_teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * Filter, which statistics_team to fetch.
     */
    where?: statistics_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics_teams to fetch.
     */
    orderBy?: statistics_teamOrderByWithRelationInput | statistics_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statistics_teams.
     */
    cursor?: statistics_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statistics_teams.
     */
    distinct?: Statistics_teamScalarFieldEnum | Statistics_teamScalarFieldEnum[]
  }


  /**
   * statistics_team findMany
   */
  export type statistics_teamFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * Filter, which statistics_teams to fetch.
     */
    where?: statistics_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statistics_teams to fetch.
     */
    orderBy?: statistics_teamOrderByWithRelationInput | statistics_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statistics_teams.
     */
    cursor?: statistics_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statistics_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statistics_teams.
     */
    skip?: number
    distinct?: Statistics_teamScalarFieldEnum | Statistics_teamScalarFieldEnum[]
  }


  /**
   * statistics_team create
   */
  export type statistics_teamCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * The data needed to create a statistics_team.
     */
    data: XOR<statistics_teamCreateInput, statistics_teamUncheckedCreateInput>
  }


  /**
   * statistics_team createMany
   */
  export type statistics_teamCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statistics_teams.
     */
    data: statistics_teamCreateManyInput | statistics_teamCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * statistics_team update
   */
  export type statistics_teamUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * The data needed to update a statistics_team.
     */
    data: XOR<statistics_teamUpdateInput, statistics_teamUncheckedUpdateInput>
    /**
     * Choose, which statistics_team to update.
     */
    where: statistics_teamWhereUniqueInput
  }


  /**
   * statistics_team updateMany
   */
  export type statistics_teamUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statistics_teams.
     */
    data: XOR<statistics_teamUpdateManyMutationInput, statistics_teamUncheckedUpdateManyInput>
    /**
     * Filter which statistics_teams to update
     */
    where?: statistics_teamWhereInput
  }


  /**
   * statistics_team upsert
   */
  export type statistics_teamUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * The filter to search for the statistics_team to update in case it exists.
     */
    where: statistics_teamWhereUniqueInput
    /**
     * In case the statistics_team found by the `where` argument doesn't exist, create a new statistics_team with this data.
     */
    create: XOR<statistics_teamCreateInput, statistics_teamUncheckedCreateInput>
    /**
     * In case the statistics_team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statistics_teamUpdateInput, statistics_teamUncheckedUpdateInput>
  }


  /**
   * statistics_team delete
   */
  export type statistics_teamDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    /**
     * Filter which statistics_team to delete.
     */
    where: statistics_teamWhereUniqueInput
  }


  /**
   * statistics_team deleteMany
   */
  export type statistics_teamDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which statistics_teams to delete
     */
    where?: statistics_teamWhereInput
  }


  /**
   * statistics_team without action
   */
  export type statistics_teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
  }



  /**
   * Model fixture_round
   */


  export type AggregateFixture_round = {
    _count: Fixture_roundCountAggregateOutputType | null
    _avg: Fixture_roundAvgAggregateOutputType | null
    _sum: Fixture_roundSumAggregateOutputType | null
    _min: Fixture_roundMinAggregateOutputType | null
    _max: Fixture_roundMaxAggregateOutputType | null
  }

  export type Fixture_roundAvgAggregateOutputType = {
    id: number | null
    seasson: number | null
    leagues_teams_id: number | null
  }

  export type Fixture_roundSumAggregateOutputType = {
    id: number | null
    seasson: number | null
    leagues_teams_id: number | null
  }

  export type Fixture_roundMinAggregateOutputType = {
    id: number | null
    round: string | null
    seasson: number | null
    leagues_teams_id: number | null
    date: Date | null
  }

  export type Fixture_roundMaxAggregateOutputType = {
    id: number | null
    round: string | null
    seasson: number | null
    leagues_teams_id: number | null
    date: Date | null
  }

  export type Fixture_roundCountAggregateOutputType = {
    id: number
    round: number
    seasson: number
    league: number
    leagues_teams_id: number
    status: number
    venus: number
    date: number
    goals: number
    score: number
    fulltime: number
    extratime: number
    penalty: number
    _all: number
  }


  export type Fixture_roundAvgAggregateInputType = {
    id?: true
    seasson?: true
    leagues_teams_id?: true
  }

  export type Fixture_roundSumAggregateInputType = {
    id?: true
    seasson?: true
    leagues_teams_id?: true
  }

  export type Fixture_roundMinAggregateInputType = {
    id?: true
    round?: true
    seasson?: true
    leagues_teams_id?: true
    date?: true
  }

  export type Fixture_roundMaxAggregateInputType = {
    id?: true
    round?: true
    seasson?: true
    leagues_teams_id?: true
    date?: true
  }

  export type Fixture_roundCountAggregateInputType = {
    id?: true
    round?: true
    seasson?: true
    league?: true
    leagues_teams_id?: true
    status?: true
    venus?: true
    date?: true
    goals?: true
    score?: true
    fulltime?: true
    extratime?: true
    penalty?: true
    _all?: true
  }

  export type Fixture_roundAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fixture_round to aggregate.
     */
    where?: fixture_roundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixture_rounds to fetch.
     */
    orderBy?: fixture_roundOrderByWithRelationInput | fixture_roundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fixture_roundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixture_rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixture_rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fixture_rounds
    **/
    _count?: true | Fixture_roundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fixture_roundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fixture_roundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fixture_roundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fixture_roundMaxAggregateInputType
  }

  export type GetFixture_roundAggregateType<T extends Fixture_roundAggregateArgs> = {
        [P in keyof T & keyof AggregateFixture_round]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixture_round[P]>
      : GetScalarType<T[P], AggregateFixture_round[P]>
  }




  export type fixture_roundGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fixture_roundWhereInput
    orderBy?: fixture_roundOrderByWithAggregationInput | fixture_roundOrderByWithAggregationInput[]
    by: Fixture_roundScalarFieldEnum[] | Fixture_roundScalarFieldEnum
    having?: fixture_roundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fixture_roundCountAggregateInputType | true
    _avg?: Fixture_roundAvgAggregateInputType
    _sum?: Fixture_roundSumAggregateInputType
    _min?: Fixture_roundMinAggregateInputType
    _max?: Fixture_roundMaxAggregateInputType
  }


  export type Fixture_roundGroupByOutputType = {
    id: number
    round: string
    seasson: number
    league: JsonValue
    leagues_teams_id: number
    status: JsonValue
    venus: JsonValue
    date: Date
    goals: JsonValue
    score: JsonValue
    fulltime: JsonValue
    extratime: JsonValue
    penalty: JsonValue
    _count: Fixture_roundCountAggregateOutputType | null
    _avg: Fixture_roundAvgAggregateOutputType | null
    _sum: Fixture_roundSumAggregateOutputType | null
    _min: Fixture_roundMinAggregateOutputType | null
    _max: Fixture_roundMaxAggregateOutputType | null
  }

  type GetFixture_roundGroupByPayload<T extends fixture_roundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fixture_roundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fixture_roundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fixture_roundGroupByOutputType[P]>
            : GetScalarType<T[P], Fixture_roundGroupByOutputType[P]>
        }
      >
    >


  export type fixture_roundSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    round?: boolean
    seasson?: boolean
    league?: boolean
    leagues_teams_id?: boolean
    status?: boolean
    venus?: boolean
    date?: boolean
    goals?: boolean
    score?: boolean
    fulltime?: boolean
    extratime?: boolean
    penalty?: boolean
  }, ExtArgs["result"]["fixture_round"]>

  export type fixture_roundSelectScalar = {
    id?: boolean
    round?: boolean
    seasson?: boolean
    league?: boolean
    leagues_teams_id?: boolean
    status?: boolean
    venus?: boolean
    date?: boolean
    goals?: boolean
    score?: boolean
    fulltime?: boolean
    extratime?: boolean
    penalty?: boolean
  }


  type fixture_roundGetPayload<S extends boolean | null | undefined | fixture_roundArgs> = $Types.GetResult<fixture_roundPayload, S>

  type fixture_roundCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fixture_roundFindManyArgs, 'select' | 'include'> & {
      select?: Fixture_roundCountAggregateInputType | true
    }

  export interface fixture_roundDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fixture_round'], meta: { name: 'fixture_round' } }
    /**
     * Find zero or one Fixture_round that matches the filter.
     * @param {fixture_roundFindUniqueArgs} args - Arguments to find a Fixture_round
     * @example
     * // Get one Fixture_round
     * const fixture_round = await prisma.fixture_round.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fixture_roundFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, fixture_roundFindUniqueArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Fixture_round that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fixture_roundFindUniqueOrThrowArgs} args - Arguments to find a Fixture_round
     * @example
     * // Get one Fixture_round
     * const fixture_round = await prisma.fixture_round.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fixture_roundFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fixture_roundFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Fixture_round that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixture_roundFindFirstArgs} args - Arguments to find a Fixture_round
     * @example
     * // Get one Fixture_round
     * const fixture_round = await prisma.fixture_round.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fixture_roundFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, fixture_roundFindFirstArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Fixture_round that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixture_roundFindFirstOrThrowArgs} args - Arguments to find a Fixture_round
     * @example
     * // Get one Fixture_round
     * const fixture_round = await prisma.fixture_round.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fixture_roundFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fixture_roundFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Fixture_rounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixture_roundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fixture_rounds
     * const fixture_rounds = await prisma.fixture_round.findMany()
     * 
     * // Get first 10 Fixture_rounds
     * const fixture_rounds = await prisma.fixture_round.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fixture_roundWithIdOnly = await prisma.fixture_round.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fixture_roundFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fixture_roundFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Fixture_round.
     * @param {fixture_roundCreateArgs} args - Arguments to create a Fixture_round.
     * @example
     * // Create one Fixture_round
     * const Fixture_round = await prisma.fixture_round.create({
     *   data: {
     *     // ... data to create a Fixture_round
     *   }
     * })
     * 
    **/
    create<T extends fixture_roundCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fixture_roundCreateArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Fixture_rounds.
     *     @param {fixture_roundCreateManyArgs} args - Arguments to create many Fixture_rounds.
     *     @example
     *     // Create many Fixture_rounds
     *     const fixture_round = await prisma.fixture_round.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fixture_roundCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fixture_roundCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fixture_round.
     * @param {fixture_roundDeleteArgs} args - Arguments to delete one Fixture_round.
     * @example
     * // Delete one Fixture_round
     * const Fixture_round = await prisma.fixture_round.delete({
     *   where: {
     *     // ... filter to delete one Fixture_round
     *   }
     * })
     * 
    **/
    delete<T extends fixture_roundDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fixture_roundDeleteArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Fixture_round.
     * @param {fixture_roundUpdateArgs} args - Arguments to update one Fixture_round.
     * @example
     * // Update one Fixture_round
     * const fixture_round = await prisma.fixture_round.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fixture_roundUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fixture_roundUpdateArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Fixture_rounds.
     * @param {fixture_roundDeleteManyArgs} args - Arguments to filter Fixture_rounds to delete.
     * @example
     * // Delete a few Fixture_rounds
     * const { count } = await prisma.fixture_round.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fixture_roundDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fixture_roundDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fixture_rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixture_roundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fixture_rounds
     * const fixture_round = await prisma.fixture_round.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fixture_roundUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fixture_roundUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fixture_round.
     * @param {fixture_roundUpsertArgs} args - Arguments to update or create a Fixture_round.
     * @example
     * // Update or create a Fixture_round
     * const fixture_round = await prisma.fixture_round.upsert({
     *   create: {
     *     // ... data to create a Fixture_round
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fixture_round we want to update
     *   }
     * })
    **/
    upsert<T extends fixture_roundUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fixture_roundUpsertArgs<ExtArgs>>
    ): Prisma__fixture_roundClient<$Types.GetResult<fixture_roundPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Fixture_rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixture_roundCountArgs} args - Arguments to filter Fixture_rounds to count.
     * @example
     * // Count the number of Fixture_rounds
     * const count = await prisma.fixture_round.count({
     *   where: {
     *     // ... the filter for the Fixture_rounds we want to count
     *   }
     * })
    **/
    count<T extends fixture_roundCountArgs>(
      args?: Subset<T, fixture_roundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fixture_roundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fixture_round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fixture_roundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fixture_roundAggregateArgs>(args: Subset<T, Fixture_roundAggregateArgs>): Prisma.PrismaPromise<GetFixture_roundAggregateType<T>>

    /**
     * Group by Fixture_round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixture_roundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fixture_roundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fixture_roundGroupByArgs['orderBy'] }
        : { orderBy?: fixture_roundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fixture_roundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixture_roundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fixture_round model
   */
  readonly fields: fixture_roundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fixture_round.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fixture_roundClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the fixture_round model
   */ 
  interface fixture_roundFieldRefs {
    readonly id: FieldRef<"fixture_round", 'Int'>
    readonly round: FieldRef<"fixture_round", 'String'>
    readonly seasson: FieldRef<"fixture_round", 'Int'>
    readonly league: FieldRef<"fixture_round", 'Json'>
    readonly leagues_teams_id: FieldRef<"fixture_round", 'Int'>
    readonly status: FieldRef<"fixture_round", 'Json'>
    readonly venus: FieldRef<"fixture_round", 'Json'>
    readonly date: FieldRef<"fixture_round", 'DateTime'>
    readonly goals: FieldRef<"fixture_round", 'Json'>
    readonly score: FieldRef<"fixture_round", 'Json'>
    readonly fulltime: FieldRef<"fixture_round", 'Json'>
    readonly extratime: FieldRef<"fixture_round", 'Json'>
    readonly penalty: FieldRef<"fixture_round", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * fixture_round findUnique
   */
  export type fixture_roundFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * Filter, which fixture_round to fetch.
     */
    where: fixture_roundWhereUniqueInput
  }


  /**
   * fixture_round findUniqueOrThrow
   */
  export type fixture_roundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * Filter, which fixture_round to fetch.
     */
    where: fixture_roundWhereUniqueInput
  }


  /**
   * fixture_round findFirst
   */
  export type fixture_roundFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * Filter, which fixture_round to fetch.
     */
    where?: fixture_roundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixture_rounds to fetch.
     */
    orderBy?: fixture_roundOrderByWithRelationInput | fixture_roundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fixture_rounds.
     */
    cursor?: fixture_roundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixture_rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixture_rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fixture_rounds.
     */
    distinct?: Fixture_roundScalarFieldEnum | Fixture_roundScalarFieldEnum[]
  }


  /**
   * fixture_round findFirstOrThrow
   */
  export type fixture_roundFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * Filter, which fixture_round to fetch.
     */
    where?: fixture_roundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixture_rounds to fetch.
     */
    orderBy?: fixture_roundOrderByWithRelationInput | fixture_roundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fixture_rounds.
     */
    cursor?: fixture_roundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixture_rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixture_rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fixture_rounds.
     */
    distinct?: Fixture_roundScalarFieldEnum | Fixture_roundScalarFieldEnum[]
  }


  /**
   * fixture_round findMany
   */
  export type fixture_roundFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * Filter, which fixture_rounds to fetch.
     */
    where?: fixture_roundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixture_rounds to fetch.
     */
    orderBy?: fixture_roundOrderByWithRelationInput | fixture_roundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fixture_rounds.
     */
    cursor?: fixture_roundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixture_rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixture_rounds.
     */
    skip?: number
    distinct?: Fixture_roundScalarFieldEnum | Fixture_roundScalarFieldEnum[]
  }


  /**
   * fixture_round create
   */
  export type fixture_roundCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * The data needed to create a fixture_round.
     */
    data: XOR<fixture_roundCreateInput, fixture_roundUncheckedCreateInput>
  }


  /**
   * fixture_round createMany
   */
  export type fixture_roundCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fixture_rounds.
     */
    data: fixture_roundCreateManyInput | fixture_roundCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fixture_round update
   */
  export type fixture_roundUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * The data needed to update a fixture_round.
     */
    data: XOR<fixture_roundUpdateInput, fixture_roundUncheckedUpdateInput>
    /**
     * Choose, which fixture_round to update.
     */
    where: fixture_roundWhereUniqueInput
  }


  /**
   * fixture_round updateMany
   */
  export type fixture_roundUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fixture_rounds.
     */
    data: XOR<fixture_roundUpdateManyMutationInput, fixture_roundUncheckedUpdateManyInput>
    /**
     * Filter which fixture_rounds to update
     */
    where?: fixture_roundWhereInput
  }


  /**
   * fixture_round upsert
   */
  export type fixture_roundUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * The filter to search for the fixture_round to update in case it exists.
     */
    where: fixture_roundWhereUniqueInput
    /**
     * In case the fixture_round found by the `where` argument doesn't exist, create a new fixture_round with this data.
     */
    create: XOR<fixture_roundCreateInput, fixture_roundUncheckedCreateInput>
    /**
     * In case the fixture_round was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fixture_roundUpdateInput, fixture_roundUncheckedUpdateInput>
  }


  /**
   * fixture_round delete
   */
  export type fixture_roundDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
    /**
     * Filter which fixture_round to delete.
     */
    where: fixture_roundWhereUniqueInput
  }


  /**
   * fixture_round deleteMany
   */
  export type fixture_roundDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fixture_rounds to delete
     */
    where?: fixture_roundWhereInput
  }


  /**
   * fixture_round without action
   */
  export type fixture_roundArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixture_round
     */
    select?: fixture_roundSelect<ExtArgs> | null
  }



  /**
   * Model football_players
   */


  export type AggregateFootball_players = {
    _count: Football_playersCountAggregateOutputType | null
    _avg: Football_playersAvgAggregateOutputType | null
    _sum: Football_playersSumAggregateOutputType | null
    _min: Football_playersMinAggregateOutputType | null
    _max: Football_playersMaxAggregateOutputType | null
  }

  export type Football_playersAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type Football_playersSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type Football_playersMinAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    age: number | null
    nationality: string | null
    height: string | null
    weight: string | null
    injured: boolean | null
    photo: string | null
  }

  export type Football_playersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    age: number | null
    nationality: string | null
    height: string | null
    weight: string | null
    injured: boolean | null
    photo: string | null
  }

  export type Football_playersCountAggregateOutputType = {
    id: number
    name: number
    lastname: number
    age: number
    birth: number
    nationality: number
    height: number
    weight: number
    injured: number
    photo: number
    statistics: number
    _all: number
  }


  export type Football_playersAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type Football_playersSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type Football_playersMinAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    age?: true
    nationality?: true
    height?: true
    weight?: true
    injured?: true
    photo?: true
  }

  export type Football_playersMaxAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    age?: true
    nationality?: true
    height?: true
    weight?: true
    injured?: true
    photo?: true
  }

  export type Football_playersCountAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    age?: true
    birth?: true
    nationality?: true
    height?: true
    weight?: true
    injured?: true
    photo?: true
    statistics?: true
    _all?: true
  }

  export type Football_playersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which football_players to aggregate.
     */
    where?: football_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of football_players to fetch.
     */
    orderBy?: football_playersOrderByWithRelationInput | football_playersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: football_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` football_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` football_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned football_players
    **/
    _count?: true | Football_playersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Football_playersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Football_playersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Football_playersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Football_playersMaxAggregateInputType
  }

  export type GetFootball_playersAggregateType<T extends Football_playersAggregateArgs> = {
        [P in keyof T & keyof AggregateFootball_players]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFootball_players[P]>
      : GetScalarType<T[P], AggregateFootball_players[P]>
  }




  export type football_playersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: football_playersWhereInput
    orderBy?: football_playersOrderByWithAggregationInput | football_playersOrderByWithAggregationInput[]
    by: Football_playersScalarFieldEnum[] | Football_playersScalarFieldEnum
    having?: football_playersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Football_playersCountAggregateInputType | true
    _avg?: Football_playersAvgAggregateInputType
    _sum?: Football_playersSumAggregateInputType
    _min?: Football_playersMinAggregateInputType
    _max?: Football_playersMaxAggregateInputType
  }


  export type Football_playersGroupByOutputType = {
    id: number
    name: string
    lastname: string
    age: number
    birth: JsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: JsonValue
    _count: Football_playersCountAggregateOutputType | null
    _avg: Football_playersAvgAggregateOutputType | null
    _sum: Football_playersSumAggregateOutputType | null
    _min: Football_playersMinAggregateOutputType | null
    _max: Football_playersMaxAggregateOutputType | null
  }

  type GetFootball_playersGroupByPayload<T extends football_playersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Football_playersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Football_playersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Football_playersGroupByOutputType[P]>
            : GetScalarType<T[P], Football_playersGroupByOutputType[P]>
        }
      >
    >


  export type football_playersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    age?: boolean
    birth?: boolean
    nationality?: boolean
    height?: boolean
    weight?: boolean
    injured?: boolean
    photo?: boolean
    statistics?: boolean
    team_player?: boolean | football_players$team_playerArgs<ExtArgs>
    _count?: boolean | Football_playersCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["football_players"]>

  export type football_playersSelectScalar = {
    id?: boolean
    name?: boolean
    lastname?: boolean
    age?: boolean
    birth?: boolean
    nationality?: boolean
    height?: boolean
    weight?: boolean
    injured?: boolean
    photo?: boolean
    statistics?: boolean
  }

  export type football_playersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team_player?: boolean | football_players$team_playerArgs<ExtArgs>
    _count?: boolean | Football_playersCountOutputTypeArgs<ExtArgs>
  }


  type football_playersGetPayload<S extends boolean | null | undefined | football_playersArgs> = $Types.GetResult<football_playersPayload, S>

  type football_playersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<football_playersFindManyArgs, 'select' | 'include'> & {
      select?: Football_playersCountAggregateInputType | true
    }

  export interface football_playersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['football_players'], meta: { name: 'football_players' } }
    /**
     * Find zero or one Football_players that matches the filter.
     * @param {football_playersFindUniqueArgs} args - Arguments to find a Football_players
     * @example
     * // Get one Football_players
     * const football_players = await prisma.football_players.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends football_playersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, football_playersFindUniqueArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Football_players that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {football_playersFindUniqueOrThrowArgs} args - Arguments to find a Football_players
     * @example
     * // Get one Football_players
     * const football_players = await prisma.football_players.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends football_playersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, football_playersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Football_players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {football_playersFindFirstArgs} args - Arguments to find a Football_players
     * @example
     * // Get one Football_players
     * const football_players = await prisma.football_players.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends football_playersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, football_playersFindFirstArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Football_players that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {football_playersFindFirstOrThrowArgs} args - Arguments to find a Football_players
     * @example
     * // Get one Football_players
     * const football_players = await prisma.football_players.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends football_playersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, football_playersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Football_players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {football_playersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Football_players
     * const football_players = await prisma.football_players.findMany()
     * 
     * // Get first 10 Football_players
     * const football_players = await prisma.football_players.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const football_playersWithIdOnly = await prisma.football_players.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends football_playersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, football_playersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Football_players.
     * @param {football_playersCreateArgs} args - Arguments to create a Football_players.
     * @example
     * // Create one Football_players
     * const Football_players = await prisma.football_players.create({
     *   data: {
     *     // ... data to create a Football_players
     *   }
     * })
     * 
    **/
    create<T extends football_playersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, football_playersCreateArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Football_players.
     *     @param {football_playersCreateManyArgs} args - Arguments to create many Football_players.
     *     @example
     *     // Create many Football_players
     *     const football_players = await prisma.football_players.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends football_playersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, football_playersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Football_players.
     * @param {football_playersDeleteArgs} args - Arguments to delete one Football_players.
     * @example
     * // Delete one Football_players
     * const Football_players = await prisma.football_players.delete({
     *   where: {
     *     // ... filter to delete one Football_players
     *   }
     * })
     * 
    **/
    delete<T extends football_playersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, football_playersDeleteArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Football_players.
     * @param {football_playersUpdateArgs} args - Arguments to update one Football_players.
     * @example
     * // Update one Football_players
     * const football_players = await prisma.football_players.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends football_playersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, football_playersUpdateArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Football_players.
     * @param {football_playersDeleteManyArgs} args - Arguments to filter Football_players to delete.
     * @example
     * // Delete a few Football_players
     * const { count } = await prisma.football_players.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends football_playersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, football_playersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Football_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {football_playersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Football_players
     * const football_players = await prisma.football_players.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends football_playersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, football_playersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Football_players.
     * @param {football_playersUpsertArgs} args - Arguments to update or create a Football_players.
     * @example
     * // Update or create a Football_players
     * const football_players = await prisma.football_players.upsert({
     *   create: {
     *     // ... data to create a Football_players
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Football_players we want to update
     *   }
     * })
    **/
    upsert<T extends football_playersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, football_playersUpsertArgs<ExtArgs>>
    ): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Football_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {football_playersCountArgs} args - Arguments to filter Football_players to count.
     * @example
     * // Count the number of Football_players
     * const count = await prisma.football_players.count({
     *   where: {
     *     // ... the filter for the Football_players we want to count
     *   }
     * })
    **/
    count<T extends football_playersCountArgs>(
      args?: Subset<T, football_playersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Football_playersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Football_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Football_playersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Football_playersAggregateArgs>(args: Subset<T, Football_playersAggregateArgs>): Prisma.PrismaPromise<GetFootball_playersAggregateType<T>>

    /**
     * Group by Football_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {football_playersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends football_playersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: football_playersGroupByArgs['orderBy'] }
        : { orderBy?: football_playersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, football_playersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFootball_playersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the football_players model
   */
  readonly fields: football_playersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for football_players.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__football_playersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    team_player<T extends football_players$team_playerArgs<ExtArgs> = {}>(args?: Subset<T, football_players$team_playerArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the football_players model
   */ 
  interface football_playersFieldRefs {
    readonly id: FieldRef<"football_players", 'Int'>
    readonly name: FieldRef<"football_players", 'String'>
    readonly lastname: FieldRef<"football_players", 'String'>
    readonly age: FieldRef<"football_players", 'Int'>
    readonly birth: FieldRef<"football_players", 'Json'>
    readonly nationality: FieldRef<"football_players", 'String'>
    readonly height: FieldRef<"football_players", 'String'>
    readonly weight: FieldRef<"football_players", 'String'>
    readonly injured: FieldRef<"football_players", 'Boolean'>
    readonly photo: FieldRef<"football_players", 'String'>
    readonly statistics: FieldRef<"football_players", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * football_players findUnique
   */
  export type football_playersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * Filter, which football_players to fetch.
     */
    where: football_playersWhereUniqueInput
  }


  /**
   * football_players findUniqueOrThrow
   */
  export type football_playersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * Filter, which football_players to fetch.
     */
    where: football_playersWhereUniqueInput
  }


  /**
   * football_players findFirst
   */
  export type football_playersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * Filter, which football_players to fetch.
     */
    where?: football_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of football_players to fetch.
     */
    orderBy?: football_playersOrderByWithRelationInput | football_playersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for football_players.
     */
    cursor?: football_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` football_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` football_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of football_players.
     */
    distinct?: Football_playersScalarFieldEnum | Football_playersScalarFieldEnum[]
  }


  /**
   * football_players findFirstOrThrow
   */
  export type football_playersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * Filter, which football_players to fetch.
     */
    where?: football_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of football_players to fetch.
     */
    orderBy?: football_playersOrderByWithRelationInput | football_playersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for football_players.
     */
    cursor?: football_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` football_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` football_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of football_players.
     */
    distinct?: Football_playersScalarFieldEnum | Football_playersScalarFieldEnum[]
  }


  /**
   * football_players findMany
   */
  export type football_playersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * Filter, which football_players to fetch.
     */
    where?: football_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of football_players to fetch.
     */
    orderBy?: football_playersOrderByWithRelationInput | football_playersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing football_players.
     */
    cursor?: football_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` football_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` football_players.
     */
    skip?: number
    distinct?: Football_playersScalarFieldEnum | Football_playersScalarFieldEnum[]
  }


  /**
   * football_players create
   */
  export type football_playersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * The data needed to create a football_players.
     */
    data: XOR<football_playersCreateInput, football_playersUncheckedCreateInput>
  }


  /**
   * football_players createMany
   */
  export type football_playersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many football_players.
     */
    data: football_playersCreateManyInput | football_playersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * football_players update
   */
  export type football_playersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * The data needed to update a football_players.
     */
    data: XOR<football_playersUpdateInput, football_playersUncheckedUpdateInput>
    /**
     * Choose, which football_players to update.
     */
    where: football_playersWhereUniqueInput
  }


  /**
   * football_players updateMany
   */
  export type football_playersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update football_players.
     */
    data: XOR<football_playersUpdateManyMutationInput, football_playersUncheckedUpdateManyInput>
    /**
     * Filter which football_players to update
     */
    where?: football_playersWhereInput
  }


  /**
   * football_players upsert
   */
  export type football_playersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * The filter to search for the football_players to update in case it exists.
     */
    where: football_playersWhereUniqueInput
    /**
     * In case the football_players found by the `where` argument doesn't exist, create a new football_players with this data.
     */
    create: XOR<football_playersCreateInput, football_playersUncheckedCreateInput>
    /**
     * In case the football_players was found with the provided `where` argument, update it with this data.
     */
    update: XOR<football_playersUpdateInput, football_playersUncheckedUpdateInput>
  }


  /**
   * football_players delete
   */
  export type football_playersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
    /**
     * Filter which football_players to delete.
     */
    where: football_playersWhereUniqueInput
  }


  /**
   * football_players deleteMany
   */
  export type football_playersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which football_players to delete
     */
    where?: football_playersWhereInput
  }


  /**
   * football_players.team_player
   */
  export type football_players$team_playerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    where?: team_playerWhereInput
    orderBy?: team_playerOrderByWithRelationInput | team_playerOrderByWithRelationInput[]
    cursor?: team_playerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_playerScalarFieldEnum | Team_playerScalarFieldEnum[]
  }


  /**
   * football_players without action
   */
  export type football_playersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the football_players
     */
    select?: football_playersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: football_playersInclude<ExtArgs> | null
  }



  /**
   * Model team_player
   */


  export type AggregateTeam_player = {
    _count: Team_playerCountAggregateOutputType | null
    _avg: Team_playerAvgAggregateOutputType | null
    _sum: Team_playerSumAggregateOutputType | null
    _min: Team_playerMinAggregateOutputType | null
    _max: Team_playerMaxAggregateOutputType | null
  }

  export type Team_playerAvgAggregateOutputType = {
    id: number | null
    team_id: number | null
    player_id: number | null
  }

  export type Team_playerSumAggregateOutputType = {
    id: number | null
    team_id: number | null
    player_id: number | null
  }

  export type Team_playerMinAggregateOutputType = {
    id: number | null
    team_id: number | null
    player_id: number | null
  }

  export type Team_playerMaxAggregateOutputType = {
    id: number | null
    team_id: number | null
    player_id: number | null
  }

  export type Team_playerCountAggregateOutputType = {
    id: number
    team_id: number
    player_id: number
    _all: number
  }


  export type Team_playerAvgAggregateInputType = {
    id?: true
    team_id?: true
    player_id?: true
  }

  export type Team_playerSumAggregateInputType = {
    id?: true
    team_id?: true
    player_id?: true
  }

  export type Team_playerMinAggregateInputType = {
    id?: true
    team_id?: true
    player_id?: true
  }

  export type Team_playerMaxAggregateInputType = {
    id?: true
    team_id?: true
    player_id?: true
  }

  export type Team_playerCountAggregateInputType = {
    id?: true
    team_id?: true
    player_id?: true
    _all?: true
  }

  export type Team_playerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_player to aggregate.
     */
    where?: team_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_players to fetch.
     */
    orderBy?: team_playerOrderByWithRelationInput | team_playerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_players
    **/
    _count?: true | Team_playerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Team_playerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Team_playerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_playerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_playerMaxAggregateInputType
  }

  export type GetTeam_playerAggregateType<T extends Team_playerAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_player]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_player[P]>
      : GetScalarType<T[P], AggregateTeam_player[P]>
  }




  export type team_playerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: team_playerWhereInput
    orderBy?: team_playerOrderByWithAggregationInput | team_playerOrderByWithAggregationInput[]
    by: Team_playerScalarFieldEnum[] | Team_playerScalarFieldEnum
    having?: team_playerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_playerCountAggregateInputType | true
    _avg?: Team_playerAvgAggregateInputType
    _sum?: Team_playerSumAggregateInputType
    _min?: Team_playerMinAggregateInputType
    _max?: Team_playerMaxAggregateInputType
  }


  export type Team_playerGroupByOutputType = {
    id: number
    team_id: number
    player_id: number
    _count: Team_playerCountAggregateOutputType | null
    _avg: Team_playerAvgAggregateOutputType | null
    _sum: Team_playerSumAggregateOutputType | null
    _min: Team_playerMinAggregateOutputType | null
    _max: Team_playerMaxAggregateOutputType | null
  }

  type GetTeam_playerGroupByPayload<T extends team_playerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_playerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_playerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_playerGroupByOutputType[P]>
            : GetScalarType<T[P], Team_playerGroupByOutputType[P]>
        }
      >
    >


  export type team_playerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    team_id?: boolean
    player_id?: boolean
    teamid?: boolean | teamArgs<ExtArgs>
    playerid?: boolean | football_playersArgs<ExtArgs>
  }, ExtArgs["result"]["team_player"]>

  export type team_playerSelectScalar = {
    id?: boolean
    team_id?: boolean
    player_id?: boolean
  }

  export type team_playerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    teamid?: boolean | teamArgs<ExtArgs>
    playerid?: boolean | football_playersArgs<ExtArgs>
  }


  type team_playerGetPayload<S extends boolean | null | undefined | team_playerArgs> = $Types.GetResult<team_playerPayload, S>

  type team_playerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<team_playerFindManyArgs, 'select' | 'include'> & {
      select?: Team_playerCountAggregateInputType | true
    }

  export interface team_playerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_player'], meta: { name: 'team_player' } }
    /**
     * Find zero or one Team_player that matches the filter.
     * @param {team_playerFindUniqueArgs} args - Arguments to find a Team_player
     * @example
     * // Get one Team_player
     * const team_player = await prisma.team_player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends team_playerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, team_playerFindUniqueArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team_player that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {team_playerFindUniqueOrThrowArgs} args - Arguments to find a Team_player
     * @example
     * // Get one Team_player
     * const team_player = await prisma.team_player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends team_playerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_playerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team_player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_playerFindFirstArgs} args - Arguments to find a Team_player
     * @example
     * // Get one Team_player
     * const team_player = await prisma.team_player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends team_playerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, team_playerFindFirstArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team_player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_playerFindFirstOrThrowArgs} args - Arguments to find a Team_player
     * @example
     * // Get one Team_player
     * const team_player = await prisma.team_player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends team_playerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, team_playerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Team_players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_playerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_players
     * const team_players = await prisma.team_player.findMany()
     * 
     * // Get first 10 Team_players
     * const team_players = await prisma.team_player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const team_playerWithIdOnly = await prisma.team_player.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends team_playerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_playerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team_player.
     * @param {team_playerCreateArgs} args - Arguments to create a Team_player.
     * @example
     * // Create one Team_player
     * const Team_player = await prisma.team_player.create({
     *   data: {
     *     // ... data to create a Team_player
     *   }
     * })
     * 
    **/
    create<T extends team_playerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, team_playerCreateArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Team_players.
     *     @param {team_playerCreateManyArgs} args - Arguments to create many Team_players.
     *     @example
     *     // Create many Team_players
     *     const team_player = await prisma.team_player.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends team_playerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_playerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_player.
     * @param {team_playerDeleteArgs} args - Arguments to delete one Team_player.
     * @example
     * // Delete one Team_player
     * const Team_player = await prisma.team_player.delete({
     *   where: {
     *     // ... filter to delete one Team_player
     *   }
     * })
     * 
    **/
    delete<T extends team_playerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, team_playerDeleteArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team_player.
     * @param {team_playerUpdateArgs} args - Arguments to update one Team_player.
     * @example
     * // Update one Team_player
     * const team_player = await prisma.team_player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends team_playerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, team_playerUpdateArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Team_players.
     * @param {team_playerDeleteManyArgs} args - Arguments to filter Team_players to delete.
     * @example
     * // Delete a few Team_players
     * const { count } = await prisma.team_player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends team_playerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, team_playerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_playerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_players
     * const team_player = await prisma.team_player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends team_playerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, team_playerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_player.
     * @param {team_playerUpsertArgs} args - Arguments to update or create a Team_player.
     * @example
     * // Update or create a Team_player
     * const team_player = await prisma.team_player.upsert({
     *   create: {
     *     // ... data to create a Team_player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_player we want to update
     *   }
     * })
    **/
    upsert<T extends team_playerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, team_playerUpsertArgs<ExtArgs>>
    ): Prisma__team_playerClient<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Team_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_playerCountArgs} args - Arguments to filter Team_players to count.
     * @example
     * // Count the number of Team_players
     * const count = await prisma.team_player.count({
     *   where: {
     *     // ... the filter for the Team_players we want to count
     *   }
     * })
    **/
    count<T extends team_playerCountArgs>(
      args?: Subset<T, team_playerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_playerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_playerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_playerAggregateArgs>(args: Subset<T, Team_playerAggregateArgs>): Prisma.PrismaPromise<GetTeam_playerAggregateType<T>>

    /**
     * Group by Team_player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_playerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_playerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_playerGroupByArgs['orderBy'] }
        : { orderBy?: team_playerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_playerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_playerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_player model
   */
  readonly fields: team_playerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__team_playerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    teamid<T extends teamArgs<ExtArgs> = {}>(args?: Subset<T, teamArgs<ExtArgs>>): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    playerid<T extends football_playersArgs<ExtArgs> = {}>(args?: Subset<T, football_playersArgs<ExtArgs>>): Prisma__football_playersClient<$Types.GetResult<football_playersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the team_player model
   */ 
  interface team_playerFieldRefs {
    readonly id: FieldRef<"team_player", 'Int'>
    readonly team_id: FieldRef<"team_player", 'Int'>
    readonly player_id: FieldRef<"team_player", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * team_player findUnique
   */
  export type team_playerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * Filter, which team_player to fetch.
     */
    where: team_playerWhereUniqueInput
  }


  /**
   * team_player findUniqueOrThrow
   */
  export type team_playerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * Filter, which team_player to fetch.
     */
    where: team_playerWhereUniqueInput
  }


  /**
   * team_player findFirst
   */
  export type team_playerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * Filter, which team_player to fetch.
     */
    where?: team_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_players to fetch.
     */
    orderBy?: team_playerOrderByWithRelationInput | team_playerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_players.
     */
    cursor?: team_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_players.
     */
    distinct?: Team_playerScalarFieldEnum | Team_playerScalarFieldEnum[]
  }


  /**
   * team_player findFirstOrThrow
   */
  export type team_playerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * Filter, which team_player to fetch.
     */
    where?: team_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_players to fetch.
     */
    orderBy?: team_playerOrderByWithRelationInput | team_playerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_players.
     */
    cursor?: team_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_players.
     */
    distinct?: Team_playerScalarFieldEnum | Team_playerScalarFieldEnum[]
  }


  /**
   * team_player findMany
   */
  export type team_playerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * Filter, which team_players to fetch.
     */
    where?: team_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_players to fetch.
     */
    orderBy?: team_playerOrderByWithRelationInput | team_playerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_players.
     */
    cursor?: team_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_players.
     */
    skip?: number
    distinct?: Team_playerScalarFieldEnum | Team_playerScalarFieldEnum[]
  }


  /**
   * team_player create
   */
  export type team_playerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * The data needed to create a team_player.
     */
    data: XOR<team_playerCreateInput, team_playerUncheckedCreateInput>
  }


  /**
   * team_player createMany
   */
  export type team_playerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_players.
     */
    data: team_playerCreateManyInput | team_playerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team_player update
   */
  export type team_playerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * The data needed to update a team_player.
     */
    data: XOR<team_playerUpdateInput, team_playerUncheckedUpdateInput>
    /**
     * Choose, which team_player to update.
     */
    where: team_playerWhereUniqueInput
  }


  /**
   * team_player updateMany
   */
  export type team_playerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_players.
     */
    data: XOR<team_playerUpdateManyMutationInput, team_playerUncheckedUpdateManyInput>
    /**
     * Filter which team_players to update
     */
    where?: team_playerWhereInput
  }


  /**
   * team_player upsert
   */
  export type team_playerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * The filter to search for the team_player to update in case it exists.
     */
    where: team_playerWhereUniqueInput
    /**
     * In case the team_player found by the `where` argument doesn't exist, create a new team_player with this data.
     */
    create: XOR<team_playerCreateInput, team_playerUncheckedCreateInput>
    /**
     * In case the team_player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_playerUpdateInput, team_playerUncheckedUpdateInput>
  }


  /**
   * team_player delete
   */
  export type team_playerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    /**
     * Filter which team_player to delete.
     */
    where: team_playerWhereUniqueInput
  }


  /**
   * team_player deleteMany
   */
  export type team_playerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_players to delete
     */
    where?: team_playerWhereInput
  }


  /**
   * team_player without action
   */
  export type team_playerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
  }



  /**
   * Model product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    userid: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    userid: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    userid: number | null
    createdat: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    userid: number | null
    createdat: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    userid: number
    createdat: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    userid?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    userid?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    userid?: true
    createdat?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    userid?: true
    createdat?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    userid?: true
    createdat?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string
    price: number
    userid: number
    createdat: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userArgs<ExtArgs>
    orders?: boolean | product$ordersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    userid?: boolean
    createdat?: boolean
  }

  export type productInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    orders?: boolean | product$ordersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }


  type productGetPayload<S extends boolean | null | undefined | productArgs> = $Types.GetResult<productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productCreateArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productDeleteArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productUpsertArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    orders<T extends product$ordersArgs<ExtArgs> = {}>(args?: Subset<T, product$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<orderPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the product model
   */ 
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'Int'>
    readonly name: FieldRef<"product", 'String'>
    readonly description: FieldRef<"product", 'String'>
    readonly price: FieldRef<"product", 'Float'>
    readonly userid: FieldRef<"product", 'Int'>
    readonly createdat: FieldRef<"product", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product.orders
   */
  export type product$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * product without action
   */
  export type productArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
  }



  /**
   * Model order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    productid: number | null
    userid: number | null
    quantity: number | null
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    productid: number | null
    userid: number | null
    quantity: number | null
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    productid: number | null
    userid: number | null
    quantity: number | null
    total: number | null
    createdat: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    productid: number | null
    userid: number | null
    quantity: number | null
    total: number | null
    createdat: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    productid: number
    userid: number
    quantity: number
    total: number
    createdat: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    productid?: true
    userid?: true
    quantity?: true
    total?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    productid?: true
    userid?: true
    quantity?: true
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    productid?: true
    userid?: true
    quantity?: true
    total?: true
    createdat?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    productid?: true
    userid?: true
    quantity?: true
    total?: true
    createdat?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    productid?: true
    userid?: true
    quantity?: true
    total?: true
    createdat?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which order to aggregate.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type orderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
    orderBy?: orderOrderByWithAggregationInput | orderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    productid: number
    userid: number
    quantity: number
    total: number
    createdat: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productid?: boolean
    userid?: boolean
    quantity?: boolean
    total?: boolean
    createdat?: boolean
    product?: boolean | productArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectScalar = {
    id?: boolean
    productid?: boolean
    userid?: boolean
    quantity?: boolean
    total?: boolean
    createdat?: boolean
  }

  export type orderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | productArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
  }


  type orderGetPayload<S extends boolean | null | undefined | orderArgs> = $Types.GetResult<orderPayload, S>

  type orderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<orderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface orderDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order'], meta: { name: 'order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderFindUniqueArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends orderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<orderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends orderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderCreateArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {orderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends orderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderDeleteArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends orderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpsertArgs<ExtArgs>>
    ): Prisma__orderClient<$Types.GetResult<orderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderGroupByArgs['orderBy'] }
        : { orderBy?: orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order model
   */
  readonly fields: orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__orderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends productArgs<ExtArgs> = {}>(args?: Subset<T, productArgs<ExtArgs>>): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the order model
   */ 
  interface orderFieldRefs {
    readonly id: FieldRef<"order", 'Int'>
    readonly productid: FieldRef<"order", 'Int'>
    readonly userid: FieldRef<"order", 'Int'>
    readonly quantity: FieldRef<"order", 'Int'>
    readonly total: FieldRef<"order", 'Float'>
    readonly createdat: FieldRef<"order", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * order findUnique
   */
  export type orderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order findFirst
   */
  export type orderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order findMany
   */
  export type orderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order create
   */
  export type orderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to create a order.
     */
    data: XOR<orderCreateInput, orderUncheckedCreateInput>
  }


  /**
   * order createMany
   */
  export type orderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: orderCreateManyInput | orderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order update
   */
  export type orderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to update a order.
     */
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order updateMany
   */
  export type orderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
  }


  /**
   * order upsert
   */
  export type orderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The filter to search for the order to update in case it exists.
     */
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     */
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }


  /**
   * order delete
   */
  export type orderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter which order to delete.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: orderWhereInput
  }


  /**
   * order without action
   */
  export type orderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
  }



  /**
   * Model wallet
   */


  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    id: number | null
    balance: number | null
    userid: number | null
  }

  export type WalletSumAggregateOutputType = {
    id: number | null
    balance: number | null
    userid: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: number | null
    balance: number | null
    userid: number | null
    createdat: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: number | null
    balance: number | null
    userid: number | null
    createdat: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    balance: number
    userid: number
    createdat: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    id?: true
    balance?: true
    userid?: true
  }

  export type WalletSumAggregateInputType = {
    id?: true
    balance?: true
    userid?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    balance?: true
    userid?: true
    createdat?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    balance?: true
    userid?: true
    createdat?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    balance?: true
    userid?: true
    createdat?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet to aggregate.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type walletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
    orderBy?: walletOrderByWithAggregationInput | walletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }


  export type WalletGroupByOutputType = {
    id: number
    balance: number
    userid: number
    createdat: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends walletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type walletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userArgs<ExtArgs>
    walletmovement?: boolean | wallet$walletmovementArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type walletSelectScalar = {
    id?: boolean
    balance?: boolean
    userid?: boolean
    createdat?: boolean
  }

  export type walletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    walletmovement?: boolean | wallet$walletmovementArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeArgs<ExtArgs>
  }


  type walletGetPayload<S extends boolean | null | undefined | walletArgs> = $Types.GetResult<walletPayload, S>

  type walletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<walletFindManyArgs, 'select' | 'include'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface walletDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet'], meta: { name: 'wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {walletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends walletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, walletFindUniqueArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {walletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends walletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends walletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindFirstArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends walletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends walletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<walletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Wallet.
     * @param {walletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends walletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, walletCreateArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Wallets.
     *     @param {walletCreateManyArgs} args - Arguments to create many Wallets.
     *     @example
     *     // Create many Wallets
     *     const wallet = await prisma.wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends walletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {walletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends walletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, walletDeleteArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {walletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends walletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpdateArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {walletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends walletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends walletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {walletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends walletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpsertArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletCountArgs>(
      args?: Subset<T, walletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletGroupByArgs['orderBy'] }
        : { orderBy?: walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet model
   */
  readonly fields: walletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__walletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    walletmovement<T extends wallet$walletmovementArgs<ExtArgs> = {}>(args?: Subset<T, wallet$walletmovementArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the wallet model
   */ 
  interface walletFieldRefs {
    readonly id: FieldRef<"wallet", 'Int'>
    readonly balance: FieldRef<"wallet", 'Float'>
    readonly userid: FieldRef<"wallet", 'Int'>
    readonly createdat: FieldRef<"wallet", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * wallet findUnique
   */
  export type walletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet findUniqueOrThrow
   */
  export type walletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet findFirst
   */
  export type walletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }


  /**
   * wallet findFirstOrThrow
   */
  export type walletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }


  /**
   * wallet findMany
   */
  export type walletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }


  /**
   * wallet create
   */
  export type walletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet.
     */
    data: XOR<walletCreateInput, walletUncheckedCreateInput>
  }


  /**
   * wallet createMany
   */
  export type walletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * wallet update
   */
  export type walletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet.
     */
    data: XOR<walletUpdateInput, walletUncheckedUpdateInput>
    /**
     * Choose, which wallet to update.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet updateMany
   */
  export type walletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletWhereInput
  }


  /**
   * wallet upsert
   */
  export type walletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet to update in case it exists.
     */
    where: walletWhereUniqueInput
    /**
     * In case the wallet found by the `where` argument doesn't exist, create a new wallet with this data.
     */
    create: XOR<walletCreateInput, walletUncheckedCreateInput>
    /**
     * In case the wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletUpdateInput, walletUncheckedUpdateInput>
  }


  /**
   * wallet delete
   */
  export type walletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter which wallet to delete.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet deleteMany
   */
  export type walletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletWhereInput
  }


  /**
   * wallet.walletmovement
   */
  export type wallet$walletmovementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    where?: walletmovementWhereInput
    orderBy?: walletmovementOrderByWithRelationInput | walletmovementOrderByWithRelationInput[]
    cursor?: walletmovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletmovementScalarFieldEnum | WalletmovementScalarFieldEnum[]
  }


  /**
   * wallet without action
   */
  export type walletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
  }



  /**
   * Model walletmovement
   */


  export type AggregateWalletmovement = {
    _count: WalletmovementCountAggregateOutputType | null
    _avg: WalletmovementAvgAggregateOutputType | null
    _sum: WalletmovementSumAggregateOutputType | null
    _min: WalletmovementMinAggregateOutputType | null
    _max: WalletmovementMaxAggregateOutputType | null
  }

  export type WalletmovementAvgAggregateOutputType = {
    id: number | null
    walletid: number | null
    amount: number | null
  }

  export type WalletmovementSumAggregateOutputType = {
    id: number | null
    walletid: number | null
    amount: number | null
  }

  export type WalletmovementMinAggregateOutputType = {
    id: number | null
    walletid: number | null
    amount: number | null
    movementtype: movementtype | null
    createdat: Date | null
  }

  export type WalletmovementMaxAggregateOutputType = {
    id: number | null
    walletid: number | null
    amount: number | null
    movementtype: movementtype | null
    createdat: Date | null
  }

  export type WalletmovementCountAggregateOutputType = {
    id: number
    walletid: number
    amount: number
    movementtype: number
    createdat: number
    _all: number
  }


  export type WalletmovementAvgAggregateInputType = {
    id?: true
    walletid?: true
    amount?: true
  }

  export type WalletmovementSumAggregateInputType = {
    id?: true
    walletid?: true
    amount?: true
  }

  export type WalletmovementMinAggregateInputType = {
    id?: true
    walletid?: true
    amount?: true
    movementtype?: true
    createdat?: true
  }

  export type WalletmovementMaxAggregateInputType = {
    id?: true
    walletid?: true
    amount?: true
    movementtype?: true
    createdat?: true
  }

  export type WalletmovementCountAggregateInputType = {
    id?: true
    walletid?: true
    amount?: true
    movementtype?: true
    createdat?: true
    _all?: true
  }

  export type WalletmovementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which walletmovement to aggregate.
     */
    where?: walletmovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of walletmovements to fetch.
     */
    orderBy?: walletmovementOrderByWithRelationInput | walletmovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletmovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` walletmovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` walletmovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned walletmovements
    **/
    _count?: true | WalletmovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletmovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletmovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletmovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletmovementMaxAggregateInputType
  }

  export type GetWalletmovementAggregateType<T extends WalletmovementAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletmovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletmovement[P]>
      : GetScalarType<T[P], AggregateWalletmovement[P]>
  }




  export type walletmovementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: walletmovementWhereInput
    orderBy?: walletmovementOrderByWithAggregationInput | walletmovementOrderByWithAggregationInput[]
    by: WalletmovementScalarFieldEnum[] | WalletmovementScalarFieldEnum
    having?: walletmovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletmovementCountAggregateInputType | true
    _avg?: WalletmovementAvgAggregateInputType
    _sum?: WalletmovementSumAggregateInputType
    _min?: WalletmovementMinAggregateInputType
    _max?: WalletmovementMaxAggregateInputType
  }


  export type WalletmovementGroupByOutputType = {
    id: number
    walletid: number
    amount: number
    movementtype: movementtype
    createdat: Date
    _count: WalletmovementCountAggregateOutputType | null
    _avg: WalletmovementAvgAggregateOutputType | null
    _sum: WalletmovementSumAggregateOutputType | null
    _min: WalletmovementMinAggregateOutputType | null
    _max: WalletmovementMaxAggregateOutputType | null
  }

  type GetWalletmovementGroupByPayload<T extends walletmovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletmovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletmovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletmovementGroupByOutputType[P]>
            : GetScalarType<T[P], WalletmovementGroupByOutputType[P]>
        }
      >
    >


  export type walletmovementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletid?: boolean
    amount?: boolean
    movementtype?: boolean
    createdat?: boolean
    wallet?: boolean | walletArgs<ExtArgs>
  }, ExtArgs["result"]["walletmovement"]>

  export type walletmovementSelectScalar = {
    id?: boolean
    walletid?: boolean
    amount?: boolean
    movementtype?: boolean
    createdat?: boolean
  }

  export type walletmovementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    wallet?: boolean | walletArgs<ExtArgs>
  }


  type walletmovementGetPayload<S extends boolean | null | undefined | walletmovementArgs> = $Types.GetResult<walletmovementPayload, S>

  type walletmovementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<walletmovementFindManyArgs, 'select' | 'include'> & {
      select?: WalletmovementCountAggregateInputType | true
    }

  export interface walletmovementDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['walletmovement'], meta: { name: 'walletmovement' } }
    /**
     * Find zero or one Walletmovement that matches the filter.
     * @param {walletmovementFindUniqueArgs} args - Arguments to find a Walletmovement
     * @example
     * // Get one Walletmovement
     * const walletmovement = await prisma.walletmovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends walletmovementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, walletmovementFindUniqueArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Walletmovement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {walletmovementFindUniqueOrThrowArgs} args - Arguments to find a Walletmovement
     * @example
     * // Get one Walletmovement
     * const walletmovement = await prisma.walletmovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends walletmovementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletmovementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Walletmovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletmovementFindFirstArgs} args - Arguments to find a Walletmovement
     * @example
     * // Get one Walletmovement
     * const walletmovement = await prisma.walletmovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends walletmovementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, walletmovementFindFirstArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Walletmovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletmovementFindFirstOrThrowArgs} args - Arguments to find a Walletmovement
     * @example
     * // Get one Walletmovement
     * const walletmovement = await prisma.walletmovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends walletmovementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletmovementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Walletmovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletmovementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Walletmovements
     * const walletmovements = await prisma.walletmovement.findMany()
     * 
     * // Get first 10 Walletmovements
     * const walletmovements = await prisma.walletmovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletmovementWithIdOnly = await prisma.walletmovement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends walletmovementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletmovementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Walletmovement.
     * @param {walletmovementCreateArgs} args - Arguments to create a Walletmovement.
     * @example
     * // Create one Walletmovement
     * const Walletmovement = await prisma.walletmovement.create({
     *   data: {
     *     // ... data to create a Walletmovement
     *   }
     * })
     * 
    **/
    create<T extends walletmovementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, walletmovementCreateArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Walletmovements.
     *     @param {walletmovementCreateManyArgs} args - Arguments to create many Walletmovements.
     *     @example
     *     // Create many Walletmovements
     *     const walletmovement = await prisma.walletmovement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends walletmovementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletmovementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Walletmovement.
     * @param {walletmovementDeleteArgs} args - Arguments to delete one Walletmovement.
     * @example
     * // Delete one Walletmovement
     * const Walletmovement = await prisma.walletmovement.delete({
     *   where: {
     *     // ... filter to delete one Walletmovement
     *   }
     * })
     * 
    **/
    delete<T extends walletmovementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, walletmovementDeleteArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Walletmovement.
     * @param {walletmovementUpdateArgs} args - Arguments to update one Walletmovement.
     * @example
     * // Update one Walletmovement
     * const walletmovement = await prisma.walletmovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends walletmovementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, walletmovementUpdateArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Walletmovements.
     * @param {walletmovementDeleteManyArgs} args - Arguments to filter Walletmovements to delete.
     * @example
     * // Delete a few Walletmovements
     * const { count } = await prisma.walletmovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends walletmovementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletmovementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Walletmovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletmovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Walletmovements
     * const walletmovement = await prisma.walletmovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends walletmovementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, walletmovementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Walletmovement.
     * @param {walletmovementUpsertArgs} args - Arguments to update or create a Walletmovement.
     * @example
     * // Update or create a Walletmovement
     * const walletmovement = await prisma.walletmovement.upsert({
     *   create: {
     *     // ... data to create a Walletmovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Walletmovement we want to update
     *   }
     * })
    **/
    upsert<T extends walletmovementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, walletmovementUpsertArgs<ExtArgs>>
    ): Prisma__walletmovementClient<$Types.GetResult<walletmovementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Walletmovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletmovementCountArgs} args - Arguments to filter Walletmovements to count.
     * @example
     * // Count the number of Walletmovements
     * const count = await prisma.walletmovement.count({
     *   where: {
     *     // ... the filter for the Walletmovements we want to count
     *   }
     * })
    **/
    count<T extends walletmovementCountArgs>(
      args?: Subset<T, walletmovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletmovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Walletmovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletmovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletmovementAggregateArgs>(args: Subset<T, WalletmovementAggregateArgs>): Prisma.PrismaPromise<GetWalletmovementAggregateType<T>>

    /**
     * Group by Walletmovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletmovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletmovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletmovementGroupByArgs['orderBy'] }
        : { orderBy?: walletmovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletmovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletmovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the walletmovement model
   */
  readonly fields: walletmovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for walletmovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__walletmovementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    wallet<T extends walletArgs<ExtArgs> = {}>(args?: Subset<T, walletArgs<ExtArgs>>): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the walletmovement model
   */ 
  interface walletmovementFieldRefs {
    readonly id: FieldRef<"walletmovement", 'Int'>
    readonly walletid: FieldRef<"walletmovement", 'Int'>
    readonly amount: FieldRef<"walletmovement", 'Float'>
    readonly movementtype: FieldRef<"walletmovement", 'movementtype'>
    readonly createdat: FieldRef<"walletmovement", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * walletmovement findUnique
   */
  export type walletmovementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * Filter, which walletmovement to fetch.
     */
    where: walletmovementWhereUniqueInput
  }


  /**
   * walletmovement findUniqueOrThrow
   */
  export type walletmovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * Filter, which walletmovement to fetch.
     */
    where: walletmovementWhereUniqueInput
  }


  /**
   * walletmovement findFirst
   */
  export type walletmovementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * Filter, which walletmovement to fetch.
     */
    where?: walletmovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of walletmovements to fetch.
     */
    orderBy?: walletmovementOrderByWithRelationInput | walletmovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for walletmovements.
     */
    cursor?: walletmovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` walletmovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` walletmovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of walletmovements.
     */
    distinct?: WalletmovementScalarFieldEnum | WalletmovementScalarFieldEnum[]
  }


  /**
   * walletmovement findFirstOrThrow
   */
  export type walletmovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * Filter, which walletmovement to fetch.
     */
    where?: walletmovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of walletmovements to fetch.
     */
    orderBy?: walletmovementOrderByWithRelationInput | walletmovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for walletmovements.
     */
    cursor?: walletmovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` walletmovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` walletmovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of walletmovements.
     */
    distinct?: WalletmovementScalarFieldEnum | WalletmovementScalarFieldEnum[]
  }


  /**
   * walletmovement findMany
   */
  export type walletmovementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * Filter, which walletmovements to fetch.
     */
    where?: walletmovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of walletmovements to fetch.
     */
    orderBy?: walletmovementOrderByWithRelationInput | walletmovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing walletmovements.
     */
    cursor?: walletmovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` walletmovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` walletmovements.
     */
    skip?: number
    distinct?: WalletmovementScalarFieldEnum | WalletmovementScalarFieldEnum[]
  }


  /**
   * walletmovement create
   */
  export type walletmovementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * The data needed to create a walletmovement.
     */
    data: XOR<walletmovementCreateInput, walletmovementUncheckedCreateInput>
  }


  /**
   * walletmovement createMany
   */
  export type walletmovementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many walletmovements.
     */
    data: walletmovementCreateManyInput | walletmovementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * walletmovement update
   */
  export type walletmovementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * The data needed to update a walletmovement.
     */
    data: XOR<walletmovementUpdateInput, walletmovementUncheckedUpdateInput>
    /**
     * Choose, which walletmovement to update.
     */
    where: walletmovementWhereUniqueInput
  }


  /**
   * walletmovement updateMany
   */
  export type walletmovementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update walletmovements.
     */
    data: XOR<walletmovementUpdateManyMutationInput, walletmovementUncheckedUpdateManyInput>
    /**
     * Filter which walletmovements to update
     */
    where?: walletmovementWhereInput
  }


  /**
   * walletmovement upsert
   */
  export type walletmovementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * The filter to search for the walletmovement to update in case it exists.
     */
    where: walletmovementWhereUniqueInput
    /**
     * In case the walletmovement found by the `where` argument doesn't exist, create a new walletmovement with this data.
     */
    create: XOR<walletmovementCreateInput, walletmovementUncheckedCreateInput>
    /**
     * In case the walletmovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletmovementUpdateInput, walletmovementUncheckedUpdateInput>
  }


  /**
   * walletmovement delete
   */
  export type walletmovementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
    /**
     * Filter which walletmovement to delete.
     */
    where: walletmovementWhereUniqueInput
  }


  /**
   * walletmovement deleteMany
   */
  export type walletmovementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which walletmovements to delete
     */
    where?: walletmovementWhereInput
  }


  /**
   * walletmovement without action
   */
  export type walletmovementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the walletmovement
     */
    select?: walletmovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletmovementInclude<ExtArgs> | null
  }



  /**
   * Model leagues
   */


  export type AggregateLeagues = {
    _count: LeaguesCountAggregateOutputType | null
    _avg: LeaguesAvgAggregateOutputType | null
    _sum: LeaguesSumAggregateOutputType | null
    _min: LeaguesMinAggregateOutputType | null
    _max: LeaguesMaxAggregateOutputType | null
  }

  export type LeaguesAvgAggregateOutputType = {
    id: number | null
  }

  export type LeaguesSumAggregateOutputType = {
    id: number | null
  }

  export type LeaguesMinAggregateOutputType = {
    id: number | null
    name: string | null
    cup: typecup | null
    country: string | null
    code: string | null
    flag: string | null
  }

  export type LeaguesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    cup: typecup | null
    country: string | null
    code: string | null
    flag: string | null
  }

  export type LeaguesCountAggregateOutputType = {
    id: number
    name: number
    cup: number
    country: number
    code: number
    flag: number
    _all: number
  }


  export type LeaguesAvgAggregateInputType = {
    id?: true
  }

  export type LeaguesSumAggregateInputType = {
    id?: true
  }

  export type LeaguesMinAggregateInputType = {
    id?: true
    name?: true
    cup?: true
    country?: true
    code?: true
    flag?: true
  }

  export type LeaguesMaxAggregateInputType = {
    id?: true
    name?: true
    cup?: true
    country?: true
    code?: true
    flag?: true
  }

  export type LeaguesCountAggregateInputType = {
    id?: true
    name?: true
    cup?: true
    country?: true
    code?: true
    flag?: true
    _all?: true
  }

  export type LeaguesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which leagues to aggregate.
     */
    where?: leaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leagues to fetch.
     */
    orderBy?: leaguesOrderByWithRelationInput | leaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leagues
    **/
    _count?: true | LeaguesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaguesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaguesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaguesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaguesMaxAggregateInputType
  }

  export type GetLeaguesAggregateType<T extends LeaguesAggregateArgs> = {
        [P in keyof T & keyof AggregateLeagues]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeagues[P]>
      : GetScalarType<T[P], AggregateLeagues[P]>
  }




  export type leaguesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: leaguesWhereInput
    orderBy?: leaguesOrderByWithAggregationInput | leaguesOrderByWithAggregationInput[]
    by: LeaguesScalarFieldEnum[] | LeaguesScalarFieldEnum
    having?: leaguesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaguesCountAggregateInputType | true
    _avg?: LeaguesAvgAggregateInputType
    _sum?: LeaguesSumAggregateInputType
    _min?: LeaguesMinAggregateInputType
    _max?: LeaguesMaxAggregateInputType
  }


  export type LeaguesGroupByOutputType = {
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
    _count: LeaguesCountAggregateOutputType | null
    _avg: LeaguesAvgAggregateOutputType | null
    _sum: LeaguesSumAggregateOutputType | null
    _min: LeaguesMinAggregateOutputType | null
    _max: LeaguesMaxAggregateOutputType | null
  }

  type GetLeaguesGroupByPayload<T extends leaguesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaguesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaguesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaguesGroupByOutputType[P]>
            : GetScalarType<T[P], LeaguesGroupByOutputType[P]>
        }
      >
    >


  export type leaguesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cup?: boolean
    country?: boolean
    code?: boolean
    flag?: boolean
    league_teams?: boolean | leagues$league_teamsArgs<ExtArgs>
    _count?: boolean | LeaguesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["leagues"]>

  export type leaguesSelectScalar = {
    id?: boolean
    name?: boolean
    cup?: boolean
    country?: boolean
    code?: boolean
    flag?: boolean
  }

  export type leaguesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    league_teams?: boolean | leagues$league_teamsArgs<ExtArgs>
    _count?: boolean | LeaguesCountOutputTypeArgs<ExtArgs>
  }


  type leaguesGetPayload<S extends boolean | null | undefined | leaguesArgs> = $Types.GetResult<leaguesPayload, S>

  type leaguesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<leaguesFindManyArgs, 'select' | 'include'> & {
      select?: LeaguesCountAggregateInputType | true
    }

  export interface leaguesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['leagues'], meta: { name: 'leagues' } }
    /**
     * Find zero or one Leagues that matches the filter.
     * @param {leaguesFindUniqueArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends leaguesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, leaguesFindUniqueArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Leagues that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {leaguesFindUniqueOrThrowArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends leaguesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leaguesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaguesFindFirstArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends leaguesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, leaguesFindFirstArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Leagues that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaguesFindFirstOrThrowArgs} args - Arguments to find a Leagues
     * @example
     * // Get one Leagues
     * const leagues = await prisma.leagues.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends leaguesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leaguesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaguesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leagues
     * const leagues = await prisma.leagues.findMany()
     * 
     * // Get first 10 Leagues
     * const leagues = await prisma.leagues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaguesWithIdOnly = await prisma.leagues.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends leaguesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leaguesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Leagues.
     * @param {leaguesCreateArgs} args - Arguments to create a Leagues.
     * @example
     * // Create one Leagues
     * const Leagues = await prisma.leagues.create({
     *   data: {
     *     // ... data to create a Leagues
     *   }
     * })
     * 
    **/
    create<T extends leaguesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, leaguesCreateArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leagues.
     *     @param {leaguesCreateManyArgs} args - Arguments to create many Leagues.
     *     @example
     *     // Create many Leagues
     *     const leagues = await prisma.leagues.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends leaguesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leaguesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leagues.
     * @param {leaguesDeleteArgs} args - Arguments to delete one Leagues.
     * @example
     * // Delete one Leagues
     * const Leagues = await prisma.leagues.delete({
     *   where: {
     *     // ... filter to delete one Leagues
     *   }
     * })
     * 
    **/
    delete<T extends leaguesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, leaguesDeleteArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Leagues.
     * @param {leaguesUpdateArgs} args - Arguments to update one Leagues.
     * @example
     * // Update one Leagues
     * const leagues = await prisma.leagues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends leaguesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, leaguesUpdateArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leagues.
     * @param {leaguesDeleteManyArgs} args - Arguments to filter Leagues to delete.
     * @example
     * // Delete a few Leagues
     * const { count } = await prisma.leagues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends leaguesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leaguesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaguesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leagues
     * const leagues = await prisma.leagues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends leaguesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, leaguesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leagues.
     * @param {leaguesUpsertArgs} args - Arguments to update or create a Leagues.
     * @example
     * // Update or create a Leagues
     * const leagues = await prisma.leagues.upsert({
     *   create: {
     *     // ... data to create a Leagues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leagues we want to update
     *   }
     * })
    **/
    upsert<T extends leaguesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, leaguesUpsertArgs<ExtArgs>>
    ): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaguesCountArgs} args - Arguments to filter Leagues to count.
     * @example
     * // Count the number of Leagues
     * const count = await prisma.leagues.count({
     *   where: {
     *     // ... the filter for the Leagues we want to count
     *   }
     * })
    **/
    count<T extends leaguesCountArgs>(
      args?: Subset<T, leaguesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaguesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaguesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaguesAggregateArgs>(args: Subset<T, LeaguesAggregateArgs>): Prisma.PrismaPromise<GetLeaguesAggregateType<T>>

    /**
     * Group by Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaguesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leaguesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leaguesGroupByArgs['orderBy'] }
        : { orderBy?: leaguesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leaguesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaguesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the leagues model
   */
  readonly fields: leaguesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for leagues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__leaguesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    league_teams<T extends leagues$league_teamsArgs<ExtArgs> = {}>(args?: Subset<T, leagues$league_teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the leagues model
   */ 
  interface leaguesFieldRefs {
    readonly id: FieldRef<"leagues", 'Int'>
    readonly name: FieldRef<"leagues", 'String'>
    readonly cup: FieldRef<"leagues", 'typecup'>
    readonly country: FieldRef<"leagues", 'String'>
    readonly code: FieldRef<"leagues", 'String'>
    readonly flag: FieldRef<"leagues", 'String'>
  }
    

  // Custom InputTypes

  /**
   * leagues findUnique
   */
  export type leaguesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * Filter, which leagues to fetch.
     */
    where: leaguesWhereUniqueInput
  }


  /**
   * leagues findUniqueOrThrow
   */
  export type leaguesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * Filter, which leagues to fetch.
     */
    where: leaguesWhereUniqueInput
  }


  /**
   * leagues findFirst
   */
  export type leaguesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * Filter, which leagues to fetch.
     */
    where?: leaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leagues to fetch.
     */
    orderBy?: leaguesOrderByWithRelationInput | leaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leagues.
     */
    cursor?: leaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leagues.
     */
    distinct?: LeaguesScalarFieldEnum | LeaguesScalarFieldEnum[]
  }


  /**
   * leagues findFirstOrThrow
   */
  export type leaguesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * Filter, which leagues to fetch.
     */
    where?: leaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leagues to fetch.
     */
    orderBy?: leaguesOrderByWithRelationInput | leaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leagues.
     */
    cursor?: leaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leagues.
     */
    distinct?: LeaguesScalarFieldEnum | LeaguesScalarFieldEnum[]
  }


  /**
   * leagues findMany
   */
  export type leaguesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * Filter, which leagues to fetch.
     */
    where?: leaguesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leagues to fetch.
     */
    orderBy?: leaguesOrderByWithRelationInput | leaguesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leagues.
     */
    cursor?: leaguesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leagues.
     */
    skip?: number
    distinct?: LeaguesScalarFieldEnum | LeaguesScalarFieldEnum[]
  }


  /**
   * leagues create
   */
  export type leaguesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * The data needed to create a leagues.
     */
    data: XOR<leaguesCreateInput, leaguesUncheckedCreateInput>
  }


  /**
   * leagues createMany
   */
  export type leaguesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leagues.
     */
    data: leaguesCreateManyInput | leaguesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * leagues update
   */
  export type leaguesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * The data needed to update a leagues.
     */
    data: XOR<leaguesUpdateInput, leaguesUncheckedUpdateInput>
    /**
     * Choose, which leagues to update.
     */
    where: leaguesWhereUniqueInput
  }


  /**
   * leagues updateMany
   */
  export type leaguesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leagues.
     */
    data: XOR<leaguesUpdateManyMutationInput, leaguesUncheckedUpdateManyInput>
    /**
     * Filter which leagues to update
     */
    where?: leaguesWhereInput
  }


  /**
   * leagues upsert
   */
  export type leaguesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * The filter to search for the leagues to update in case it exists.
     */
    where: leaguesWhereUniqueInput
    /**
     * In case the leagues found by the `where` argument doesn't exist, create a new leagues with this data.
     */
    create: XOR<leaguesCreateInput, leaguesUncheckedCreateInput>
    /**
     * In case the leagues was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leaguesUpdateInput, leaguesUncheckedUpdateInput>
  }


  /**
   * leagues delete
   */
  export type leaguesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
    /**
     * Filter which leagues to delete.
     */
    where: leaguesWhereUniqueInput
  }


  /**
   * leagues deleteMany
   */
  export type leaguesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which leagues to delete
     */
    where?: leaguesWhereInput
  }


  /**
   * leagues.league_teams
   */
  export type leagues$league_teamsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    where?: league_teamsWhereInput
    orderBy?: league_teamsOrderByWithRelationInput | league_teamsOrderByWithRelationInput[]
    cursor?: league_teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: League_teamsScalarFieldEnum | League_teamsScalarFieldEnum[]
  }


  /**
   * leagues without action
   */
  export type leaguesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leagues
     */
    select?: leaguesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leaguesInclude<ExtArgs> | null
  }



  /**
   * Model league_teams
   */


  export type AggregateLeague_teams = {
    _count: League_teamsCountAggregateOutputType | null
    _avg: League_teamsAvgAggregateOutputType | null
    _sum: League_teamsSumAggregateOutputType | null
    _min: League_teamsMinAggregateOutputType | null
    _max: League_teamsMaxAggregateOutputType | null
  }

  export type League_teamsAvgAggregateOutputType = {
    id: number | null
    league_id: number | null
    team_id: number | null
  }

  export type League_teamsSumAggregateOutputType = {
    id: number | null
    league_id: number | null
    team_id: number | null
  }

  export type League_teamsMinAggregateOutputType = {
    id: number | null
    league_id: number | null
    team_id: number | null
  }

  export type League_teamsMaxAggregateOutputType = {
    id: number | null
    league_id: number | null
    team_id: number | null
  }

  export type League_teamsCountAggregateOutputType = {
    id: number
    league_id: number
    team_id: number
    _all: number
  }


  export type League_teamsAvgAggregateInputType = {
    id?: true
    league_id?: true
    team_id?: true
  }

  export type League_teamsSumAggregateInputType = {
    id?: true
    league_id?: true
    team_id?: true
  }

  export type League_teamsMinAggregateInputType = {
    id?: true
    league_id?: true
    team_id?: true
  }

  export type League_teamsMaxAggregateInputType = {
    id?: true
    league_id?: true
    team_id?: true
  }

  export type League_teamsCountAggregateInputType = {
    id?: true
    league_id?: true
    team_id?: true
    _all?: true
  }

  export type League_teamsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which league_teams to aggregate.
     */
    where?: league_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of league_teams to fetch.
     */
    orderBy?: league_teamsOrderByWithRelationInput | league_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: league_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` league_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` league_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned league_teams
    **/
    _count?: true | League_teamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: League_teamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: League_teamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: League_teamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: League_teamsMaxAggregateInputType
  }

  export type GetLeague_teamsAggregateType<T extends League_teamsAggregateArgs> = {
        [P in keyof T & keyof AggregateLeague_teams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeague_teams[P]>
      : GetScalarType<T[P], AggregateLeague_teams[P]>
  }




  export type league_teamsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: league_teamsWhereInput
    orderBy?: league_teamsOrderByWithAggregationInput | league_teamsOrderByWithAggregationInput[]
    by: League_teamsScalarFieldEnum[] | League_teamsScalarFieldEnum
    having?: league_teamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: League_teamsCountAggregateInputType | true
    _avg?: League_teamsAvgAggregateInputType
    _sum?: League_teamsSumAggregateInputType
    _min?: League_teamsMinAggregateInputType
    _max?: League_teamsMaxAggregateInputType
  }


  export type League_teamsGroupByOutputType = {
    id: number
    league_id: number
    team_id: number
    _count: League_teamsCountAggregateOutputType | null
    _avg: League_teamsAvgAggregateOutputType | null
    _sum: League_teamsSumAggregateOutputType | null
    _min: League_teamsMinAggregateOutputType | null
    _max: League_teamsMaxAggregateOutputType | null
  }

  type GetLeague_teamsGroupByPayload<T extends league_teamsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<League_teamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof League_teamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], League_teamsGroupByOutputType[P]>
            : GetScalarType<T[P], League_teamsGroupByOutputType[P]>
        }
      >
    >


  export type league_teamsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    league_id?: boolean
    team_id?: boolean
    leagues?: boolean | leaguesArgs<ExtArgs>
    teamid?: boolean | teamArgs<ExtArgs>
    statistics_team?: boolean | league_teams$statistics_teamArgs<ExtArgs>
    _count?: boolean | League_teamsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["league_teams"]>

  export type league_teamsSelectScalar = {
    id?: boolean
    league_id?: boolean
    team_id?: boolean
  }

  export type league_teamsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    leagues?: boolean | leaguesArgs<ExtArgs>
    teamid?: boolean | teamArgs<ExtArgs>
    statistics_team?: boolean | league_teams$statistics_teamArgs<ExtArgs>
    _count?: boolean | League_teamsCountOutputTypeArgs<ExtArgs>
  }


  type league_teamsGetPayload<S extends boolean | null | undefined | league_teamsArgs> = $Types.GetResult<league_teamsPayload, S>

  type league_teamsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<league_teamsFindManyArgs, 'select' | 'include'> & {
      select?: League_teamsCountAggregateInputType | true
    }

  export interface league_teamsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['league_teams'], meta: { name: 'league_teams' } }
    /**
     * Find zero or one League_teams that matches the filter.
     * @param {league_teamsFindUniqueArgs} args - Arguments to find a League_teams
     * @example
     * // Get one League_teams
     * const league_teams = await prisma.league_teams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends league_teamsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, league_teamsFindUniqueArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one League_teams that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {league_teamsFindUniqueOrThrowArgs} args - Arguments to find a League_teams
     * @example
     * // Get one League_teams
     * const league_teams = await prisma.league_teams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends league_teamsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, league_teamsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first League_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {league_teamsFindFirstArgs} args - Arguments to find a League_teams
     * @example
     * // Get one League_teams
     * const league_teams = await prisma.league_teams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends league_teamsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, league_teamsFindFirstArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first League_teams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {league_teamsFindFirstOrThrowArgs} args - Arguments to find a League_teams
     * @example
     * // Get one League_teams
     * const league_teams = await prisma.league_teams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends league_teamsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, league_teamsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more League_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {league_teamsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all League_teams
     * const league_teams = await prisma.league_teams.findMany()
     * 
     * // Get first 10 League_teams
     * const league_teams = await prisma.league_teams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const league_teamsWithIdOnly = await prisma.league_teams.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends league_teamsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, league_teamsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a League_teams.
     * @param {league_teamsCreateArgs} args - Arguments to create a League_teams.
     * @example
     * // Create one League_teams
     * const League_teams = await prisma.league_teams.create({
     *   data: {
     *     // ... data to create a League_teams
     *   }
     * })
     * 
    **/
    create<T extends league_teamsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, league_teamsCreateArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many League_teams.
     *     @param {league_teamsCreateManyArgs} args - Arguments to create many League_teams.
     *     @example
     *     // Create many League_teams
     *     const league_teams = await prisma.league_teams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends league_teamsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, league_teamsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a League_teams.
     * @param {league_teamsDeleteArgs} args - Arguments to delete one League_teams.
     * @example
     * // Delete one League_teams
     * const League_teams = await prisma.league_teams.delete({
     *   where: {
     *     // ... filter to delete one League_teams
     *   }
     * })
     * 
    **/
    delete<T extends league_teamsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, league_teamsDeleteArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one League_teams.
     * @param {league_teamsUpdateArgs} args - Arguments to update one League_teams.
     * @example
     * // Update one League_teams
     * const league_teams = await prisma.league_teams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends league_teamsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, league_teamsUpdateArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more League_teams.
     * @param {league_teamsDeleteManyArgs} args - Arguments to filter League_teams to delete.
     * @example
     * // Delete a few League_teams
     * const { count } = await prisma.league_teams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends league_teamsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, league_teamsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more League_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {league_teamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many League_teams
     * const league_teams = await prisma.league_teams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends league_teamsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, league_teamsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one League_teams.
     * @param {league_teamsUpsertArgs} args - Arguments to update or create a League_teams.
     * @example
     * // Update or create a League_teams
     * const league_teams = await prisma.league_teams.upsert({
     *   create: {
     *     // ... data to create a League_teams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the League_teams we want to update
     *   }
     * })
    **/
    upsert<T extends league_teamsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, league_teamsUpsertArgs<ExtArgs>>
    ): Prisma__league_teamsClient<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of League_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {league_teamsCountArgs} args - Arguments to filter League_teams to count.
     * @example
     * // Count the number of League_teams
     * const count = await prisma.league_teams.count({
     *   where: {
     *     // ... the filter for the League_teams we want to count
     *   }
     * })
    **/
    count<T extends league_teamsCountArgs>(
      args?: Subset<T, league_teamsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], League_teamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a League_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {League_teamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends League_teamsAggregateArgs>(args: Subset<T, League_teamsAggregateArgs>): Prisma.PrismaPromise<GetLeague_teamsAggregateType<T>>

    /**
     * Group by League_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {league_teamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends league_teamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: league_teamsGroupByArgs['orderBy'] }
        : { orderBy?: league_teamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, league_teamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeague_teamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the league_teams model
   */
  readonly fields: league_teamsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for league_teams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__league_teamsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    leagues<T extends leaguesArgs<ExtArgs> = {}>(args?: Subset<T, leaguesArgs<ExtArgs>>): Prisma__leaguesClient<$Types.GetResult<leaguesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    teamid<T extends teamArgs<ExtArgs> = {}>(args?: Subset<T, teamArgs<ExtArgs>>): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    statistics_team<T extends league_teams$statistics_teamArgs<ExtArgs> = {}>(args?: Subset<T, league_teams$statistics_teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<statistics_teamPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the league_teams model
   */ 
  interface league_teamsFieldRefs {
    readonly id: FieldRef<"league_teams", 'Int'>
    readonly league_id: FieldRef<"league_teams", 'Int'>
    readonly team_id: FieldRef<"league_teams", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * league_teams findUnique
   */
  export type league_teamsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * Filter, which league_teams to fetch.
     */
    where: league_teamsWhereUniqueInput
  }


  /**
   * league_teams findUniqueOrThrow
   */
  export type league_teamsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * Filter, which league_teams to fetch.
     */
    where: league_teamsWhereUniqueInput
  }


  /**
   * league_teams findFirst
   */
  export type league_teamsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * Filter, which league_teams to fetch.
     */
    where?: league_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of league_teams to fetch.
     */
    orderBy?: league_teamsOrderByWithRelationInput | league_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for league_teams.
     */
    cursor?: league_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` league_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` league_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of league_teams.
     */
    distinct?: League_teamsScalarFieldEnum | League_teamsScalarFieldEnum[]
  }


  /**
   * league_teams findFirstOrThrow
   */
  export type league_teamsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * Filter, which league_teams to fetch.
     */
    where?: league_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of league_teams to fetch.
     */
    orderBy?: league_teamsOrderByWithRelationInput | league_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for league_teams.
     */
    cursor?: league_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` league_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` league_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of league_teams.
     */
    distinct?: League_teamsScalarFieldEnum | League_teamsScalarFieldEnum[]
  }


  /**
   * league_teams findMany
   */
  export type league_teamsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * Filter, which league_teams to fetch.
     */
    where?: league_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of league_teams to fetch.
     */
    orderBy?: league_teamsOrderByWithRelationInput | league_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing league_teams.
     */
    cursor?: league_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` league_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` league_teams.
     */
    skip?: number
    distinct?: League_teamsScalarFieldEnum | League_teamsScalarFieldEnum[]
  }


  /**
   * league_teams create
   */
  export type league_teamsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * The data needed to create a league_teams.
     */
    data: XOR<league_teamsCreateInput, league_teamsUncheckedCreateInput>
  }


  /**
   * league_teams createMany
   */
  export type league_teamsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many league_teams.
     */
    data: league_teamsCreateManyInput | league_teamsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * league_teams update
   */
  export type league_teamsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * The data needed to update a league_teams.
     */
    data: XOR<league_teamsUpdateInput, league_teamsUncheckedUpdateInput>
    /**
     * Choose, which league_teams to update.
     */
    where: league_teamsWhereUniqueInput
  }


  /**
   * league_teams updateMany
   */
  export type league_teamsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update league_teams.
     */
    data: XOR<league_teamsUpdateManyMutationInput, league_teamsUncheckedUpdateManyInput>
    /**
     * Filter which league_teams to update
     */
    where?: league_teamsWhereInput
  }


  /**
   * league_teams upsert
   */
  export type league_teamsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * The filter to search for the league_teams to update in case it exists.
     */
    where: league_teamsWhereUniqueInput
    /**
     * In case the league_teams found by the `where` argument doesn't exist, create a new league_teams with this data.
     */
    create: XOR<league_teamsCreateInput, league_teamsUncheckedCreateInput>
    /**
     * In case the league_teams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<league_teamsUpdateInput, league_teamsUncheckedUpdateInput>
  }


  /**
   * league_teams delete
   */
  export type league_teamsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    /**
     * Filter which league_teams to delete.
     */
    where: league_teamsWhereUniqueInput
  }


  /**
   * league_teams deleteMany
   */
  export type league_teamsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which league_teams to delete
     */
    where?: league_teamsWhereInput
  }


  /**
   * league_teams.statistics_team
   */
  export type league_teams$statistics_teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statistics_team
     */
    select?: statistics_teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: statistics_teamInclude<ExtArgs> | null
    where?: statistics_teamWhereInput
    orderBy?: statistics_teamOrderByWithRelationInput | statistics_teamOrderByWithRelationInput[]
    cursor?: statistics_teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Statistics_teamScalarFieldEnum | Statistics_teamScalarFieldEnum[]
  }


  /**
   * league_teams without action
   */
  export type league_teamsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
  }



  /**
   * Model country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    name: string | null
    code: string | null
    flag: string | null
  }

  export type CountryMaxAggregateOutputType = {
    name: string | null
    code: string | null
    flag: string | null
  }

  export type CountryCountAggregateOutputType = {
    name: number
    code: number
    flag: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    name?: true
    code?: true
    flag?: true
  }

  export type CountryMaxAggregateInputType = {
    name?: true
    code?: true
    flag?: true
  }

  export type CountryCountAggregateInputType = {
    name?: true
    code?: true
    flag?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which country to aggregate.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type countryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: countryWhereInput
    orderBy?: countryOrderByWithAggregationInput | countryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: countryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    name: string
    code: string
    flag: string
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends countryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type countrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    code?: boolean
    flag?: boolean
  }, ExtArgs["result"]["country"]>

  export type countrySelectScalar = {
    name?: boolean
    code?: boolean
    flag?: boolean
  }


  type countryGetPayload<S extends boolean | null | undefined | countryArgs> = $Types.GetResult<countryPayload, S>

  type countryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<countryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface countryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['country'], meta: { name: 'country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {countryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends countryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, countryFindUniqueArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {countryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends countryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, countryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends countryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, countryFindFirstArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends countryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, countryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const countryWithNameOnly = await prisma.country.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends countryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, countryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<countryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Country.
     * @param {countryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends countryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, countryCreateArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {countryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends countryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, countryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {countryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends countryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, countryDeleteArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {countryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends countryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, countryUpdateArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {countryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends countryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, countryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends countryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, countryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {countryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends countryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, countryUpsertArgs<ExtArgs>>
    ): Prisma__countryClient<$Types.GetResult<countryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countryCountArgs>(
      args?: Subset<T, countryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends countryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: countryGroupByArgs['orderBy'] }
        : { orderBy?: countryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, countryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the country model
   */
  readonly fields: countryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__countryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the country model
   */ 
  interface countryFieldRefs {
    readonly name: FieldRef<"country", 'String'>
    readonly code: FieldRef<"country", 'String'>
    readonly flag: FieldRef<"country", 'String'>
  }
    

  // Custom InputTypes

  /**
   * country findUnique
   */
  export type countryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where: countryWhereUniqueInput
  }


  /**
   * country findUniqueOrThrow
   */
  export type countryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where: countryWhereUniqueInput
  }


  /**
   * country findFirst
   */
  export type countryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }


  /**
   * country findFirstOrThrow
   */
  export type countryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }


  /**
   * country findMany
   */
  export type countryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }


  /**
   * country create
   */
  export type countryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * The data needed to create a country.
     */
    data: XOR<countryCreateInput, countryUncheckedCreateInput>
  }


  /**
   * country createMany
   */
  export type countryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many countries.
     */
    data: countryCreateManyInput | countryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * country update
   */
  export type countryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * The data needed to update a country.
     */
    data: XOR<countryUpdateInput, countryUncheckedUpdateInput>
    /**
     * Choose, which country to update.
     */
    where: countryWhereUniqueInput
  }


  /**
   * country updateMany
   */
  export type countryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update countries.
     */
    data: XOR<countryUpdateManyMutationInput, countryUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countryWhereInput
  }


  /**
   * country upsert
   */
  export type countryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * The filter to search for the country to update in case it exists.
     */
    where: countryWhereUniqueInput
    /**
     * In case the country found by the `where` argument doesn't exist, create a new country with this data.
     */
    create: XOR<countryCreateInput, countryUncheckedCreateInput>
    /**
     * In case the country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countryUpdateInput, countryUncheckedUpdateInput>
  }


  /**
   * country delete
   */
  export type countryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Filter which country to delete.
     */
    where: countryWhereUniqueInput
  }


  /**
   * country deleteMany
   */
  export type countryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to delete
     */
    where?: countryWhereInput
  }


  /**
   * country without action
   */
  export type countryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
  }



  /**
   * Model team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    founded: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    founded: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    founded: number | null
    national: boolean | null
    logo: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    founded: number | null
    national: boolean | null
    logo: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    code: number
    founded: number
    national: number
    logo: number
    venues: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    founded?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    founded?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    founded?: true
    national?: true
    logo?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    founded?: true
    national?: true
    logo?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    founded?: true
    national?: true
    logo?: true
    venues?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type teamGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
    orderBy?: teamOrderByWithAggregationInput | teamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonValue
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    founded?: boolean
    national?: boolean
    logo?: boolean
    venues?: boolean
    league_teams?: boolean | team$league_teamsArgs<ExtArgs>
    player_team?: boolean | team$player_teamArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    founded?: boolean
    national?: boolean
    logo?: boolean
    venues?: boolean
  }

  export type teamInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    league_teams?: boolean | team$league_teamsArgs<ExtArgs>
    player_team?: boolean | team$player_teamArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeArgs<ExtArgs>
  }


  type teamGetPayload<S extends boolean | null | undefined | teamArgs> = $Types.GetResult<teamPayload, S>

  type teamCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<teamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team'], meta: { name: 'team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends teamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, teamFindUniqueArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends teamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindFirstArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends teamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<teamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends teamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, teamCreateArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Teams.
     *     @param {teamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends teamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends teamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, teamDeleteArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends teamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpdateArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends teamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends teamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends teamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpsertArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamGroupByArgs['orderBy'] }
        : { orderBy?: teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team model
   */
  readonly fields: teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__teamClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    league_teams<T extends team$league_teamsArgs<ExtArgs> = {}>(args?: Subset<T, team$league_teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<league_teamsPayload<ExtArgs>, T, 'findMany'>| Null>;

    player_team<T extends team$player_teamArgs<ExtArgs> = {}>(args?: Subset<T, team$player_teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<team_playerPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the team model
   */ 
  interface teamFieldRefs {
    readonly id: FieldRef<"team", 'Int'>
    readonly name: FieldRef<"team", 'String'>
    readonly code: FieldRef<"team", 'String'>
    readonly founded: FieldRef<"team", 'Int'>
    readonly national: FieldRef<"team", 'Boolean'>
    readonly logo: FieldRef<"team", 'String'>
    readonly venues: FieldRef<"team", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * team findUnique
   */
  export type teamFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team findFirst
   */
  export type teamFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team findMany
   */
  export type teamFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team create
   */
  export type teamCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }


  /**
   * team createMany
   */
  export type teamCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team update
   */
  export type teamUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team updateMany
   */
  export type teamUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
  }


  /**
   * team upsert
   */
  export type teamUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }


  /**
   * team delete
   */
  export type teamDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
  }


  /**
   * team.league_teams
   */
  export type team$league_teamsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the league_teams
     */
    select?: league_teamsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: league_teamsInclude<ExtArgs> | null
    where?: league_teamsWhereInput
    orderBy?: league_teamsOrderByWithRelationInput | league_teamsOrderByWithRelationInput[]
    cursor?: league_teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: League_teamsScalarFieldEnum | League_teamsScalarFieldEnum[]
  }


  /**
   * team.player_team
   */
  export type team$player_teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_player
     */
    select?: team_playerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: team_playerInclude<ExtArgs> | null
    where?: team_playerWhereInput
    orderBy?: team_playerOrderByWithRelationInput | team_playerOrderByWithRelationInput[]
    cursor?: team_playerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_playerScalarFieldEnum | Team_playerScalarFieldEnum[]
  }


  /**
   * team without action
   */
  export type teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
  }



  /**
   * Model lead
   */


  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    id: number | null
  }

  export type LeadSumAggregateOutputType = {
    id: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    phone: string | null
    description: string | null
    createdat: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    phone: string | null
    description: string | null
    createdat: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    phone: number
    description: number
    createdat: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    id?: true
  }

  export type LeadSumAggregateInputType = {
    id?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    phone?: true
    description?: true
    createdat?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    phone?: true
    description?: true
    createdat?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    phone?: true
    description?: true
    createdat?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which lead to aggregate.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type leadGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: leadWhereInput
    orderBy?: leadOrderByWithAggregationInput | leadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: leadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }


  export type LeadGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    email: string
    phone: string | null
    description: string
    createdat: Date
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends leadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type leadSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    phone?: boolean
    description?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["lead"]>

  export type leadSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    phone?: boolean
    description?: boolean
    createdat?: boolean
  }


  type leadGetPayload<S extends boolean | null | undefined | leadArgs> = $Types.GetResult<leadPayload, S>

  type leadCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<leadFindManyArgs, 'select' | 'include'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface leadDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lead'], meta: { name: 'lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {leadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends leadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, leadFindUniqueArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {leadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends leadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends leadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, leadFindFirstArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends leadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends leadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<leadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lead.
     * @param {leadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
    **/
    create<T extends leadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, leadCreateArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leads.
     *     @param {leadCreateManyArgs} args - Arguments to create many Leads.
     *     @example
     *     // Create many Leads
     *     const lead = await prisma.lead.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends leadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lead.
     * @param {leadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
    **/
    delete<T extends leadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, leadDeleteArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {leadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends leadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, leadUpdateArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {leadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends leadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends leadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, leadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {leadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
    **/
    upsert<T extends leadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, leadUpsertArgs<ExtArgs>>
    ): Prisma__leadClient<$Types.GetResult<leadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends leadCountArgs>(
      args?: Subset<T, leadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leadGroupByArgs['orderBy'] }
        : { orderBy?: leadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lead model
   */
  readonly fields: leadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__leadClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the lead model
   */ 
  interface leadFieldRefs {
    readonly id: FieldRef<"lead", 'Int'>
    readonly firstname: FieldRef<"lead", 'String'>
    readonly lastname: FieldRef<"lead", 'String'>
    readonly email: FieldRef<"lead", 'String'>
    readonly phone: FieldRef<"lead", 'String'>
    readonly description: FieldRef<"lead", 'String'>
    readonly createdat: FieldRef<"lead", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * lead findUnique
   */
  export type leadFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where: leadWhereUniqueInput
  }


  /**
   * lead findUniqueOrThrow
   */
  export type leadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where: leadWhereUniqueInput
  }


  /**
   * lead findFirst
   */
  export type leadFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leads.
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * lead findFirstOrThrow
   */
  export type leadFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Filter, which lead to fetch.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leads.
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * lead findMany
   */
  export type leadFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Filter, which leads to fetch.
     */
    where?: leadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leads to fetch.
     */
    orderBy?: leadOrderByWithRelationInput | leadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leads.
     */
    cursor?: leadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }


  /**
   * lead create
   */
  export type leadCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * The data needed to create a lead.
     */
    data: XOR<leadCreateInput, leadUncheckedCreateInput>
  }


  /**
   * lead createMany
   */
  export type leadCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leads.
     */
    data: leadCreateManyInput | leadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lead update
   */
  export type leadUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * The data needed to update a lead.
     */
    data: XOR<leadUpdateInput, leadUncheckedUpdateInput>
    /**
     * Choose, which lead to update.
     */
    where: leadWhereUniqueInput
  }


  /**
   * lead updateMany
   */
  export type leadUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leads.
     */
    data: XOR<leadUpdateManyMutationInput, leadUncheckedUpdateManyInput>
    /**
     * Filter which leads to update
     */
    where?: leadWhereInput
  }


  /**
   * lead upsert
   */
  export type leadUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * The filter to search for the lead to update in case it exists.
     */
    where: leadWhereUniqueInput
    /**
     * In case the lead found by the `where` argument doesn't exist, create a new lead with this data.
     */
    create: XOR<leadCreateInput, leadUncheckedCreateInput>
    /**
     * In case the lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leadUpdateInput, leadUncheckedUpdateInput>
  }


  /**
   * lead delete
   */
  export type leadDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
    /**
     * Filter which lead to delete.
     */
    where: leadWhereUniqueInput
  }


  /**
   * lead deleteMany
   */
  export type leadDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which leads to delete
     */
    where?: leadWhereInput
  }


  /**
   * lead without action
   */
  export type leadArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lead
     */
    select?: leadSelect<ExtArgs> | null
  }



  /**
   * Model passwordhash
   */


  export type AggregatePasswordhash = {
    _count: PasswordhashCountAggregateOutputType | null
    _avg: PasswordhashAvgAggregateOutputType | null
    _sum: PasswordhashSumAggregateOutputType | null
    _min: PasswordhashMinAggregateOutputType | null
    _max: PasswordhashMaxAggregateOutputType | null
  }

  export type PasswordhashAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PasswordhashSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PasswordhashMinAggregateOutputType = {
    id: number | null
    userid: number | null
    hash: string | null
    salt: string | null
    createdat: Date | null
  }

  export type PasswordhashMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    hash: string | null
    salt: string | null
    createdat: Date | null
  }

  export type PasswordhashCountAggregateOutputType = {
    id: number
    userid: number
    hash: number
    salt: number
    createdat: number
    _all: number
  }


  export type PasswordhashAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PasswordhashSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PasswordhashMinAggregateInputType = {
    id?: true
    userid?: true
    hash?: true
    salt?: true
    createdat?: true
  }

  export type PasswordhashMaxAggregateInputType = {
    id?: true
    userid?: true
    hash?: true
    salt?: true
    createdat?: true
  }

  export type PasswordhashCountAggregateInputType = {
    id?: true
    userid?: true
    hash?: true
    salt?: true
    createdat?: true
    _all?: true
  }

  export type PasswordhashAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which passwordhash to aggregate.
     */
    where?: passwordhashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordhashes to fetch.
     */
    orderBy?: passwordhashOrderByWithRelationInput | passwordhashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: passwordhashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordhashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordhashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned passwordhashes
    **/
    _count?: true | PasswordhashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordhashAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordhashSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordhashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordhashMaxAggregateInputType
  }

  export type GetPasswordhashAggregateType<T extends PasswordhashAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordhash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordhash[P]>
      : GetScalarType<T[P], AggregatePasswordhash[P]>
  }




  export type passwordhashGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: passwordhashWhereInput
    orderBy?: passwordhashOrderByWithAggregationInput | passwordhashOrderByWithAggregationInput[]
    by: PasswordhashScalarFieldEnum[] | PasswordhashScalarFieldEnum
    having?: passwordhashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordhashCountAggregateInputType | true
    _avg?: PasswordhashAvgAggregateInputType
    _sum?: PasswordhashSumAggregateInputType
    _min?: PasswordhashMinAggregateInputType
    _max?: PasswordhashMaxAggregateInputType
  }


  export type PasswordhashGroupByOutputType = {
    id: number
    userid: number
    hash: string
    salt: string
    createdat: Date
    _count: PasswordhashCountAggregateOutputType | null
    _avg: PasswordhashAvgAggregateOutputType | null
    _sum: PasswordhashSumAggregateOutputType | null
    _min: PasswordhashMinAggregateOutputType | null
    _max: PasswordhashMaxAggregateOutputType | null
  }

  type GetPasswordhashGroupByPayload<T extends passwordhashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordhashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordhashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordhashGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordhashGroupByOutputType[P]>
        }
      >
    >


  export type passwordhashSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    hash?: boolean
    salt?: boolean
    createdat?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["passwordhash"]>

  export type passwordhashSelectScalar = {
    id?: boolean
    userid?: boolean
    hash?: boolean
    salt?: boolean
    createdat?: boolean
  }

  export type passwordhashInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type passwordhashGetPayload<S extends boolean | null | undefined | passwordhashArgs> = $Types.GetResult<passwordhashPayload, S>

  type passwordhashCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<passwordhashFindManyArgs, 'select' | 'include'> & {
      select?: PasswordhashCountAggregateInputType | true
    }

  export interface passwordhashDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['passwordhash'], meta: { name: 'passwordhash' } }
    /**
     * Find zero or one Passwordhash that matches the filter.
     * @param {passwordhashFindUniqueArgs} args - Arguments to find a Passwordhash
     * @example
     * // Get one Passwordhash
     * const passwordhash = await prisma.passwordhash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends passwordhashFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, passwordhashFindUniqueArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Passwordhash that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {passwordhashFindUniqueOrThrowArgs} args - Arguments to find a Passwordhash
     * @example
     * // Get one Passwordhash
     * const passwordhash = await prisma.passwordhash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends passwordhashFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, passwordhashFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Passwordhash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordhashFindFirstArgs} args - Arguments to find a Passwordhash
     * @example
     * // Get one Passwordhash
     * const passwordhash = await prisma.passwordhash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends passwordhashFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, passwordhashFindFirstArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Passwordhash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordhashFindFirstOrThrowArgs} args - Arguments to find a Passwordhash
     * @example
     * // Get one Passwordhash
     * const passwordhash = await prisma.passwordhash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends passwordhashFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, passwordhashFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Passwordhashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordhashFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passwordhashes
     * const passwordhashes = await prisma.passwordhash.findMany()
     * 
     * // Get first 10 Passwordhashes
     * const passwordhashes = await prisma.passwordhash.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordhashWithIdOnly = await prisma.passwordhash.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends passwordhashFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, passwordhashFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Passwordhash.
     * @param {passwordhashCreateArgs} args - Arguments to create a Passwordhash.
     * @example
     * // Create one Passwordhash
     * const Passwordhash = await prisma.passwordhash.create({
     *   data: {
     *     // ... data to create a Passwordhash
     *   }
     * })
     * 
    **/
    create<T extends passwordhashCreateArgs<ExtArgs>>(
      args: SelectSubset<T, passwordhashCreateArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Passwordhashes.
     *     @param {passwordhashCreateManyArgs} args - Arguments to create many Passwordhashes.
     *     @example
     *     // Create many Passwordhashes
     *     const passwordhash = await prisma.passwordhash.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends passwordhashCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, passwordhashCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Passwordhash.
     * @param {passwordhashDeleteArgs} args - Arguments to delete one Passwordhash.
     * @example
     * // Delete one Passwordhash
     * const Passwordhash = await prisma.passwordhash.delete({
     *   where: {
     *     // ... filter to delete one Passwordhash
     *   }
     * })
     * 
    **/
    delete<T extends passwordhashDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, passwordhashDeleteArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Passwordhash.
     * @param {passwordhashUpdateArgs} args - Arguments to update one Passwordhash.
     * @example
     * // Update one Passwordhash
     * const passwordhash = await prisma.passwordhash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends passwordhashUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, passwordhashUpdateArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Passwordhashes.
     * @param {passwordhashDeleteManyArgs} args - Arguments to filter Passwordhashes to delete.
     * @example
     * // Delete a few Passwordhashes
     * const { count } = await prisma.passwordhash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends passwordhashDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, passwordhashDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passwordhashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordhashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passwordhashes
     * const passwordhash = await prisma.passwordhash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends passwordhashUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, passwordhashUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Passwordhash.
     * @param {passwordhashUpsertArgs} args - Arguments to update or create a Passwordhash.
     * @example
     * // Update or create a Passwordhash
     * const passwordhash = await prisma.passwordhash.upsert({
     *   create: {
     *     // ... data to create a Passwordhash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passwordhash we want to update
     *   }
     * })
    **/
    upsert<T extends passwordhashUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, passwordhashUpsertArgs<ExtArgs>>
    ): Prisma__passwordhashClient<$Types.GetResult<passwordhashPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Passwordhashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordhashCountArgs} args - Arguments to filter Passwordhashes to count.
     * @example
     * // Count the number of Passwordhashes
     * const count = await prisma.passwordhash.count({
     *   where: {
     *     // ... the filter for the Passwordhashes we want to count
     *   }
     * })
    **/
    count<T extends passwordhashCountArgs>(
      args?: Subset<T, passwordhashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordhashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passwordhash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordhashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordhashAggregateArgs>(args: Subset<T, PasswordhashAggregateArgs>): Prisma.PrismaPromise<GetPasswordhashAggregateType<T>>

    /**
     * Group by Passwordhash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordhashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends passwordhashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: passwordhashGroupByArgs['orderBy'] }
        : { orderBy?: passwordhashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, passwordhashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordhashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the passwordhash model
   */
  readonly fields: passwordhashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for passwordhash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__passwordhashClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the passwordhash model
   */ 
  interface passwordhashFieldRefs {
    readonly id: FieldRef<"passwordhash", 'Int'>
    readonly userid: FieldRef<"passwordhash", 'Int'>
    readonly hash: FieldRef<"passwordhash", 'String'>
    readonly salt: FieldRef<"passwordhash", 'String'>
    readonly createdat: FieldRef<"passwordhash", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * passwordhash findUnique
   */
  export type passwordhashFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * Filter, which passwordhash to fetch.
     */
    where: passwordhashWhereUniqueInput
  }


  /**
   * passwordhash findUniqueOrThrow
   */
  export type passwordhashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * Filter, which passwordhash to fetch.
     */
    where: passwordhashWhereUniqueInput
  }


  /**
   * passwordhash findFirst
   */
  export type passwordhashFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * Filter, which passwordhash to fetch.
     */
    where?: passwordhashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordhashes to fetch.
     */
    orderBy?: passwordhashOrderByWithRelationInput | passwordhashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passwordhashes.
     */
    cursor?: passwordhashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordhashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordhashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passwordhashes.
     */
    distinct?: PasswordhashScalarFieldEnum | PasswordhashScalarFieldEnum[]
  }


  /**
   * passwordhash findFirstOrThrow
   */
  export type passwordhashFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * Filter, which passwordhash to fetch.
     */
    where?: passwordhashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordhashes to fetch.
     */
    orderBy?: passwordhashOrderByWithRelationInput | passwordhashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passwordhashes.
     */
    cursor?: passwordhashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordhashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordhashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passwordhashes.
     */
    distinct?: PasswordhashScalarFieldEnum | PasswordhashScalarFieldEnum[]
  }


  /**
   * passwordhash findMany
   */
  export type passwordhashFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * Filter, which passwordhashes to fetch.
     */
    where?: passwordhashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordhashes to fetch.
     */
    orderBy?: passwordhashOrderByWithRelationInput | passwordhashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing passwordhashes.
     */
    cursor?: passwordhashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordhashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordhashes.
     */
    skip?: number
    distinct?: PasswordhashScalarFieldEnum | PasswordhashScalarFieldEnum[]
  }


  /**
   * passwordhash create
   */
  export type passwordhashCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * The data needed to create a passwordhash.
     */
    data: XOR<passwordhashCreateInput, passwordhashUncheckedCreateInput>
  }


  /**
   * passwordhash createMany
   */
  export type passwordhashCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many passwordhashes.
     */
    data: passwordhashCreateManyInput | passwordhashCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * passwordhash update
   */
  export type passwordhashUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * The data needed to update a passwordhash.
     */
    data: XOR<passwordhashUpdateInput, passwordhashUncheckedUpdateInput>
    /**
     * Choose, which passwordhash to update.
     */
    where: passwordhashWhereUniqueInput
  }


  /**
   * passwordhash updateMany
   */
  export type passwordhashUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update passwordhashes.
     */
    data: XOR<passwordhashUpdateManyMutationInput, passwordhashUncheckedUpdateManyInput>
    /**
     * Filter which passwordhashes to update
     */
    where?: passwordhashWhereInput
  }


  /**
   * passwordhash upsert
   */
  export type passwordhashUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * The filter to search for the passwordhash to update in case it exists.
     */
    where: passwordhashWhereUniqueInput
    /**
     * In case the passwordhash found by the `where` argument doesn't exist, create a new passwordhash with this data.
     */
    create: XOR<passwordhashCreateInput, passwordhashUncheckedCreateInput>
    /**
     * In case the passwordhash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<passwordhashUpdateInput, passwordhashUncheckedUpdateInput>
  }


  /**
   * passwordhash delete
   */
  export type passwordhashDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
    /**
     * Filter which passwordhash to delete.
     */
    where: passwordhashWhereUniqueInput
  }


  /**
   * passwordhash deleteMany
   */
  export type passwordhashDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which passwordhashes to delete
     */
    where?: passwordhashWhereInput
  }


  /**
   * passwordhash without action
   */
  export type passwordhashArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordhash
     */
    select?: passwordhashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: passwordhashInclude<ExtArgs> | null
  }



  /**
   * Model permissionlog
   */


  export type AggregatePermissionlog = {
    _count: PermissionlogCountAggregateOutputType | null
    _avg: PermissionlogAvgAggregateOutputType | null
    _sum: PermissionlogSumAggregateOutputType | null
    _min: PermissionlogMinAggregateOutputType | null
    _max: PermissionlogMaxAggregateOutputType | null
  }

  export type PermissionlogAvgAggregateOutputType = {
    id: number | null
    permissionid: number | null
  }

  export type PermissionlogSumAggregateOutputType = {
    id: number | null
    permissionid: number | null
  }

  export type PermissionlogMinAggregateOutputType = {
    id: number | null
    permissionid: number | null
    action: string | null
    createdat: Date | null
  }

  export type PermissionlogMaxAggregateOutputType = {
    id: number | null
    permissionid: number | null
    action: string | null
    createdat: Date | null
  }

  export type PermissionlogCountAggregateOutputType = {
    id: number
    permissionid: number
    action: number
    createdat: number
    _all: number
  }


  export type PermissionlogAvgAggregateInputType = {
    id?: true
    permissionid?: true
  }

  export type PermissionlogSumAggregateInputType = {
    id?: true
    permissionid?: true
  }

  export type PermissionlogMinAggregateInputType = {
    id?: true
    permissionid?: true
    action?: true
    createdat?: true
  }

  export type PermissionlogMaxAggregateInputType = {
    id?: true
    permissionid?: true
    action?: true
    createdat?: true
  }

  export type PermissionlogCountAggregateInputType = {
    id?: true
    permissionid?: true
    action?: true
    createdat?: true
    _all?: true
  }

  export type PermissionlogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissionlog to aggregate.
     */
    where?: permissionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissionlogs to fetch.
     */
    orderBy?: permissionlogOrderByWithRelationInput | permissionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissionlogs
    **/
    _count?: true | PermissionlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionlogMaxAggregateInputType
  }

  export type GetPermissionlogAggregateType<T extends PermissionlogAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissionlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissionlog[P]>
      : GetScalarType<T[P], AggregatePermissionlog[P]>
  }




  export type permissionlogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: permissionlogWhereInput
    orderBy?: permissionlogOrderByWithAggregationInput | permissionlogOrderByWithAggregationInput[]
    by: PermissionlogScalarFieldEnum[] | PermissionlogScalarFieldEnum
    having?: permissionlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionlogCountAggregateInputType | true
    _avg?: PermissionlogAvgAggregateInputType
    _sum?: PermissionlogSumAggregateInputType
    _min?: PermissionlogMinAggregateInputType
    _max?: PermissionlogMaxAggregateInputType
  }


  export type PermissionlogGroupByOutputType = {
    id: number
    permissionid: number
    action: string
    createdat: Date
    _count: PermissionlogCountAggregateOutputType | null
    _avg: PermissionlogAvgAggregateOutputType | null
    _sum: PermissionlogSumAggregateOutputType | null
    _min: PermissionlogMinAggregateOutputType | null
    _max: PermissionlogMaxAggregateOutputType | null
  }

  type GetPermissionlogGroupByPayload<T extends permissionlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionlogGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionlogGroupByOutputType[P]>
        }
      >
    >


  export type permissionlogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    permissionid?: boolean
    action?: boolean
    createdat?: boolean
    permision?: boolean | permissionArgs<ExtArgs>
  }, ExtArgs["result"]["permissionlog"]>

  export type permissionlogSelectScalar = {
    id?: boolean
    permissionid?: boolean
    action?: boolean
    createdat?: boolean
  }

  export type permissionlogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    permision?: boolean | permissionArgs<ExtArgs>
  }


  type permissionlogGetPayload<S extends boolean | null | undefined | permissionlogArgs> = $Types.GetResult<permissionlogPayload, S>

  type permissionlogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<permissionlogFindManyArgs, 'select' | 'include'> & {
      select?: PermissionlogCountAggregateInputType | true
    }

  export interface permissionlogDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissionlog'], meta: { name: 'permissionlog' } }
    /**
     * Find zero or one Permissionlog that matches the filter.
     * @param {permissionlogFindUniqueArgs} args - Arguments to find a Permissionlog
     * @example
     * // Get one Permissionlog
     * const permissionlog = await prisma.permissionlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends permissionlogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, permissionlogFindUniqueArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Permissionlog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {permissionlogFindUniqueOrThrowArgs} args - Arguments to find a Permissionlog
     * @example
     * // Get one Permissionlog
     * const permissionlog = await prisma.permissionlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends permissionlogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionlogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Permissionlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionlogFindFirstArgs} args - Arguments to find a Permissionlog
     * @example
     * // Get one Permissionlog
     * const permissionlog = await prisma.permissionlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends permissionlogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionlogFindFirstArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Permissionlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionlogFindFirstOrThrowArgs} args - Arguments to find a Permissionlog
     * @example
     * // Get one Permissionlog
     * const permissionlog = await prisma.permissionlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends permissionlogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionlogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Permissionlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissionlogs
     * const permissionlogs = await prisma.permissionlog.findMany()
     * 
     * // Get first 10 Permissionlogs
     * const permissionlogs = await prisma.permissionlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionlogWithIdOnly = await prisma.permissionlog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends permissionlogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionlogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Permissionlog.
     * @param {permissionlogCreateArgs} args - Arguments to create a Permissionlog.
     * @example
     * // Create one Permissionlog
     * const Permissionlog = await prisma.permissionlog.create({
     *   data: {
     *     // ... data to create a Permissionlog
     *   }
     * })
     * 
    **/
    create<T extends permissionlogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, permissionlogCreateArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Permissionlogs.
     *     @param {permissionlogCreateManyArgs} args - Arguments to create many Permissionlogs.
     *     @example
     *     // Create many Permissionlogs
     *     const permissionlog = await prisma.permissionlog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends permissionlogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionlogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissionlog.
     * @param {permissionlogDeleteArgs} args - Arguments to delete one Permissionlog.
     * @example
     * // Delete one Permissionlog
     * const Permissionlog = await prisma.permissionlog.delete({
     *   where: {
     *     // ... filter to delete one Permissionlog
     *   }
     * })
     * 
    **/
    delete<T extends permissionlogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, permissionlogDeleteArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Permissionlog.
     * @param {permissionlogUpdateArgs} args - Arguments to update one Permissionlog.
     * @example
     * // Update one Permissionlog
     * const permissionlog = await prisma.permissionlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends permissionlogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, permissionlogUpdateArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Permissionlogs.
     * @param {permissionlogDeleteManyArgs} args - Arguments to filter Permissionlogs to delete.
     * @example
     * // Delete a few Permissionlogs
     * const { count } = await prisma.permissionlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends permissionlogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionlogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissionlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissionlogs
     * const permissionlog = await prisma.permissionlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends permissionlogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, permissionlogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissionlog.
     * @param {permissionlogUpsertArgs} args - Arguments to update or create a Permissionlog.
     * @example
     * // Update or create a Permissionlog
     * const permissionlog = await prisma.permissionlog.upsert({
     *   create: {
     *     // ... data to create a Permissionlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissionlog we want to update
     *   }
     * })
    **/
    upsert<T extends permissionlogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, permissionlogUpsertArgs<ExtArgs>>
    ): Prisma__permissionlogClient<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Permissionlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionlogCountArgs} args - Arguments to filter Permissionlogs to count.
     * @example
     * // Count the number of Permissionlogs
     * const count = await prisma.permissionlog.count({
     *   where: {
     *     // ... the filter for the Permissionlogs we want to count
     *   }
     * })
    **/
    count<T extends permissionlogCountArgs>(
      args?: Subset<T, permissionlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissionlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionlogAggregateArgs>(args: Subset<T, PermissionlogAggregateArgs>): Prisma.PrismaPromise<GetPermissionlogAggregateType<T>>

    /**
     * Group by Permissionlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionlogGroupByArgs['orderBy'] }
        : { orderBy?: permissionlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissionlog model
   */
  readonly fields: permissionlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissionlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__permissionlogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    permision<T extends permissionArgs<ExtArgs> = {}>(args?: Subset<T, permissionArgs<ExtArgs>>): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the permissionlog model
   */ 
  interface permissionlogFieldRefs {
    readonly id: FieldRef<"permissionlog", 'Int'>
    readonly permissionid: FieldRef<"permissionlog", 'Int'>
    readonly action: FieldRef<"permissionlog", 'String'>
    readonly createdat: FieldRef<"permissionlog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * permissionlog findUnique
   */
  export type permissionlogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * Filter, which permissionlog to fetch.
     */
    where: permissionlogWhereUniqueInput
  }


  /**
   * permissionlog findUniqueOrThrow
   */
  export type permissionlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * Filter, which permissionlog to fetch.
     */
    where: permissionlogWhereUniqueInput
  }


  /**
   * permissionlog findFirst
   */
  export type permissionlogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * Filter, which permissionlog to fetch.
     */
    where?: permissionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissionlogs to fetch.
     */
    orderBy?: permissionlogOrderByWithRelationInput | permissionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissionlogs.
     */
    cursor?: permissionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissionlogs.
     */
    distinct?: PermissionlogScalarFieldEnum | PermissionlogScalarFieldEnum[]
  }


  /**
   * permissionlog findFirstOrThrow
   */
  export type permissionlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * Filter, which permissionlog to fetch.
     */
    where?: permissionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissionlogs to fetch.
     */
    orderBy?: permissionlogOrderByWithRelationInput | permissionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissionlogs.
     */
    cursor?: permissionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissionlogs.
     */
    distinct?: PermissionlogScalarFieldEnum | PermissionlogScalarFieldEnum[]
  }


  /**
   * permissionlog findMany
   */
  export type permissionlogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * Filter, which permissionlogs to fetch.
     */
    where?: permissionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissionlogs to fetch.
     */
    orderBy?: permissionlogOrderByWithRelationInput | permissionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissionlogs.
     */
    cursor?: permissionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissionlogs.
     */
    skip?: number
    distinct?: PermissionlogScalarFieldEnum | PermissionlogScalarFieldEnum[]
  }


  /**
   * permissionlog create
   */
  export type permissionlogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * The data needed to create a permissionlog.
     */
    data: XOR<permissionlogCreateInput, permissionlogUncheckedCreateInput>
  }


  /**
   * permissionlog createMany
   */
  export type permissionlogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissionlogs.
     */
    data: permissionlogCreateManyInput | permissionlogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * permissionlog update
   */
  export type permissionlogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * The data needed to update a permissionlog.
     */
    data: XOR<permissionlogUpdateInput, permissionlogUncheckedUpdateInput>
    /**
     * Choose, which permissionlog to update.
     */
    where: permissionlogWhereUniqueInput
  }


  /**
   * permissionlog updateMany
   */
  export type permissionlogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissionlogs.
     */
    data: XOR<permissionlogUpdateManyMutationInput, permissionlogUncheckedUpdateManyInput>
    /**
     * Filter which permissionlogs to update
     */
    where?: permissionlogWhereInput
  }


  /**
   * permissionlog upsert
   */
  export type permissionlogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * The filter to search for the permissionlog to update in case it exists.
     */
    where: permissionlogWhereUniqueInput
    /**
     * In case the permissionlog found by the `where` argument doesn't exist, create a new permissionlog with this data.
     */
    create: XOR<permissionlogCreateInput, permissionlogUncheckedCreateInput>
    /**
     * In case the permissionlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionlogUpdateInput, permissionlogUncheckedUpdateInput>
  }


  /**
   * permissionlog delete
   */
  export type permissionlogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    /**
     * Filter which permissionlog to delete.
     */
    where: permissionlogWhereUniqueInput
  }


  /**
   * permissionlog deleteMany
   */
  export type permissionlogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissionlogs to delete
     */
    where?: permissionlogWhereInput
  }


  /**
   * permissionlog without action
   */
  export type permissionlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
  }



  /**
   * Model userlog
   */


  export type AggregateUserlog = {
    _count: UserlogCountAggregateOutputType | null
    _avg: UserlogAvgAggregateOutputType | null
    _sum: UserlogSumAggregateOutputType | null
    _min: UserlogMinAggregateOutputType | null
    _max: UserlogMaxAggregateOutputType | null
  }

  export type UserlogAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type UserlogSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type UserlogMinAggregateOutputType = {
    id: number | null
    userid: number | null
    action: string | null
    createat: Date | null
  }

  export type UserlogMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    action: string | null
    createat: Date | null
  }

  export type UserlogCountAggregateOutputType = {
    id: number
    userid: number
    action: number
    createat: number
    _all: number
  }


  export type UserlogAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type UserlogSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type UserlogMinAggregateInputType = {
    id?: true
    userid?: true
    action?: true
    createat?: true
  }

  export type UserlogMaxAggregateInputType = {
    id?: true
    userid?: true
    action?: true
    createat?: true
  }

  export type UserlogCountAggregateInputType = {
    id?: true
    userid?: true
    action?: true
    createat?: true
    _all?: true
  }

  export type UserlogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userlog to aggregate.
     */
    where?: userlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userlogs to fetch.
     */
    orderBy?: userlogOrderByWithRelationInput | userlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userlogs
    **/
    _count?: true | UserlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserlogMaxAggregateInputType
  }

  export type GetUserlogAggregateType<T extends UserlogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserlog[P]>
      : GetScalarType<T[P], AggregateUserlog[P]>
  }




  export type userlogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userlogWhereInput
    orderBy?: userlogOrderByWithAggregationInput | userlogOrderByWithAggregationInput[]
    by: UserlogScalarFieldEnum[] | UserlogScalarFieldEnum
    having?: userlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserlogCountAggregateInputType | true
    _avg?: UserlogAvgAggregateInputType
    _sum?: UserlogSumAggregateInputType
    _min?: UserlogMinAggregateInputType
    _max?: UserlogMaxAggregateInputType
  }


  export type UserlogGroupByOutputType = {
    id: number
    userid: number
    action: string
    createat: Date
    _count: UserlogCountAggregateOutputType | null
    _avg: UserlogAvgAggregateOutputType | null
    _sum: UserlogSumAggregateOutputType | null
    _min: UserlogMinAggregateOutputType | null
    _max: UserlogMaxAggregateOutputType | null
  }

  type GetUserlogGroupByPayload<T extends userlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserlogGroupByOutputType[P]>
            : GetScalarType<T[P], UserlogGroupByOutputType[P]>
        }
      >
    >


  export type userlogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    action?: boolean
    createat?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["userlog"]>

  export type userlogSelectScalar = {
    id?: boolean
    userid?: boolean
    action?: boolean
    createat?: boolean
  }

  export type userlogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type userlogGetPayload<S extends boolean | null | undefined | userlogArgs> = $Types.GetResult<userlogPayload, S>

  type userlogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userlogFindManyArgs, 'select' | 'include'> & {
      select?: UserlogCountAggregateInputType | true
    }

  export interface userlogDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userlog'], meta: { name: 'userlog' } }
    /**
     * Find zero or one Userlog that matches the filter.
     * @param {userlogFindUniqueArgs} args - Arguments to find a Userlog
     * @example
     * // Get one Userlog
     * const userlog = await prisma.userlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userlogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userlogFindUniqueArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Userlog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userlogFindUniqueOrThrowArgs} args - Arguments to find a Userlog
     * @example
     * // Get one Userlog
     * const userlog = await prisma.userlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userlogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userlogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Userlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userlogFindFirstArgs} args - Arguments to find a Userlog
     * @example
     * // Get one Userlog
     * const userlog = await prisma.userlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userlogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userlogFindFirstArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Userlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userlogFindFirstOrThrowArgs} args - Arguments to find a Userlog
     * @example
     * // Get one Userlog
     * const userlog = await prisma.userlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userlogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userlogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Userlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userlogs
     * const userlogs = await prisma.userlog.findMany()
     * 
     * // Get first 10 Userlogs
     * const userlogs = await prisma.userlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userlogWithIdOnly = await prisma.userlog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userlogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userlogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userlogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Userlog.
     * @param {userlogCreateArgs} args - Arguments to create a Userlog.
     * @example
     * // Create one Userlog
     * const Userlog = await prisma.userlog.create({
     *   data: {
     *     // ... data to create a Userlog
     *   }
     * })
     * 
    **/
    create<T extends userlogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userlogCreateArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Userlogs.
     *     @param {userlogCreateManyArgs} args - Arguments to create many Userlogs.
     *     @example
     *     // Create many Userlogs
     *     const userlog = await prisma.userlog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userlogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userlogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userlog.
     * @param {userlogDeleteArgs} args - Arguments to delete one Userlog.
     * @example
     * // Delete one Userlog
     * const Userlog = await prisma.userlog.delete({
     *   where: {
     *     // ... filter to delete one Userlog
     *   }
     * })
     * 
    **/
    delete<T extends userlogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userlogDeleteArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Userlog.
     * @param {userlogUpdateArgs} args - Arguments to update one Userlog.
     * @example
     * // Update one Userlog
     * const userlog = await prisma.userlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userlogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userlogUpdateArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Userlogs.
     * @param {userlogDeleteManyArgs} args - Arguments to filter Userlogs to delete.
     * @example
     * // Delete a few Userlogs
     * const { count } = await prisma.userlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userlogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userlogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userlogs
     * const userlog = await prisma.userlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userlogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userlogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userlog.
     * @param {userlogUpsertArgs} args - Arguments to update or create a Userlog.
     * @example
     * // Update or create a Userlog
     * const userlog = await prisma.userlog.upsert({
     *   create: {
     *     // ... data to create a Userlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userlog we want to update
     *   }
     * })
    **/
    upsert<T extends userlogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userlogUpsertArgs<ExtArgs>>
    ): Prisma__userlogClient<$Types.GetResult<userlogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Userlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userlogCountArgs} args - Arguments to filter Userlogs to count.
     * @example
     * // Count the number of Userlogs
     * const count = await prisma.userlog.count({
     *   where: {
     *     // ... the filter for the Userlogs we want to count
     *   }
     * })
    **/
    count<T extends userlogCountArgs>(
      args?: Subset<T, userlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserlogAggregateArgs>(args: Subset<T, UserlogAggregateArgs>): Prisma.PrismaPromise<GetUserlogAggregateType<T>>

    /**
     * Group by Userlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userlogGroupByArgs['orderBy'] }
        : { orderBy?: userlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userlog model
   */
  readonly fields: userlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userlogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the userlog model
   */ 
  interface userlogFieldRefs {
    readonly id: FieldRef<"userlog", 'Int'>
    readonly userid: FieldRef<"userlog", 'Int'>
    readonly action: FieldRef<"userlog", 'String'>
    readonly createat: FieldRef<"userlog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * userlog findUnique
   */
  export type userlogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * Filter, which userlog to fetch.
     */
    where: userlogWhereUniqueInput
  }


  /**
   * userlog findUniqueOrThrow
   */
  export type userlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * Filter, which userlog to fetch.
     */
    where: userlogWhereUniqueInput
  }


  /**
   * userlog findFirst
   */
  export type userlogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * Filter, which userlog to fetch.
     */
    where?: userlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userlogs to fetch.
     */
    orderBy?: userlogOrderByWithRelationInput | userlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userlogs.
     */
    cursor?: userlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userlogs.
     */
    distinct?: UserlogScalarFieldEnum | UserlogScalarFieldEnum[]
  }


  /**
   * userlog findFirstOrThrow
   */
  export type userlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * Filter, which userlog to fetch.
     */
    where?: userlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userlogs to fetch.
     */
    orderBy?: userlogOrderByWithRelationInput | userlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userlogs.
     */
    cursor?: userlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userlogs.
     */
    distinct?: UserlogScalarFieldEnum | UserlogScalarFieldEnum[]
  }


  /**
   * userlog findMany
   */
  export type userlogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * Filter, which userlogs to fetch.
     */
    where?: userlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userlogs to fetch.
     */
    orderBy?: userlogOrderByWithRelationInput | userlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userlogs.
     */
    cursor?: userlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userlogs.
     */
    skip?: number
    distinct?: UserlogScalarFieldEnum | UserlogScalarFieldEnum[]
  }


  /**
   * userlog create
   */
  export type userlogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * The data needed to create a userlog.
     */
    data: XOR<userlogCreateInput, userlogUncheckedCreateInput>
  }


  /**
   * userlog createMany
   */
  export type userlogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userlogs.
     */
    data: userlogCreateManyInput | userlogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userlog update
   */
  export type userlogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * The data needed to update a userlog.
     */
    data: XOR<userlogUpdateInput, userlogUncheckedUpdateInput>
    /**
     * Choose, which userlog to update.
     */
    where: userlogWhereUniqueInput
  }


  /**
   * userlog updateMany
   */
  export type userlogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userlogs.
     */
    data: XOR<userlogUpdateManyMutationInput, userlogUncheckedUpdateManyInput>
    /**
     * Filter which userlogs to update
     */
    where?: userlogWhereInput
  }


  /**
   * userlog upsert
   */
  export type userlogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * The filter to search for the userlog to update in case it exists.
     */
    where: userlogWhereUniqueInput
    /**
     * In case the userlog found by the `where` argument doesn't exist, create a new userlog with this data.
     */
    create: XOR<userlogCreateInput, userlogUncheckedCreateInput>
    /**
     * In case the userlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userlogUpdateInput, userlogUncheckedUpdateInput>
  }


  /**
   * userlog delete
   */
  export type userlogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
    /**
     * Filter which userlog to delete.
     */
    where: userlogWhereUniqueInput
  }


  /**
   * userlog deleteMany
   */
  export type userlogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userlogs to delete
     */
    where?: userlogWhereInput
  }


  /**
   * userlog without action
   */
  export type userlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userlog
     */
    select?: userlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userlogInclude<ExtArgs> | null
  }



  /**
   * Model permission
   */


  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userid: number | null
    createdat: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    userid: number | null
    createdat: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userid: number
    createdat: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userid?: true
    createdat?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userid?: true
    createdat?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userid?: true
    createdat?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type permissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithAggregationInput | permissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }


  export type PermissionGroupByOutputType = {
    id: number
    name: string
    description: string
    userid: number
    createdat: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userid?: boolean
    createdat?: boolean
    permission?: boolean | userArgs<ExtArgs>
    permissionlog?: boolean | permission$permissionlogArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userid?: boolean
    createdat?: boolean
  }

  export type permissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    permission?: boolean | userArgs<ExtArgs>
    permissionlog?: boolean | permission$permissionlogArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeArgs<ExtArgs>
  }


  type permissionGetPayload<S extends boolean | null | undefined | permissionArgs> = $Types.GetResult<permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<permissionFindManyArgs, 'select' | 'include'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends permissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends permissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends permissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends permissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, permissionCreateArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Permissions.
     *     @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permission = await prisma.permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends permissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends permissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends permissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends permissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends permissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends permissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionGroupByArgs['orderBy'] }
        : { orderBy?: permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission model
   */
  readonly fields: permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    permission<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    permissionlog<T extends permission$permissionlogArgs<ExtArgs> = {}>(args?: Subset<T, permission$permissionlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<permissionlogPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the permission model
   */ 
  interface permissionFieldRefs {
    readonly id: FieldRef<"permission", 'Int'>
    readonly name: FieldRef<"permission", 'String'>
    readonly description: FieldRef<"permission", 'String'>
    readonly userid: FieldRef<"permission", 'Int'>
    readonly createdat: FieldRef<"permission", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * permission findUnique
   */
  export type permissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission findFirst
   */
  export type permissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }


  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }


  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
  }


  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }


  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
  }


  /**
   * permission.permissionlog
   */
  export type permission$permissionlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissionlog
     */
    select?: permissionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionlogInclude<ExtArgs> | null
    where?: permissionlogWhereInput
    orderBy?: permissionlogOrderByWithRelationInput | permissionlogOrderByWithRelationInput[]
    cursor?: permissionlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionlogScalarFieldEnum | PermissionlogScalarFieldEnum[]
  }


  /**
   * permission without action
   */
  export type permissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
  }



  /**
   * Model users_profile
   */


  export type AggregateUsers_profile = {
    _count: Users_profileCountAggregateOutputType | null
    _avg: Users_profileAvgAggregateOutputType | null
    _sum: Users_profileSumAggregateOutputType | null
    _min: Users_profileMinAggregateOutputType | null
    _max: Users_profileMaxAggregateOutputType | null
  }

  export type Users_profileAvgAggregateOutputType = {
    id: number | null
    number_address: number | null
    userid: number | null
  }

  export type Users_profileSumAggregateOutputType = {
    id: number | null
    number_address: number | null
    userid: number | null
  }

  export type Users_profileMinAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    street: string | null
    phone_number: string | null
    number_address: number | null
    neigh: string | null
    userid: number | null
  }

  export type Users_profileMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    street: string | null
    phone_number: string | null
    number_address: number | null
    neigh: string | null
    userid: number | null
  }

  export type Users_profileCountAggregateOutputType = {
    id: number
    name: number
    lastname: number
    street: number
    phone_number: number
    number_address: number
    neigh: number
    userid: number
    _all: number
  }


  export type Users_profileAvgAggregateInputType = {
    id?: true
    number_address?: true
    userid?: true
  }

  export type Users_profileSumAggregateInputType = {
    id?: true
    number_address?: true
    userid?: true
  }

  export type Users_profileMinAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    street?: true
    phone_number?: true
    number_address?: true
    neigh?: true
    userid?: true
  }

  export type Users_profileMaxAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    street?: true
    phone_number?: true
    number_address?: true
    neigh?: true
    userid?: true
  }

  export type Users_profileCountAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    street?: true
    phone_number?: true
    number_address?: true
    neigh?: true
    userid?: true
    _all?: true
  }

  export type Users_profileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_profile to aggregate.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_profiles
    **/
    _count?: true | Users_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_profileMaxAggregateInputType
  }

  export type GetUsers_profileAggregateType<T extends Users_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_profile[P]>
      : GetScalarType<T[P], AggregateUsers_profile[P]>
  }




  export type users_profileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: users_profileWhereInput
    orderBy?: users_profileOrderByWithAggregationInput | users_profileOrderByWithAggregationInput[]
    by: Users_profileScalarFieldEnum[] | Users_profileScalarFieldEnum
    having?: users_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_profileCountAggregateInputType | true
    _avg?: Users_profileAvgAggregateInputType
    _sum?: Users_profileSumAggregateInputType
    _min?: Users_profileMinAggregateInputType
    _max?: Users_profileMaxAggregateInputType
  }


  export type Users_profileGroupByOutputType = {
    id: number
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
    userid: number
    _count: Users_profileCountAggregateOutputType | null
    _avg: Users_profileAvgAggregateOutputType | null
    _sum: Users_profileSumAggregateOutputType | null
    _min: Users_profileMinAggregateOutputType | null
    _max: Users_profileMaxAggregateOutputType | null
  }

  type GetUsers_profileGroupByPayload<T extends users_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Users_profileGroupByOutputType[P]>
        }
      >
    >


  export type users_profileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    street?: boolean
    phone_number?: boolean
    number_address?: boolean
    neigh?: boolean
    userid?: boolean
    profile?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["users_profile"]>

  export type users_profileSelectScalar = {
    id?: boolean
    name?: boolean
    lastname?: boolean
    street?: boolean
    phone_number?: boolean
    number_address?: boolean
    neigh?: boolean
    userid?: boolean
  }

  export type users_profileInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    profile?: boolean | userArgs<ExtArgs>
  }


  type users_profileGetPayload<S extends boolean | null | undefined | users_profileArgs> = $Types.GetResult<users_profilePayload, S>

  type users_profileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<users_profileFindManyArgs, 'select' | 'include'> & {
      select?: Users_profileCountAggregateInputType | true
    }

  export interface users_profileDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_profile'], meta: { name: 'users_profile' } }
    /**
     * Find zero or one Users_profile that matches the filter.
     * @param {users_profileFindUniqueArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends users_profileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, users_profileFindUniqueArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users_profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {users_profileFindUniqueOrThrowArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends users_profileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, users_profileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileFindFirstArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends users_profileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, users_profileFindFirstArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users_profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileFindFirstOrThrowArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends users_profileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, users_profileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_profiles
     * const users_profiles = await prisma.users_profile.findMany()
     * 
     * // Get first 10 Users_profiles
     * const users_profiles = await prisma.users_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_profileWithIdOnly = await prisma.users_profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends users_profileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_profileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users_profile.
     * @param {users_profileCreateArgs} args - Arguments to create a Users_profile.
     * @example
     * // Create one Users_profile
     * const Users_profile = await prisma.users_profile.create({
     *   data: {
     *     // ... data to create a Users_profile
     *   }
     * })
     * 
    **/
    create<T extends users_profileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, users_profileCreateArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users_profiles.
     *     @param {users_profileCreateManyArgs} args - Arguments to create many Users_profiles.
     *     @example
     *     // Create many Users_profiles
     *     const users_profile = await prisma.users_profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends users_profileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_profileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_profile.
     * @param {users_profileDeleteArgs} args - Arguments to delete one Users_profile.
     * @example
     * // Delete one Users_profile
     * const Users_profile = await prisma.users_profile.delete({
     *   where: {
     *     // ... filter to delete one Users_profile
     *   }
     * })
     * 
    **/
    delete<T extends users_profileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, users_profileDeleteArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users_profile.
     * @param {users_profileUpdateArgs} args - Arguments to update one Users_profile.
     * @example
     * // Update one Users_profile
     * const users_profile = await prisma.users_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends users_profileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, users_profileUpdateArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users_profiles.
     * @param {users_profileDeleteManyArgs} args - Arguments to filter Users_profiles to delete.
     * @example
     * // Delete a few Users_profiles
     * const { count } = await prisma.users_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends users_profileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_profileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_profiles
     * const users_profile = await prisma.users_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends users_profileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, users_profileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_profile.
     * @param {users_profileUpsertArgs} args - Arguments to update or create a Users_profile.
     * @example
     * // Update or create a Users_profile
     * const users_profile = await prisma.users_profile.upsert({
     *   create: {
     *     // ... data to create a Users_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_profile we want to update
     *   }
     * })
    **/
    upsert<T extends users_profileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, users_profileUpsertArgs<ExtArgs>>
    ): Prisma__users_profileClient<$Types.GetResult<users_profilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileCountArgs} args - Arguments to filter Users_profiles to count.
     * @example
     * // Count the number of Users_profiles
     * const count = await prisma.users_profile.count({
     *   where: {
     *     // ... the filter for the Users_profiles we want to count
     *   }
     * })
    **/
    count<T extends users_profileCountArgs>(
      args?: Subset<T, users_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_profileAggregateArgs>(args: Subset<T, Users_profileAggregateArgs>): Prisma.PrismaPromise<GetUsers_profileAggregateType<T>>

    /**
     * Group by Users_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_profileGroupByArgs['orderBy'] }
        : { orderBy?: users_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_profile model
   */
  readonly fields: users_profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__users_profileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the users_profile model
   */ 
  interface users_profileFieldRefs {
    readonly id: FieldRef<"users_profile", 'Int'>
    readonly name: FieldRef<"users_profile", 'String'>
    readonly lastname: FieldRef<"users_profile", 'String'>
    readonly street: FieldRef<"users_profile", 'String'>
    readonly phone_number: FieldRef<"users_profile", 'String'>
    readonly number_address: FieldRef<"users_profile", 'Int'>
    readonly neigh: FieldRef<"users_profile", 'String'>
    readonly userid: FieldRef<"users_profile", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * users_profile findUnique
   */
  export type users_profileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where: users_profileWhereUniqueInput
  }


  /**
   * users_profile findUniqueOrThrow
   */
  export type users_profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where: users_profileWhereUniqueInput
  }


  /**
   * users_profile findFirst
   */
  export type users_profileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_profiles.
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_profiles.
     */
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }


  /**
   * users_profile findFirstOrThrow
   */
  export type users_profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_profiles.
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_profiles.
     */
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }


  /**
   * users_profile findMany
   */
  export type users_profileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profiles to fetch.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_profiles.
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }


  /**
   * users_profile create
   */
  export type users_profileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * The data needed to create a users_profile.
     */
    data: XOR<users_profileCreateInput, users_profileUncheckedCreateInput>
  }


  /**
   * users_profile createMany
   */
  export type users_profileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_profiles.
     */
    data: users_profileCreateManyInput | users_profileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * users_profile update
   */
  export type users_profileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * The data needed to update a users_profile.
     */
    data: XOR<users_profileUpdateInput, users_profileUncheckedUpdateInput>
    /**
     * Choose, which users_profile to update.
     */
    where: users_profileWhereUniqueInput
  }


  /**
   * users_profile updateMany
   */
  export type users_profileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_profiles.
     */
    data: XOR<users_profileUpdateManyMutationInput, users_profileUncheckedUpdateManyInput>
    /**
     * Filter which users_profiles to update
     */
    where?: users_profileWhereInput
  }


  /**
   * users_profile upsert
   */
  export type users_profileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * The filter to search for the users_profile to update in case it exists.
     */
    where: users_profileWhereUniqueInput
    /**
     * In case the users_profile found by the `where` argument doesn't exist, create a new users_profile with this data.
     */
    create: XOR<users_profileCreateInput, users_profileUncheckedCreateInput>
    /**
     * In case the users_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_profileUpdateInput, users_profileUncheckedUpdateInput>
  }


  /**
   * users_profile delete
   */
  export type users_profileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter which users_profile to delete.
     */
    where: users_profileWhereUniqueInput
  }


  /**
   * users_profile deleteMany
   */
  export type users_profileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_profiles to delete
     */
    where?: users_profileWhereInput
  }


  /**
   * users_profile without action
   */
  export type users_profileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: users_profileInclude<ExtArgs> | null
  }



  /**
   * Model cookie
   */


  export type AggregateCookie = {
    _count: CookieCountAggregateOutputType | null
    _avg: CookieAvgAggregateOutputType | null
    _sum: CookieSumAggregateOutputType | null
    _min: CookieMinAggregateOutputType | null
    _max: CookieMaxAggregateOutputType | null
  }

  export type CookieAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type CookieSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type CookieMinAggregateOutputType = {
    id: number | null
    value: string | null
    userid: number | null
    createdat: Date | null
  }

  export type CookieMaxAggregateOutputType = {
    id: number | null
    value: string | null
    userid: number | null
    createdat: Date | null
  }

  export type CookieCountAggregateOutputType = {
    id: number
    value: number
    userid: number
    createdat: number
    _all: number
  }


  export type CookieAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type CookieSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type CookieMinAggregateInputType = {
    id?: true
    value?: true
    userid?: true
    createdat?: true
  }

  export type CookieMaxAggregateInputType = {
    id?: true
    value?: true
    userid?: true
    createdat?: true
  }

  export type CookieCountAggregateInputType = {
    id?: true
    value?: true
    userid?: true
    createdat?: true
    _all?: true
  }

  export type CookieAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cookie to aggregate.
     */
    where?: cookieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cookies to fetch.
     */
    orderBy?: cookieOrderByWithRelationInput | cookieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cookieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cookies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cookies
    **/
    _count?: true | CookieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CookieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CookieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CookieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CookieMaxAggregateInputType
  }

  export type GetCookieAggregateType<T extends CookieAggregateArgs> = {
        [P in keyof T & keyof AggregateCookie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCookie[P]>
      : GetScalarType<T[P], AggregateCookie[P]>
  }




  export type cookieGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: cookieWhereInput
    orderBy?: cookieOrderByWithAggregationInput | cookieOrderByWithAggregationInput[]
    by: CookieScalarFieldEnum[] | CookieScalarFieldEnum
    having?: cookieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CookieCountAggregateInputType | true
    _avg?: CookieAvgAggregateInputType
    _sum?: CookieSumAggregateInputType
    _min?: CookieMinAggregateInputType
    _max?: CookieMaxAggregateInputType
  }


  export type CookieGroupByOutputType = {
    id: number
    value: string
    userid: number
    createdat: Date
    _count: CookieCountAggregateOutputType | null
    _avg: CookieAvgAggregateOutputType | null
    _sum: CookieSumAggregateOutputType | null
    _min: CookieMinAggregateOutputType | null
    _max: CookieMaxAggregateOutputType | null
  }

  type GetCookieGroupByPayload<T extends cookieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CookieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CookieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CookieGroupByOutputType[P]>
            : GetScalarType<T[P], CookieGroupByOutputType[P]>
        }
      >
    >


  export type cookieSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["cookie"]>

  export type cookieSelectScalar = {
    id?: boolean
    value?: boolean
    userid?: boolean
    createdat?: boolean
  }

  export type cookieInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type cookieGetPayload<S extends boolean | null | undefined | cookieArgs> = $Types.GetResult<cookiePayload, S>

  type cookieCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<cookieFindManyArgs, 'select' | 'include'> & {
      select?: CookieCountAggregateInputType | true
    }

  export interface cookieDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cookie'], meta: { name: 'cookie' } }
    /**
     * Find zero or one Cookie that matches the filter.
     * @param {cookieFindUniqueArgs} args - Arguments to find a Cookie
     * @example
     * // Get one Cookie
     * const cookie = await prisma.cookie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cookieFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cookieFindUniqueArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cookie that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cookieFindUniqueOrThrowArgs} args - Arguments to find a Cookie
     * @example
     * // Get one Cookie
     * const cookie = await prisma.cookie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cookieFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cookieFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cookie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cookieFindFirstArgs} args - Arguments to find a Cookie
     * @example
     * // Get one Cookie
     * const cookie = await prisma.cookie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cookieFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cookieFindFirstArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cookie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cookieFindFirstOrThrowArgs} args - Arguments to find a Cookie
     * @example
     * // Get one Cookie
     * const cookie = await prisma.cookie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cookieFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cookieFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cookies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cookieFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cookies
     * const cookies = await prisma.cookie.findMany()
     * 
     * // Get first 10 Cookies
     * const cookies = await prisma.cookie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cookieWithIdOnly = await prisma.cookie.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cookieFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cookieFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<cookiePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cookie.
     * @param {cookieCreateArgs} args - Arguments to create a Cookie.
     * @example
     * // Create one Cookie
     * const Cookie = await prisma.cookie.create({
     *   data: {
     *     // ... data to create a Cookie
     *   }
     * })
     * 
    **/
    create<T extends cookieCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cookieCreateArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cookies.
     *     @param {cookieCreateManyArgs} args - Arguments to create many Cookies.
     *     @example
     *     // Create many Cookies
     *     const cookie = await prisma.cookie.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cookieCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cookieCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cookie.
     * @param {cookieDeleteArgs} args - Arguments to delete one Cookie.
     * @example
     * // Delete one Cookie
     * const Cookie = await prisma.cookie.delete({
     *   where: {
     *     // ... filter to delete one Cookie
     *   }
     * })
     * 
    **/
    delete<T extends cookieDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cookieDeleteArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cookie.
     * @param {cookieUpdateArgs} args - Arguments to update one Cookie.
     * @example
     * // Update one Cookie
     * const cookie = await prisma.cookie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cookieUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cookieUpdateArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cookies.
     * @param {cookieDeleteManyArgs} args - Arguments to filter Cookies to delete.
     * @example
     * // Delete a few Cookies
     * const { count } = await prisma.cookie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cookieDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cookieDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cookies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cookieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cookies
     * const cookie = await prisma.cookie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cookieUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cookieUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cookie.
     * @param {cookieUpsertArgs} args - Arguments to update or create a Cookie.
     * @example
     * // Update or create a Cookie
     * const cookie = await prisma.cookie.upsert({
     *   create: {
     *     // ... data to create a Cookie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cookie we want to update
     *   }
     * })
    **/
    upsert<T extends cookieUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cookieUpsertArgs<ExtArgs>>
    ): Prisma__cookieClient<$Types.GetResult<cookiePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cookies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cookieCountArgs} args - Arguments to filter Cookies to count.
     * @example
     * // Count the number of Cookies
     * const count = await prisma.cookie.count({
     *   where: {
     *     // ... the filter for the Cookies we want to count
     *   }
     * })
    **/
    count<T extends cookieCountArgs>(
      args?: Subset<T, cookieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CookieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cookie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CookieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CookieAggregateArgs>(args: Subset<T, CookieAggregateArgs>): Prisma.PrismaPromise<GetCookieAggregateType<T>>

    /**
     * Group by Cookie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cookieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cookieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cookieGroupByArgs['orderBy'] }
        : { orderBy?: cookieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cookieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCookieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cookie model
   */
  readonly fields: cookieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cookie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cookieClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the cookie model
   */ 
  interface cookieFieldRefs {
    readonly id: FieldRef<"cookie", 'Int'>
    readonly value: FieldRef<"cookie", 'String'>
    readonly userid: FieldRef<"cookie", 'Int'>
    readonly createdat: FieldRef<"cookie", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * cookie findUnique
   */
  export type cookieFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * Filter, which cookie to fetch.
     */
    where: cookieWhereUniqueInput
  }


  /**
   * cookie findUniqueOrThrow
   */
  export type cookieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * Filter, which cookie to fetch.
     */
    where: cookieWhereUniqueInput
  }


  /**
   * cookie findFirst
   */
  export type cookieFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * Filter, which cookie to fetch.
     */
    where?: cookieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cookies to fetch.
     */
    orderBy?: cookieOrderByWithRelationInput | cookieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cookies.
     */
    cursor?: cookieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cookies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cookies.
     */
    distinct?: CookieScalarFieldEnum | CookieScalarFieldEnum[]
  }


  /**
   * cookie findFirstOrThrow
   */
  export type cookieFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * Filter, which cookie to fetch.
     */
    where?: cookieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cookies to fetch.
     */
    orderBy?: cookieOrderByWithRelationInput | cookieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cookies.
     */
    cursor?: cookieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cookies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cookies.
     */
    distinct?: CookieScalarFieldEnum | CookieScalarFieldEnum[]
  }


  /**
   * cookie findMany
   */
  export type cookieFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * Filter, which cookies to fetch.
     */
    where?: cookieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cookies to fetch.
     */
    orderBy?: cookieOrderByWithRelationInput | cookieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cookies.
     */
    cursor?: cookieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cookies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cookies.
     */
    skip?: number
    distinct?: CookieScalarFieldEnum | CookieScalarFieldEnum[]
  }


  /**
   * cookie create
   */
  export type cookieCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * The data needed to create a cookie.
     */
    data: XOR<cookieCreateInput, cookieUncheckedCreateInput>
  }


  /**
   * cookie createMany
   */
  export type cookieCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cookies.
     */
    data: cookieCreateManyInput | cookieCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cookie update
   */
  export type cookieUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * The data needed to update a cookie.
     */
    data: XOR<cookieUpdateInput, cookieUncheckedUpdateInput>
    /**
     * Choose, which cookie to update.
     */
    where: cookieWhereUniqueInput
  }


  /**
   * cookie updateMany
   */
  export type cookieUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cookies.
     */
    data: XOR<cookieUpdateManyMutationInput, cookieUncheckedUpdateManyInput>
    /**
     * Filter which cookies to update
     */
    where?: cookieWhereInput
  }


  /**
   * cookie upsert
   */
  export type cookieUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * The filter to search for the cookie to update in case it exists.
     */
    where: cookieWhereUniqueInput
    /**
     * In case the cookie found by the `where` argument doesn't exist, create a new cookie with this data.
     */
    create: XOR<cookieCreateInput, cookieUncheckedCreateInput>
    /**
     * In case the cookie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cookieUpdateInput, cookieUncheckedUpdateInput>
  }


  /**
   * cookie delete
   */
  export type cookieDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
    /**
     * Filter which cookie to delete.
     */
    where: cookieWhereUniqueInput
  }


  /**
   * cookie deleteMany
   */
  export type cookieDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cookies to delete
     */
    where?: cookieWhereInput
  }


  /**
   * cookie without action
   */
  export type cookieArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cookie
     */
    select?: cookieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cookieInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    usecase: 'usecase',
    createdat: 'createdat'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Statistics_teamScalarFieldEnum: {
    league_team_id: 'league_team_id',
    fixtures: 'fixtures',
    biggest: 'biggest',
    goals: 'goals',
    clean_sheet: 'clean_sheet',
    failed_to_score: 'failed_to_score',
    penalty: 'penalty',
    lineups: 'lineups',
    cards: 'cards'
  };

  export type Statistics_teamScalarFieldEnum = (typeof Statistics_teamScalarFieldEnum)[keyof typeof Statistics_teamScalarFieldEnum]


  export const Fixture_roundScalarFieldEnum: {
    id: 'id',
    round: 'round',
    seasson: 'seasson',
    league: 'league',
    leagues_teams_id: 'leagues_teams_id',
    status: 'status',
    venus: 'venus',
    date: 'date',
    goals: 'goals',
    score: 'score',
    fulltime: 'fulltime',
    extratime: 'extratime',
    penalty: 'penalty'
  };

  export type Fixture_roundScalarFieldEnum = (typeof Fixture_roundScalarFieldEnum)[keyof typeof Fixture_roundScalarFieldEnum]


  export const Football_playersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastname: 'lastname',
    age: 'age',
    birth: 'birth',
    nationality: 'nationality',
    height: 'height',
    weight: 'weight',
    injured: 'injured',
    photo: 'photo',
    statistics: 'statistics'
  };

  export type Football_playersScalarFieldEnum = (typeof Football_playersScalarFieldEnum)[keyof typeof Football_playersScalarFieldEnum]


  export const Team_playerScalarFieldEnum: {
    id: 'id',
    team_id: 'team_id',
    player_id: 'player_id'
  };

  export type Team_playerScalarFieldEnum = (typeof Team_playerScalarFieldEnum)[keyof typeof Team_playerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    userid: 'userid',
    createdat: 'createdat'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    productid: 'productid',
    userid: 'userid',
    quantity: 'quantity',
    total: 'total',
    createdat: 'createdat'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    userid: 'userid',
    createdat: 'createdat'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletmovementScalarFieldEnum: {
    id: 'id',
    walletid: 'walletid',
    amount: 'amount',
    movementtype: 'movementtype',
    createdat: 'createdat'
  };

  export type WalletmovementScalarFieldEnum = (typeof WalletmovementScalarFieldEnum)[keyof typeof WalletmovementScalarFieldEnum]


  export const LeaguesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cup: 'cup',
    country: 'country',
    code: 'code',
    flag: 'flag'
  };

  export type LeaguesScalarFieldEnum = (typeof LeaguesScalarFieldEnum)[keyof typeof LeaguesScalarFieldEnum]


  export const League_teamsScalarFieldEnum: {
    id: 'id',
    league_id: 'league_id',
    team_id: 'team_id'
  };

  export type League_teamsScalarFieldEnum = (typeof League_teamsScalarFieldEnum)[keyof typeof League_teamsScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    name: 'name',
    code: 'code',
    flag: 'flag'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    founded: 'founded',
    national: 'national',
    logo: 'logo',
    venues: 'venues'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    phone: 'phone',
    description: 'description',
    createdat: 'createdat'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const PasswordhashScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    hash: 'hash',
    salt: 'salt',
    createdat: 'createdat'
  };

  export type PasswordhashScalarFieldEnum = (typeof PasswordhashScalarFieldEnum)[keyof typeof PasswordhashScalarFieldEnum]


  export const PermissionlogScalarFieldEnum: {
    id: 'id',
    permissionid: 'permissionid',
    action: 'action',
    createdat: 'createdat'
  };

  export type PermissionlogScalarFieldEnum = (typeof PermissionlogScalarFieldEnum)[keyof typeof PermissionlogScalarFieldEnum]


  export const UserlogScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    action: 'action',
    createat: 'createat'
  };

  export type UserlogScalarFieldEnum = (typeof UserlogScalarFieldEnum)[keyof typeof UserlogScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userid: 'userid',
    createdat: 'createdat'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const Users_profileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastname: 'lastname',
    street: 'street',
    phone_number: 'phone_number',
    number_address: 'number_address',
    neigh: 'neigh',
    userid: 'userid'
  };

  export type Users_profileScalarFieldEnum = (typeof Users_profileScalarFieldEnum)[keyof typeof Users_profileScalarFieldEnum]


  export const CookieScalarFieldEnum: {
    id: 'id',
    value: 'value',
    userid: 'userid',
    createdat: 'createdat'
  };

  export type CookieScalarFieldEnum = (typeof CookieScalarFieldEnum)[keyof typeof CookieScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'usecase'
   */
  export type EnumusecaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'usecase'>
    


  /**
   * Reference to a field of type 'usecase[]'
   */
  export type ListEnumusecaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'usecase[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'movementtype'
   */
  export type EnummovementtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'movementtype'>
    


  /**
   * Reference to a field of type 'movementtype[]'
   */
  export type ListEnummovementtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'movementtype[]'>
    


  /**
   * Reference to a field of type 'typecup'
   */
  export type EnumtypecupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'typecup'>
    


  /**
   * Reference to a field of type 'typecup[]'
   */
  export type ListEnumtypecupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'typecup[]'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    usecase?: EnumusecaseFilter<"user"> | usecase
    createdat?: DateTimeFilter<"user"> | Date | string
    passwordhash?: XOR<PasswordhashNullableRelationFilter, passwordhashWhereInput> | null
    cookies?: CookieListRelationFilter
    permission?: PermissionListRelationFilter
    userlog?: UserlogListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
    product?: ProductListRelationFilter
    order?: OrderListRelationFilter
    profile?: Users_profileListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    usecase?: SortOrder
    createdat?: SortOrder
    passwordhash?: passwordhashOrderByWithRelationInput
    cookies?: cookieOrderByRelationAggregateInput
    permission?: permissionOrderByRelationAggregateInput
    userlog?: userlogOrderByRelationAggregateInput
    wallet?: walletOrderByWithRelationInput
    product?: productOrderByRelationAggregateInput
    order?: orderOrderByRelationAggregateInput
    profile?: users_profileOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    usecase?: EnumusecaseFilter<"user"> | usecase
    createdat?: DateTimeFilter<"user"> | Date | string
    passwordhash?: XOR<PasswordhashNullableRelationFilter, passwordhashWhereInput> | null
    cookies?: CookieListRelationFilter
    permission?: PermissionListRelationFilter
    userlog?: UserlogListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
    product?: ProductListRelationFilter
    order?: OrderListRelationFilter
    profile?: Users_profileListRelationFilter
  }, "id" | "username" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    usecase?: SortOrder
    createdat?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    username?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    usecase?: EnumusecaseWithAggregatesFilter<"user"> | usecase
    createdat?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type statistics_teamWhereInput = {
    AND?: statistics_teamWhereInput | statistics_teamWhereInput[]
    OR?: statistics_teamWhereInput[]
    NOT?: statistics_teamWhereInput | statistics_teamWhereInput[]
    league_team_id?: IntFilter<"statistics_team"> | number
    fixtures?: JsonFilter<"statistics_team">
    biggest?: JsonFilter<"statistics_team">
    goals?: JsonFilter<"statistics_team">
    clean_sheet?: JsonFilter<"statistics_team">
    failed_to_score?: JsonFilter<"statistics_team">
    penalty?: JsonFilter<"statistics_team">
    lineups?: JsonFilter<"statistics_team">
    cards?: JsonFilter<"statistics_team">
    league_teamid?: XOR<League_teamsRelationFilter, league_teamsWhereInput>
  }

  export type statistics_teamOrderByWithRelationInput = {
    league_team_id?: SortOrder
    fixtures?: SortOrder
    biggest?: SortOrder
    goals?: SortOrder
    clean_sheet?: SortOrder
    failed_to_score?: SortOrder
    penalty?: SortOrder
    lineups?: SortOrder
    cards?: SortOrder
    league_teamid?: league_teamsOrderByWithRelationInput
  }

  export type statistics_teamWhereUniqueInput = Prisma.AtLeast<{
    league_team_id?: number
    AND?: statistics_teamWhereInput | statistics_teamWhereInput[]
    OR?: statistics_teamWhereInput[]
    NOT?: statistics_teamWhereInput | statistics_teamWhereInput[]
    fixtures?: JsonFilter<"statistics_team">
    biggest?: JsonFilter<"statistics_team">
    goals?: JsonFilter<"statistics_team">
    clean_sheet?: JsonFilter<"statistics_team">
    failed_to_score?: JsonFilter<"statistics_team">
    penalty?: JsonFilter<"statistics_team">
    lineups?: JsonFilter<"statistics_team">
    cards?: JsonFilter<"statistics_team">
    league_teamid?: XOR<League_teamsRelationFilter, league_teamsWhereInput>
  }, "league_team_id">

  export type statistics_teamOrderByWithAggregationInput = {
    league_team_id?: SortOrder
    fixtures?: SortOrder
    biggest?: SortOrder
    goals?: SortOrder
    clean_sheet?: SortOrder
    failed_to_score?: SortOrder
    penalty?: SortOrder
    lineups?: SortOrder
    cards?: SortOrder
    _count?: statistics_teamCountOrderByAggregateInput
    _avg?: statistics_teamAvgOrderByAggregateInput
    _max?: statistics_teamMaxOrderByAggregateInput
    _min?: statistics_teamMinOrderByAggregateInput
    _sum?: statistics_teamSumOrderByAggregateInput
  }

  export type statistics_teamScalarWhereWithAggregatesInput = {
    AND?: statistics_teamScalarWhereWithAggregatesInput | statistics_teamScalarWhereWithAggregatesInput[]
    OR?: statistics_teamScalarWhereWithAggregatesInput[]
    NOT?: statistics_teamScalarWhereWithAggregatesInput | statistics_teamScalarWhereWithAggregatesInput[]
    league_team_id?: IntWithAggregatesFilter<"statistics_team"> | number
    fixtures?: JsonWithAggregatesFilter<"statistics_team">
    biggest?: JsonWithAggregatesFilter<"statistics_team">
    goals?: JsonWithAggregatesFilter<"statistics_team">
    clean_sheet?: JsonWithAggregatesFilter<"statistics_team">
    failed_to_score?: JsonWithAggregatesFilter<"statistics_team">
    penalty?: JsonWithAggregatesFilter<"statistics_team">
    lineups?: JsonWithAggregatesFilter<"statistics_team">
    cards?: JsonWithAggregatesFilter<"statistics_team">
  }

  export type fixture_roundWhereInput = {
    AND?: fixture_roundWhereInput | fixture_roundWhereInput[]
    OR?: fixture_roundWhereInput[]
    NOT?: fixture_roundWhereInput | fixture_roundWhereInput[]
    id?: IntFilter<"fixture_round"> | number
    round?: StringFilter<"fixture_round"> | string
    seasson?: IntFilter<"fixture_round"> | number
    league?: JsonFilter<"fixture_round">
    leagues_teams_id?: IntFilter<"fixture_round"> | number
    status?: JsonFilter<"fixture_round">
    venus?: JsonFilter<"fixture_round">
    date?: DateTimeFilter<"fixture_round"> | Date | string
    goals?: JsonFilter<"fixture_round">
    score?: JsonFilter<"fixture_round">
    fulltime?: JsonFilter<"fixture_round">
    extratime?: JsonFilter<"fixture_round">
    penalty?: JsonFilter<"fixture_round">
  }

  export type fixture_roundOrderByWithRelationInput = {
    id?: SortOrder
    round?: SortOrder
    seasson?: SortOrder
    league?: SortOrder
    leagues_teams_id?: SortOrder
    status?: SortOrder
    venus?: SortOrder
    date?: SortOrder
    goals?: SortOrder
    score?: SortOrder
    fulltime?: SortOrder
    extratime?: SortOrder
    penalty?: SortOrder
  }

  export type fixture_roundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fixture_roundWhereInput | fixture_roundWhereInput[]
    OR?: fixture_roundWhereInput[]
    NOT?: fixture_roundWhereInput | fixture_roundWhereInput[]
    round?: StringFilter<"fixture_round"> | string
    seasson?: IntFilter<"fixture_round"> | number
    league?: JsonFilter<"fixture_round">
    leagues_teams_id?: IntFilter<"fixture_round"> | number
    status?: JsonFilter<"fixture_round">
    venus?: JsonFilter<"fixture_round">
    date?: DateTimeFilter<"fixture_round"> | Date | string
    goals?: JsonFilter<"fixture_round">
    score?: JsonFilter<"fixture_round">
    fulltime?: JsonFilter<"fixture_round">
    extratime?: JsonFilter<"fixture_round">
    penalty?: JsonFilter<"fixture_round">
  }, "id">

  export type fixture_roundOrderByWithAggregationInput = {
    id?: SortOrder
    round?: SortOrder
    seasson?: SortOrder
    league?: SortOrder
    leagues_teams_id?: SortOrder
    status?: SortOrder
    venus?: SortOrder
    date?: SortOrder
    goals?: SortOrder
    score?: SortOrder
    fulltime?: SortOrder
    extratime?: SortOrder
    penalty?: SortOrder
    _count?: fixture_roundCountOrderByAggregateInput
    _avg?: fixture_roundAvgOrderByAggregateInput
    _max?: fixture_roundMaxOrderByAggregateInput
    _min?: fixture_roundMinOrderByAggregateInput
    _sum?: fixture_roundSumOrderByAggregateInput
  }

  export type fixture_roundScalarWhereWithAggregatesInput = {
    AND?: fixture_roundScalarWhereWithAggregatesInput | fixture_roundScalarWhereWithAggregatesInput[]
    OR?: fixture_roundScalarWhereWithAggregatesInput[]
    NOT?: fixture_roundScalarWhereWithAggregatesInput | fixture_roundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fixture_round"> | number
    round?: StringWithAggregatesFilter<"fixture_round"> | string
    seasson?: IntWithAggregatesFilter<"fixture_round"> | number
    league?: JsonWithAggregatesFilter<"fixture_round">
    leagues_teams_id?: IntWithAggregatesFilter<"fixture_round"> | number
    status?: JsonWithAggregatesFilter<"fixture_round">
    venus?: JsonWithAggregatesFilter<"fixture_round">
    date?: DateTimeWithAggregatesFilter<"fixture_round"> | Date | string
    goals?: JsonWithAggregatesFilter<"fixture_round">
    score?: JsonWithAggregatesFilter<"fixture_round">
    fulltime?: JsonWithAggregatesFilter<"fixture_round">
    extratime?: JsonWithAggregatesFilter<"fixture_round">
    penalty?: JsonWithAggregatesFilter<"fixture_round">
  }

  export type football_playersWhereInput = {
    AND?: football_playersWhereInput | football_playersWhereInput[]
    OR?: football_playersWhereInput[]
    NOT?: football_playersWhereInput | football_playersWhereInput[]
    id?: IntFilter<"football_players"> | number
    name?: StringFilter<"football_players"> | string
    lastname?: StringFilter<"football_players"> | string
    age?: IntFilter<"football_players"> | number
    birth?: JsonFilter<"football_players">
    nationality?: StringFilter<"football_players"> | string
    height?: StringFilter<"football_players"> | string
    weight?: StringFilter<"football_players"> | string
    injured?: BoolFilter<"football_players"> | boolean
    photo?: StringFilter<"football_players"> | string
    statistics?: JsonFilter<"football_players">
    team_player?: Team_playerListRelationFilter
  }

  export type football_playersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    age?: SortOrder
    birth?: SortOrder
    nationality?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    injured?: SortOrder
    photo?: SortOrder
    statistics?: SortOrder
    team_player?: team_playerOrderByRelationAggregateInput
  }

  export type football_playersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: football_playersWhereInput | football_playersWhereInput[]
    OR?: football_playersWhereInput[]
    NOT?: football_playersWhereInput | football_playersWhereInput[]
    name?: StringFilter<"football_players"> | string
    lastname?: StringFilter<"football_players"> | string
    age?: IntFilter<"football_players"> | number
    birth?: JsonFilter<"football_players">
    nationality?: StringFilter<"football_players"> | string
    height?: StringFilter<"football_players"> | string
    weight?: StringFilter<"football_players"> | string
    injured?: BoolFilter<"football_players"> | boolean
    photo?: StringFilter<"football_players"> | string
    statistics?: JsonFilter<"football_players">
    team_player?: Team_playerListRelationFilter
  }, "id">

  export type football_playersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    age?: SortOrder
    birth?: SortOrder
    nationality?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    injured?: SortOrder
    photo?: SortOrder
    statistics?: SortOrder
    _count?: football_playersCountOrderByAggregateInput
    _avg?: football_playersAvgOrderByAggregateInput
    _max?: football_playersMaxOrderByAggregateInput
    _min?: football_playersMinOrderByAggregateInput
    _sum?: football_playersSumOrderByAggregateInput
  }

  export type football_playersScalarWhereWithAggregatesInput = {
    AND?: football_playersScalarWhereWithAggregatesInput | football_playersScalarWhereWithAggregatesInput[]
    OR?: football_playersScalarWhereWithAggregatesInput[]
    NOT?: football_playersScalarWhereWithAggregatesInput | football_playersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"football_players"> | number
    name?: StringWithAggregatesFilter<"football_players"> | string
    lastname?: StringWithAggregatesFilter<"football_players"> | string
    age?: IntWithAggregatesFilter<"football_players"> | number
    birth?: JsonWithAggregatesFilter<"football_players">
    nationality?: StringWithAggregatesFilter<"football_players"> | string
    height?: StringWithAggregatesFilter<"football_players"> | string
    weight?: StringWithAggregatesFilter<"football_players"> | string
    injured?: BoolWithAggregatesFilter<"football_players"> | boolean
    photo?: StringWithAggregatesFilter<"football_players"> | string
    statistics?: JsonWithAggregatesFilter<"football_players">
  }

  export type team_playerWhereInput = {
    AND?: team_playerWhereInput | team_playerWhereInput[]
    OR?: team_playerWhereInput[]
    NOT?: team_playerWhereInput | team_playerWhereInput[]
    id?: IntFilter<"team_player"> | number
    team_id?: IntFilter<"team_player"> | number
    player_id?: IntFilter<"team_player"> | number
    teamid?: XOR<TeamRelationFilter, teamWhereInput>
    playerid?: XOR<Football_playersRelationFilter, football_playersWhereInput>
  }

  export type team_playerOrderByWithRelationInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    teamid?: teamOrderByWithRelationInput
    playerid?: football_playersOrderByWithRelationInput
  }

  export type team_playerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    team_id_player_id?: team_playerTeam_idPlayer_idCompoundUniqueInput
    AND?: team_playerWhereInput | team_playerWhereInput[]
    OR?: team_playerWhereInput[]
    NOT?: team_playerWhereInput | team_playerWhereInput[]
    team_id?: IntFilter<"team_player"> | number
    player_id?: IntFilter<"team_player"> | number
    teamid?: XOR<TeamRelationFilter, teamWhereInput>
    playerid?: XOR<Football_playersRelationFilter, football_playersWhereInput>
  }, "id" | "team_id_player_id">

  export type team_playerOrderByWithAggregationInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    _count?: team_playerCountOrderByAggregateInput
    _avg?: team_playerAvgOrderByAggregateInput
    _max?: team_playerMaxOrderByAggregateInput
    _min?: team_playerMinOrderByAggregateInput
    _sum?: team_playerSumOrderByAggregateInput
  }

  export type team_playerScalarWhereWithAggregatesInput = {
    AND?: team_playerScalarWhereWithAggregatesInput | team_playerScalarWhereWithAggregatesInput[]
    OR?: team_playerScalarWhereWithAggregatesInput[]
    NOT?: team_playerScalarWhereWithAggregatesInput | team_playerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"team_player"> | number
    team_id?: IntWithAggregatesFilter<"team_player"> | number
    player_id?: IntWithAggregatesFilter<"team_player"> | number
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    description?: StringFilter<"product"> | string
    price?: FloatFilter<"product"> | number
    userid?: IntFilter<"product"> | number
    createdat?: DateTimeFilter<"product"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    orders?: OrderListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
    orders?: orderOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    name?: StringFilter<"product"> | string
    description?: StringFilter<"product"> | string
    price?: FloatFilter<"product"> | number
    userid?: IntFilter<"product"> | number
    createdat?: DateTimeFilter<"product"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    orders?: OrderListRelationFilter
  }, "id">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product"> | number
    name?: StringWithAggregatesFilter<"product"> | string
    description?: StringWithAggregatesFilter<"product"> | string
    price?: FloatWithAggregatesFilter<"product"> | number
    userid?: IntWithAggregatesFilter<"product"> | number
    createdat?: DateTimeWithAggregatesFilter<"product"> | Date | string
  }

  export type orderWhereInput = {
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    id?: IntFilter<"order"> | number
    productid?: IntFilter<"order"> | number
    userid?: IntFilter<"order"> | number
    quantity?: IntFilter<"order"> | number
    total?: FloatFilter<"order"> | number
    createdat?: DateTimeFilter<"order"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type orderOrderByWithRelationInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdat?: SortOrder
    product?: productOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type orderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    productid?: IntFilter<"order"> | number
    userid?: IntFilter<"order"> | number
    quantity?: IntFilter<"order"> | number
    total?: FloatFilter<"order"> | number
    createdat?: DateTimeFilter<"order"> | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type orderOrderByWithAggregationInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdat?: SortOrder
    _count?: orderCountOrderByAggregateInput
    _avg?: orderAvgOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
    _sum?: orderSumOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    OR?: orderScalarWhereWithAggregatesInput[]
    NOT?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order"> | number
    productid?: IntWithAggregatesFilter<"order"> | number
    userid?: IntWithAggregatesFilter<"order"> | number
    quantity?: IntWithAggregatesFilter<"order"> | number
    total?: FloatWithAggregatesFilter<"order"> | number
    createdat?: DateTimeWithAggregatesFilter<"order"> | Date | string
  }

  export type walletWhereInput = {
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    id?: IntFilter<"wallet"> | number
    balance?: FloatFilter<"wallet"> | number
    userid?: IntFilter<"wallet"> | number
    createdat?: DateTimeFilter<"wallet"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    walletmovement?: WalletmovementListRelationFilter
  }

  export type walletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
    walletmovement?: walletmovementOrderByRelationAggregateInput
  }

  export type walletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userid?: number
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    balance?: FloatFilter<"wallet"> | number
    createdat?: DateTimeFilter<"wallet"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    walletmovement?: WalletmovementListRelationFilter
  }, "id" | "userid">

  export type walletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    _count?: walletCountOrderByAggregateInput
    _avg?: walletAvgOrderByAggregateInput
    _max?: walletMaxOrderByAggregateInput
    _min?: walletMinOrderByAggregateInput
    _sum?: walletSumOrderByAggregateInput
  }

  export type walletScalarWhereWithAggregatesInput = {
    AND?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    OR?: walletScalarWhereWithAggregatesInput[]
    NOT?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet"> | number
    balance?: FloatWithAggregatesFilter<"wallet"> | number
    userid?: IntWithAggregatesFilter<"wallet"> | number
    createdat?: DateTimeWithAggregatesFilter<"wallet"> | Date | string
  }

  export type walletmovementWhereInput = {
    AND?: walletmovementWhereInput | walletmovementWhereInput[]
    OR?: walletmovementWhereInput[]
    NOT?: walletmovementWhereInput | walletmovementWhereInput[]
    id?: IntFilter<"walletmovement"> | number
    walletid?: IntFilter<"walletmovement"> | number
    amount?: FloatFilter<"walletmovement"> | number
    movementtype?: EnummovementtypeFilter<"walletmovement"> | movementtype
    createdat?: DateTimeFilter<"walletmovement"> | Date | string
    wallet?: XOR<WalletRelationFilter, walletWhereInput>
  }

  export type walletmovementOrderByWithRelationInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
    movementtype?: SortOrder
    createdat?: SortOrder
    wallet?: walletOrderByWithRelationInput
  }

  export type walletmovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: walletmovementWhereInput | walletmovementWhereInput[]
    OR?: walletmovementWhereInput[]
    NOT?: walletmovementWhereInput | walletmovementWhereInput[]
    walletid?: IntFilter<"walletmovement"> | number
    amount?: FloatFilter<"walletmovement"> | number
    movementtype?: EnummovementtypeFilter<"walletmovement"> | movementtype
    createdat?: DateTimeFilter<"walletmovement"> | Date | string
    wallet?: XOR<WalletRelationFilter, walletWhereInput>
  }, "id">

  export type walletmovementOrderByWithAggregationInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
    movementtype?: SortOrder
    createdat?: SortOrder
    _count?: walletmovementCountOrderByAggregateInput
    _avg?: walletmovementAvgOrderByAggregateInput
    _max?: walletmovementMaxOrderByAggregateInput
    _min?: walletmovementMinOrderByAggregateInput
    _sum?: walletmovementSumOrderByAggregateInput
  }

  export type walletmovementScalarWhereWithAggregatesInput = {
    AND?: walletmovementScalarWhereWithAggregatesInput | walletmovementScalarWhereWithAggregatesInput[]
    OR?: walletmovementScalarWhereWithAggregatesInput[]
    NOT?: walletmovementScalarWhereWithAggregatesInput | walletmovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"walletmovement"> | number
    walletid?: IntWithAggregatesFilter<"walletmovement"> | number
    amount?: FloatWithAggregatesFilter<"walletmovement"> | number
    movementtype?: EnummovementtypeWithAggregatesFilter<"walletmovement"> | movementtype
    createdat?: DateTimeWithAggregatesFilter<"walletmovement"> | Date | string
  }

  export type leaguesWhereInput = {
    AND?: leaguesWhereInput | leaguesWhereInput[]
    OR?: leaguesWhereInput[]
    NOT?: leaguesWhereInput | leaguesWhereInput[]
    id?: IntFilter<"leagues"> | number
    name?: StringFilter<"leagues"> | string
    cup?: EnumtypecupFilter<"leagues"> | typecup
    country?: StringFilter<"leagues"> | string
    code?: StringFilter<"leagues"> | string
    flag?: StringFilter<"leagues"> | string
    league_teams?: League_teamsListRelationFilter
  }

  export type leaguesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cup?: SortOrder
    country?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    league_teams?: league_teamsOrderByRelationAggregateInput
  }

  export type leaguesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: leaguesWhereInput | leaguesWhereInput[]
    OR?: leaguesWhereInput[]
    NOT?: leaguesWhereInput | leaguesWhereInput[]
    name?: StringFilter<"leagues"> | string
    cup?: EnumtypecupFilter<"leagues"> | typecup
    country?: StringFilter<"leagues"> | string
    code?: StringFilter<"leagues"> | string
    flag?: StringFilter<"leagues"> | string
    league_teams?: League_teamsListRelationFilter
  }, "id">

  export type leaguesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cup?: SortOrder
    country?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    _count?: leaguesCountOrderByAggregateInput
    _avg?: leaguesAvgOrderByAggregateInput
    _max?: leaguesMaxOrderByAggregateInput
    _min?: leaguesMinOrderByAggregateInput
    _sum?: leaguesSumOrderByAggregateInput
  }

  export type leaguesScalarWhereWithAggregatesInput = {
    AND?: leaguesScalarWhereWithAggregatesInput | leaguesScalarWhereWithAggregatesInput[]
    OR?: leaguesScalarWhereWithAggregatesInput[]
    NOT?: leaguesScalarWhereWithAggregatesInput | leaguesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"leagues"> | number
    name?: StringWithAggregatesFilter<"leagues"> | string
    cup?: EnumtypecupWithAggregatesFilter<"leagues"> | typecup
    country?: StringWithAggregatesFilter<"leagues"> | string
    code?: StringWithAggregatesFilter<"leagues"> | string
    flag?: StringWithAggregatesFilter<"leagues"> | string
  }

  export type league_teamsWhereInput = {
    AND?: league_teamsWhereInput | league_teamsWhereInput[]
    OR?: league_teamsWhereInput[]
    NOT?: league_teamsWhereInput | league_teamsWhereInput[]
    id?: IntFilter<"league_teams"> | number
    league_id?: IntFilter<"league_teams"> | number
    team_id?: IntFilter<"league_teams"> | number
    leagues?: XOR<LeaguesRelationFilter, leaguesWhereInput>
    teamid?: XOR<TeamRelationFilter, teamWhereInput>
    statistics_team?: Statistics_teamListRelationFilter
  }

  export type league_teamsOrderByWithRelationInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
    leagues?: leaguesOrderByWithRelationInput
    teamid?: teamOrderByWithRelationInput
    statistics_team?: statistics_teamOrderByRelationAggregateInput
  }

  export type league_teamsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    league_id_team_id?: league_teamsLeague_idTeam_idCompoundUniqueInput
    AND?: league_teamsWhereInput | league_teamsWhereInput[]
    OR?: league_teamsWhereInput[]
    NOT?: league_teamsWhereInput | league_teamsWhereInput[]
    league_id?: IntFilter<"league_teams"> | number
    team_id?: IntFilter<"league_teams"> | number
    leagues?: XOR<LeaguesRelationFilter, leaguesWhereInput>
    teamid?: XOR<TeamRelationFilter, teamWhereInput>
    statistics_team?: Statistics_teamListRelationFilter
  }, "id" | "league_id_team_id">

  export type league_teamsOrderByWithAggregationInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
    _count?: league_teamsCountOrderByAggregateInput
    _avg?: league_teamsAvgOrderByAggregateInput
    _max?: league_teamsMaxOrderByAggregateInput
    _min?: league_teamsMinOrderByAggregateInput
    _sum?: league_teamsSumOrderByAggregateInput
  }

  export type league_teamsScalarWhereWithAggregatesInput = {
    AND?: league_teamsScalarWhereWithAggregatesInput | league_teamsScalarWhereWithAggregatesInput[]
    OR?: league_teamsScalarWhereWithAggregatesInput[]
    NOT?: league_teamsScalarWhereWithAggregatesInput | league_teamsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"league_teams"> | number
    league_id?: IntWithAggregatesFilter<"league_teams"> | number
    team_id?: IntWithAggregatesFilter<"league_teams"> | number
  }

  export type countryWhereInput = {
    AND?: countryWhereInput | countryWhereInput[]
    OR?: countryWhereInput[]
    NOT?: countryWhereInput | countryWhereInput[]
    name?: StringFilter<"country"> | string
    code?: StringFilter<"country"> | string
    flag?: StringFilter<"country"> | string
  }

  export type countryOrderByWithRelationInput = {
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type countryWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: countryWhereInput | countryWhereInput[]
    OR?: countryWhereInput[]
    NOT?: countryWhereInput | countryWhereInput[]
    code?: StringFilter<"country"> | string
    flag?: StringFilter<"country"> | string
  }, "name">

  export type countryOrderByWithAggregationInput = {
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
    _count?: countryCountOrderByAggregateInput
    _max?: countryMaxOrderByAggregateInput
    _min?: countryMinOrderByAggregateInput
  }

  export type countryScalarWhereWithAggregatesInput = {
    AND?: countryScalarWhereWithAggregatesInput | countryScalarWhereWithAggregatesInput[]
    OR?: countryScalarWhereWithAggregatesInput[]
    NOT?: countryScalarWhereWithAggregatesInput | countryScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"country"> | string
    code?: StringWithAggregatesFilter<"country"> | string
    flag?: StringWithAggregatesFilter<"country"> | string
  }

  export type teamWhereInput = {
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    id?: IntFilter<"team"> | number
    name?: StringFilter<"team"> | string
    code?: StringFilter<"team"> | string
    founded?: IntFilter<"team"> | number
    national?: BoolFilter<"team"> | boolean
    logo?: StringFilter<"team"> | string
    venues?: JsonFilter<"team">
    league_teams?: League_teamsListRelationFilter
    player_team?: Team_playerListRelationFilter
  }

  export type teamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    founded?: SortOrder
    national?: SortOrder
    logo?: SortOrder
    venues?: SortOrder
    league_teams?: league_teamsOrderByRelationAggregateInput
    player_team?: team_playerOrderByRelationAggregateInput
  }

  export type teamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    name?: StringFilter<"team"> | string
    code?: StringFilter<"team"> | string
    founded?: IntFilter<"team"> | number
    national?: BoolFilter<"team"> | boolean
    logo?: StringFilter<"team"> | string
    venues?: JsonFilter<"team">
    league_teams?: League_teamsListRelationFilter
    player_team?: Team_playerListRelationFilter
  }, "id">

  export type teamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    founded?: SortOrder
    national?: SortOrder
    logo?: SortOrder
    venues?: SortOrder
    _count?: teamCountOrderByAggregateInput
    _avg?: teamAvgOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
    _sum?: teamSumOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    OR?: teamScalarWhereWithAggregatesInput[]
    NOT?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"team"> | number
    name?: StringWithAggregatesFilter<"team"> | string
    code?: StringWithAggregatesFilter<"team"> | string
    founded?: IntWithAggregatesFilter<"team"> | number
    national?: BoolWithAggregatesFilter<"team"> | boolean
    logo?: StringWithAggregatesFilter<"team"> | string
    venues?: JsonWithAggregatesFilter<"team">
  }

  export type leadWhereInput = {
    AND?: leadWhereInput | leadWhereInput[]
    OR?: leadWhereInput[]
    NOT?: leadWhereInput | leadWhereInput[]
    id?: IntFilter<"lead"> | number
    firstname?: StringFilter<"lead"> | string
    lastname?: StringFilter<"lead"> | string
    email?: StringFilter<"lead"> | string
    phone?: StringNullableFilter<"lead"> | string | null
    description?: StringFilter<"lead"> | string
    createdat?: DateTimeFilter<"lead"> | Date | string
  }

  export type leadOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    description?: SortOrder
    createdat?: SortOrder
  }

  export type leadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: leadWhereInput | leadWhereInput[]
    OR?: leadWhereInput[]
    NOT?: leadWhereInput | leadWhereInput[]
    firstname?: StringFilter<"lead"> | string
    lastname?: StringFilter<"lead"> | string
    email?: StringFilter<"lead"> | string
    phone?: StringNullableFilter<"lead"> | string | null
    description?: StringFilter<"lead"> | string
    createdat?: DateTimeFilter<"lead"> | Date | string
  }, "id">

  export type leadOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    description?: SortOrder
    createdat?: SortOrder
    _count?: leadCountOrderByAggregateInput
    _avg?: leadAvgOrderByAggregateInput
    _max?: leadMaxOrderByAggregateInput
    _min?: leadMinOrderByAggregateInput
    _sum?: leadSumOrderByAggregateInput
  }

  export type leadScalarWhereWithAggregatesInput = {
    AND?: leadScalarWhereWithAggregatesInput | leadScalarWhereWithAggregatesInput[]
    OR?: leadScalarWhereWithAggregatesInput[]
    NOT?: leadScalarWhereWithAggregatesInput | leadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lead"> | number
    firstname?: StringWithAggregatesFilter<"lead"> | string
    lastname?: StringWithAggregatesFilter<"lead"> | string
    email?: StringWithAggregatesFilter<"lead"> | string
    phone?: StringNullableWithAggregatesFilter<"lead"> | string | null
    description?: StringWithAggregatesFilter<"lead"> | string
    createdat?: DateTimeWithAggregatesFilter<"lead"> | Date | string
  }

  export type passwordhashWhereInput = {
    AND?: passwordhashWhereInput | passwordhashWhereInput[]
    OR?: passwordhashWhereInput[]
    NOT?: passwordhashWhereInput | passwordhashWhereInput[]
    id?: IntFilter<"passwordhash"> | number
    userid?: IntFilter<"passwordhash"> | number
    hash?: StringFilter<"passwordhash"> | string
    salt?: StringFilter<"passwordhash"> | string
    createdat?: DateTimeFilter<"passwordhash"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type passwordhashOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
    salt?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type passwordhashWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userid?: number
    AND?: passwordhashWhereInput | passwordhashWhereInput[]
    OR?: passwordhashWhereInput[]
    NOT?: passwordhashWhereInput | passwordhashWhereInput[]
    hash?: StringFilter<"passwordhash"> | string
    salt?: StringFilter<"passwordhash"> | string
    createdat?: DateTimeFilter<"passwordhash"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "userid">

  export type passwordhashOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
    salt?: SortOrder
    createdat?: SortOrder
    _count?: passwordhashCountOrderByAggregateInput
    _avg?: passwordhashAvgOrderByAggregateInput
    _max?: passwordhashMaxOrderByAggregateInput
    _min?: passwordhashMinOrderByAggregateInput
    _sum?: passwordhashSumOrderByAggregateInput
  }

  export type passwordhashScalarWhereWithAggregatesInput = {
    AND?: passwordhashScalarWhereWithAggregatesInput | passwordhashScalarWhereWithAggregatesInput[]
    OR?: passwordhashScalarWhereWithAggregatesInput[]
    NOT?: passwordhashScalarWhereWithAggregatesInput | passwordhashScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"passwordhash"> | number
    userid?: IntWithAggregatesFilter<"passwordhash"> | number
    hash?: StringWithAggregatesFilter<"passwordhash"> | string
    salt?: StringWithAggregatesFilter<"passwordhash"> | string
    createdat?: DateTimeWithAggregatesFilter<"passwordhash"> | Date | string
  }

  export type permissionlogWhereInput = {
    AND?: permissionlogWhereInput | permissionlogWhereInput[]
    OR?: permissionlogWhereInput[]
    NOT?: permissionlogWhereInput | permissionlogWhereInput[]
    id?: IntFilter<"permissionlog"> | number
    permissionid?: IntFilter<"permissionlog"> | number
    action?: StringFilter<"permissionlog"> | string
    createdat?: DateTimeFilter<"permissionlog"> | Date | string
    permision?: XOR<PermissionRelationFilter, permissionWhereInput>
  }

  export type permissionlogOrderByWithRelationInput = {
    id?: SortOrder
    permissionid?: SortOrder
    action?: SortOrder
    createdat?: SortOrder
    permision?: permissionOrderByWithRelationInput
  }

  export type permissionlogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: permissionlogWhereInput | permissionlogWhereInput[]
    OR?: permissionlogWhereInput[]
    NOT?: permissionlogWhereInput | permissionlogWhereInput[]
    permissionid?: IntFilter<"permissionlog"> | number
    action?: StringFilter<"permissionlog"> | string
    createdat?: DateTimeFilter<"permissionlog"> | Date | string
    permision?: XOR<PermissionRelationFilter, permissionWhereInput>
  }, "id">

  export type permissionlogOrderByWithAggregationInput = {
    id?: SortOrder
    permissionid?: SortOrder
    action?: SortOrder
    createdat?: SortOrder
    _count?: permissionlogCountOrderByAggregateInput
    _avg?: permissionlogAvgOrderByAggregateInput
    _max?: permissionlogMaxOrderByAggregateInput
    _min?: permissionlogMinOrderByAggregateInput
    _sum?: permissionlogSumOrderByAggregateInput
  }

  export type permissionlogScalarWhereWithAggregatesInput = {
    AND?: permissionlogScalarWhereWithAggregatesInput | permissionlogScalarWhereWithAggregatesInput[]
    OR?: permissionlogScalarWhereWithAggregatesInput[]
    NOT?: permissionlogScalarWhereWithAggregatesInput | permissionlogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"permissionlog"> | number
    permissionid?: IntWithAggregatesFilter<"permissionlog"> | number
    action?: StringWithAggregatesFilter<"permissionlog"> | string
    createdat?: DateTimeWithAggregatesFilter<"permissionlog"> | Date | string
  }

  export type userlogWhereInput = {
    AND?: userlogWhereInput | userlogWhereInput[]
    OR?: userlogWhereInput[]
    NOT?: userlogWhereInput | userlogWhereInput[]
    id?: IntFilter<"userlog"> | number
    userid?: IntFilter<"userlog"> | number
    action?: StringFilter<"userlog"> | string
    createat?: DateTimeFilter<"userlog"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type userlogOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    createat?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type userlogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userlogWhereInput | userlogWhereInput[]
    OR?: userlogWhereInput[]
    NOT?: userlogWhereInput | userlogWhereInput[]
    userid?: IntFilter<"userlog"> | number
    action?: StringFilter<"userlog"> | string
    createat?: DateTimeFilter<"userlog"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type userlogOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    createat?: SortOrder
    _count?: userlogCountOrderByAggregateInput
    _avg?: userlogAvgOrderByAggregateInput
    _max?: userlogMaxOrderByAggregateInput
    _min?: userlogMinOrderByAggregateInput
    _sum?: userlogSumOrderByAggregateInput
  }

  export type userlogScalarWhereWithAggregatesInput = {
    AND?: userlogScalarWhereWithAggregatesInput | userlogScalarWhereWithAggregatesInput[]
    OR?: userlogScalarWhereWithAggregatesInput[]
    NOT?: userlogScalarWhereWithAggregatesInput | userlogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userlog"> | number
    userid?: IntWithAggregatesFilter<"userlog"> | number
    action?: StringWithAggregatesFilter<"userlog"> | string
    createat?: DateTimeWithAggregatesFilter<"userlog"> | Date | string
  }

  export type permissionWhereInput = {
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    id?: IntFilter<"permission"> | number
    name?: StringFilter<"permission"> | string
    description?: StringFilter<"permission"> | string
    userid?: IntFilter<"permission"> | number
    createdat?: DateTimeFilter<"permission"> | Date | string
    permission?: XOR<UserRelationFilter, userWhereInput>
    permissionlog?: PermissionlogListRelationFilter
  }

  export type permissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    permission?: userOrderByWithRelationInput
    permissionlog?: permissionlogOrderByRelationAggregateInput
  }

  export type permissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    name?: StringFilter<"permission"> | string
    description?: StringFilter<"permission"> | string
    userid?: IntFilter<"permission"> | number
    createdat?: DateTimeFilter<"permission"> | Date | string
    permission?: XOR<UserRelationFilter, userWhereInput>
    permissionlog?: PermissionlogListRelationFilter
  }, "id">

  export type permissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    _count?: permissionCountOrderByAggregateInput
    _avg?: permissionAvgOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
    _sum?: permissionSumOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    OR?: permissionScalarWhereWithAggregatesInput[]
    NOT?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"permission"> | number
    name?: StringWithAggregatesFilter<"permission"> | string
    description?: StringWithAggregatesFilter<"permission"> | string
    userid?: IntWithAggregatesFilter<"permission"> | number
    createdat?: DateTimeWithAggregatesFilter<"permission"> | Date | string
  }

  export type users_profileWhereInput = {
    AND?: users_profileWhereInput | users_profileWhereInput[]
    OR?: users_profileWhereInput[]
    NOT?: users_profileWhereInput | users_profileWhereInput[]
    id?: IntFilter<"users_profile"> | number
    name?: StringFilter<"users_profile"> | string
    lastname?: StringFilter<"users_profile"> | string
    street?: StringFilter<"users_profile"> | string
    phone_number?: StringFilter<"users_profile"> | string
    number_address?: IntFilter<"users_profile"> | number
    neigh?: StringFilter<"users_profile"> | string
    userid?: IntFilter<"users_profile"> | number
    profile?: XOR<UserRelationFilter, userWhereInput>
  }

  export type users_profileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    street?: SortOrder
    phone_number?: SortOrder
    number_address?: SortOrder
    neigh?: SortOrder
    userid?: SortOrder
    profile?: userOrderByWithRelationInput
  }

  export type users_profileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: users_profileWhereInput | users_profileWhereInput[]
    OR?: users_profileWhereInput[]
    NOT?: users_profileWhereInput | users_profileWhereInput[]
    name?: StringFilter<"users_profile"> | string
    lastname?: StringFilter<"users_profile"> | string
    street?: StringFilter<"users_profile"> | string
    phone_number?: StringFilter<"users_profile"> | string
    number_address?: IntFilter<"users_profile"> | number
    neigh?: StringFilter<"users_profile"> | string
    userid?: IntFilter<"users_profile"> | number
    profile?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type users_profileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    street?: SortOrder
    phone_number?: SortOrder
    number_address?: SortOrder
    neigh?: SortOrder
    userid?: SortOrder
    _count?: users_profileCountOrderByAggregateInput
    _avg?: users_profileAvgOrderByAggregateInput
    _max?: users_profileMaxOrderByAggregateInput
    _min?: users_profileMinOrderByAggregateInput
    _sum?: users_profileSumOrderByAggregateInput
  }

  export type users_profileScalarWhereWithAggregatesInput = {
    AND?: users_profileScalarWhereWithAggregatesInput | users_profileScalarWhereWithAggregatesInput[]
    OR?: users_profileScalarWhereWithAggregatesInput[]
    NOT?: users_profileScalarWhereWithAggregatesInput | users_profileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users_profile"> | number
    name?: StringWithAggregatesFilter<"users_profile"> | string
    lastname?: StringWithAggregatesFilter<"users_profile"> | string
    street?: StringWithAggregatesFilter<"users_profile"> | string
    phone_number?: StringWithAggregatesFilter<"users_profile"> | string
    number_address?: IntWithAggregatesFilter<"users_profile"> | number
    neigh?: StringWithAggregatesFilter<"users_profile"> | string
    userid?: IntWithAggregatesFilter<"users_profile"> | number
  }

  export type cookieWhereInput = {
    AND?: cookieWhereInput | cookieWhereInput[]
    OR?: cookieWhereInput[]
    NOT?: cookieWhereInput | cookieWhereInput[]
    id?: IntFilter<"cookie"> | number
    value?: StringFilter<"cookie"> | string
    userid?: IntFilter<"cookie"> | number
    createdat?: DateTimeFilter<"cookie"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type cookieOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type cookieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: cookieWhereInput | cookieWhereInput[]
    OR?: cookieWhereInput[]
    NOT?: cookieWhereInput | cookieWhereInput[]
    userid?: IntFilter<"cookie"> | number
    createdat?: DateTimeFilter<"cookie"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "value">

  export type cookieOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    _count?: cookieCountOrderByAggregateInput
    _avg?: cookieAvgOrderByAggregateInput
    _max?: cookieMaxOrderByAggregateInput
    _min?: cookieMinOrderByAggregateInput
    _sum?: cookieSumOrderByAggregateInput
  }

  export type cookieScalarWhereWithAggregatesInput = {
    AND?: cookieScalarWhereWithAggregatesInput | cookieScalarWhereWithAggregatesInput[]
    OR?: cookieScalarWhereWithAggregatesInput[]
    NOT?: cookieScalarWhereWithAggregatesInput | cookieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cookie"> | number
    value?: StringWithAggregatesFilter<"cookie"> | string
    userid?: IntWithAggregatesFilter<"cookie"> | number
    createdat?: DateTimeWithAggregatesFilter<"cookie"> | Date | string
  }

  export type userCreateInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
  }

  export type userUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type statistics_teamCreateInput = {
    fixtures: JsonNullValueInput | InputJsonValue
    biggest: JsonNullValueInput | InputJsonValue
    goals: JsonNullValueInput | InputJsonValue
    clean_sheet: JsonNullValueInput | InputJsonValue
    failed_to_score: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
    lineups: JsonNullValueInput | InputJsonValue
    cards: JsonNullValueInput | InputJsonValue
    league_teamid: league_teamsCreateNestedOneWithoutStatistics_teamInput
  }

  export type statistics_teamUncheckedCreateInput = {
    league_team_id: number
    fixtures: JsonNullValueInput | InputJsonValue
    biggest: JsonNullValueInput | InputJsonValue
    goals: JsonNullValueInput | InputJsonValue
    clean_sheet: JsonNullValueInput | InputJsonValue
    failed_to_score: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
    lineups: JsonNullValueInput | InputJsonValue
    cards: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUpdateInput = {
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
    league_teamid?: league_teamsUpdateOneRequiredWithoutStatistics_teamNestedInput
  }

  export type statistics_teamUncheckedUpdateInput = {
    league_team_id?: IntFieldUpdateOperationsInput | number
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamCreateManyInput = {
    league_team_id: number
    fixtures: JsonNullValueInput | InputJsonValue
    biggest: JsonNullValueInput | InputJsonValue
    goals: JsonNullValueInput | InputJsonValue
    clean_sheet: JsonNullValueInput | InputJsonValue
    failed_to_score: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
    lineups: JsonNullValueInput | InputJsonValue
    cards: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUpdateManyMutationInput = {
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUncheckedUpdateManyInput = {
    league_team_id?: IntFieldUpdateOperationsInput | number
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundCreateInput = {
    round: string
    seasson: number
    league: JsonNullValueInput | InputJsonValue
    leagues_teams_id: number
    status: JsonNullValueInput | InputJsonValue
    venus: JsonNullValueInput | InputJsonValue
    date: Date | string
    goals: JsonNullValueInput | InputJsonValue
    score: JsonNullValueInput | InputJsonValue
    fulltime: JsonNullValueInput | InputJsonValue
    extratime: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundUncheckedCreateInput = {
    id?: number
    round: string
    seasson: number
    league: JsonNullValueInput | InputJsonValue
    leagues_teams_id: number
    status: JsonNullValueInput | InputJsonValue
    venus: JsonNullValueInput | InputJsonValue
    date: Date | string
    goals: JsonNullValueInput | InputJsonValue
    score: JsonNullValueInput | InputJsonValue
    fulltime: JsonNullValueInput | InputJsonValue
    extratime: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundUpdateInput = {
    round?: StringFieldUpdateOperationsInput | string
    seasson?: IntFieldUpdateOperationsInput | number
    league?: JsonNullValueInput | InputJsonValue
    leagues_teams_id?: IntFieldUpdateOperationsInput | number
    status?: JsonNullValueInput | InputJsonValue
    venus?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: JsonNullValueInput | InputJsonValue
    score?: JsonNullValueInput | InputJsonValue
    fulltime?: JsonNullValueInput | InputJsonValue
    extratime?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: StringFieldUpdateOperationsInput | string
    seasson?: IntFieldUpdateOperationsInput | number
    league?: JsonNullValueInput | InputJsonValue
    leagues_teams_id?: IntFieldUpdateOperationsInput | number
    status?: JsonNullValueInput | InputJsonValue
    venus?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: JsonNullValueInput | InputJsonValue
    score?: JsonNullValueInput | InputJsonValue
    fulltime?: JsonNullValueInput | InputJsonValue
    extratime?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundCreateManyInput = {
    id?: number
    round: string
    seasson: number
    league: JsonNullValueInput | InputJsonValue
    leagues_teams_id: number
    status: JsonNullValueInput | InputJsonValue
    venus: JsonNullValueInput | InputJsonValue
    date: Date | string
    goals: JsonNullValueInput | InputJsonValue
    score: JsonNullValueInput | InputJsonValue
    fulltime: JsonNullValueInput | InputJsonValue
    extratime: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundUpdateManyMutationInput = {
    round?: StringFieldUpdateOperationsInput | string
    seasson?: IntFieldUpdateOperationsInput | number
    league?: JsonNullValueInput | InputJsonValue
    leagues_teams_id?: IntFieldUpdateOperationsInput | number
    status?: JsonNullValueInput | InputJsonValue
    venus?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: JsonNullValueInput | InputJsonValue
    score?: JsonNullValueInput | InputJsonValue
    fulltime?: JsonNullValueInput | InputJsonValue
    extratime?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
  }

  export type fixture_roundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: StringFieldUpdateOperationsInput | string
    seasson?: IntFieldUpdateOperationsInput | number
    league?: JsonNullValueInput | InputJsonValue
    leagues_teams_id?: IntFieldUpdateOperationsInput | number
    status?: JsonNullValueInput | InputJsonValue
    venus?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: JsonNullValueInput | InputJsonValue
    score?: JsonNullValueInput | InputJsonValue
    fulltime?: JsonNullValueInput | InputJsonValue
    extratime?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
  }

  export type football_playersCreateInput = {
    name: string
    lastname: string
    age: number
    birth: JsonNullValueInput | InputJsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: JsonNullValueInput | InputJsonValue
    team_player?: team_playerCreateNestedManyWithoutPlayeridInput
  }

  export type football_playersUncheckedCreateInput = {
    id?: number
    name: string
    lastname: string
    age: number
    birth: JsonNullValueInput | InputJsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: JsonNullValueInput | InputJsonValue
    team_player?: team_playerUncheckedCreateNestedManyWithoutPlayeridInput
  }

  export type football_playersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    birth?: JsonNullValueInput | InputJsonValue
    nationality?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    injured?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    statistics?: JsonNullValueInput | InputJsonValue
    team_player?: team_playerUpdateManyWithoutPlayeridNestedInput
  }

  export type football_playersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    birth?: JsonNullValueInput | InputJsonValue
    nationality?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    injured?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    statistics?: JsonNullValueInput | InputJsonValue
    team_player?: team_playerUncheckedUpdateManyWithoutPlayeridNestedInput
  }

  export type football_playersCreateManyInput = {
    id?: number
    name: string
    lastname: string
    age: number
    birth: JsonNullValueInput | InputJsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: JsonNullValueInput | InputJsonValue
  }

  export type football_playersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    birth?: JsonNullValueInput | InputJsonValue
    nationality?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    injured?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    statistics?: JsonNullValueInput | InputJsonValue
  }

  export type football_playersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    birth?: JsonNullValueInput | InputJsonValue
    nationality?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    injured?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    statistics?: JsonNullValueInput | InputJsonValue
  }

  export type team_playerCreateInput = {
    teamid: teamCreateNestedOneWithoutPlayer_teamInput
    playerid: football_playersCreateNestedOneWithoutTeam_playerInput
  }

  export type team_playerUncheckedCreateInput = {
    id?: number
    team_id: number
    player_id: number
  }

  export type team_playerUpdateInput = {
    teamid?: teamUpdateOneRequiredWithoutPlayer_teamNestedInput
    playerid?: football_playersUpdateOneRequiredWithoutTeam_playerNestedInput
  }

  export type team_playerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type team_playerCreateManyInput = {
    id?: number
    team_id: number
    player_id: number
  }

  export type team_playerUpdateManyMutationInput = {

  }

  export type team_playerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type productCreateInput = {
    name: string
    description: string
    price: number
    createdat?: Date | string
    user: userCreateNestedOneWithoutProductInput
    orders?: orderCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    price: number
    userid: number
    createdat?: Date | string
    orders?: orderUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutProductNestedInput
    orders?: orderUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: orderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: number
    name: string
    description: string
    price: number
    userid: number
    createdat?: Date | string
  }

  export type productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateInput = {
    quantity: number
    total: number
    createdat?: Date | string
    product: productCreateNestedOneWithoutOrdersInput
    user: userCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateInput = {
    id?: number
    productid: number
    userid: number
    quantity: number
    total: number
    createdat?: Date | string
  }

  export type orderUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutOrdersNestedInput
    user?: userUpdateOneRequiredWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productid?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateManyInput = {
    id?: number
    productid: number
    userid: number
    quantity: number
    total: number
    createdat?: Date | string
  }

  export type orderUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productid?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletCreateInput = {
    balance?: number
    createdat?: Date | string
    user: userCreateNestedOneWithoutWalletInput
    walletmovement?: walletmovementCreateNestedManyWithoutWalletInput
  }

  export type walletUncheckedCreateInput = {
    id?: number
    balance?: number
    userid: number
    createdat?: Date | string
    walletmovement?: walletmovementUncheckedCreateNestedManyWithoutWalletInput
  }

  export type walletUpdateInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutWalletNestedInput
    walletmovement?: walletmovementUpdateManyWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    walletmovement?: walletmovementUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type walletCreateManyInput = {
    id?: number
    balance?: number
    userid: number
    createdat?: Date | string
  }

  export type walletUpdateManyMutationInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletmovementCreateInput = {
    amount: number
    movementtype: movementtype
    createdat?: Date | string
    wallet: walletCreateNestedOneWithoutWalletmovementInput
  }

  export type walletmovementUncheckedCreateInput = {
    id?: number
    walletid: number
    amount: number
    movementtype: movementtype
    createdat?: Date | string
  }

  export type walletmovementUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: walletUpdateOneRequiredWithoutWalletmovementNestedInput
  }

  export type walletmovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletid?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletmovementCreateManyInput = {
    id?: number
    walletid: number
    amount: number
    movementtype: movementtype
    createdat?: Date | string
  }

  export type walletmovementUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletmovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletid?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaguesCreateInput = {
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
    league_teams?: league_teamsCreateNestedManyWithoutLeaguesInput
  }

  export type leaguesUncheckedCreateInput = {
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
    league_teams?: league_teamsUncheckedCreateNestedManyWithoutLeaguesInput
  }

  export type leaguesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cup?: EnumtypecupFieldUpdateOperationsInput | typecup
    country?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    league_teams?: league_teamsUpdateManyWithoutLeaguesNestedInput
  }

  export type leaguesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cup?: EnumtypecupFieldUpdateOperationsInput | typecup
    country?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
    league_teams?: league_teamsUncheckedUpdateManyWithoutLeaguesNestedInput
  }

  export type leaguesCreateManyInput = {
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
  }

  export type leaguesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cup?: EnumtypecupFieldUpdateOperationsInput | typecup
    country?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type leaguesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cup?: EnumtypecupFieldUpdateOperationsInput | typecup
    country?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type league_teamsCreateInput = {
    leagues: leaguesCreateNestedOneWithoutLeague_teamsInput
    teamid: teamCreateNestedOneWithoutLeague_teamsInput
    statistics_team?: statistics_teamCreateNestedManyWithoutLeague_teamidInput
  }

  export type league_teamsUncheckedCreateInput = {
    id?: number
    league_id: number
    team_id: number
    statistics_team?: statistics_teamUncheckedCreateNestedManyWithoutLeague_teamidInput
  }

  export type league_teamsUpdateInput = {
    leagues?: leaguesUpdateOneRequiredWithoutLeague_teamsNestedInput
    teamid?: teamUpdateOneRequiredWithoutLeague_teamsNestedInput
    statistics_team?: statistics_teamUpdateManyWithoutLeague_teamidNestedInput
  }

  export type league_teamsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    league_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    statistics_team?: statistics_teamUncheckedUpdateManyWithoutLeague_teamidNestedInput
  }

  export type league_teamsCreateManyInput = {
    id?: number
    league_id: number
    team_id: number
  }

  export type league_teamsUpdateManyMutationInput = {

  }

  export type league_teamsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    league_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
  }

  export type countryCreateInput = {
    name: string
    code: string
    flag: string
  }

  export type countryUncheckedCreateInput = {
    name: string
    code: string
    flag: string
  }

  export type countryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type countryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type countryCreateManyInput = {
    name: string
    code: string
    flag: string
  }

  export type countryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type countryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type teamCreateInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsCreateNestedManyWithoutTeamidInput
    player_team?: team_playerCreateNestedManyWithoutTeamidInput
  }

  export type teamUncheckedCreateInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsUncheckedCreateNestedManyWithoutTeamidInput
    player_team?: team_playerUncheckedCreateNestedManyWithoutTeamidInput
  }

  export type teamUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsUpdateManyWithoutTeamidNestedInput
    player_team?: team_playerUpdateManyWithoutTeamidNestedInput
  }

  export type teamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsUncheckedUpdateManyWithoutTeamidNestedInput
    player_team?: team_playerUncheckedUpdateManyWithoutTeamidNestedInput
  }

  export type teamCreateManyInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
  }

  export type teamUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
  }

  export type teamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
  }

  export type leadCreateInput = {
    firstname: string
    lastname: string
    email: string
    phone?: string | null
    description: string
    createdat?: Date | string
  }

  export type leadUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    phone?: string | null
    description: string
    createdat?: Date | string
  }

  export type leadUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leadCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    phone?: string | null
    description: string
    createdat?: Date | string
  }

  export type leadUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type passwordhashCreateInput = {
    hash: string
    salt: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutPasswordhashInput
  }

  export type passwordhashUncheckedCreateInput = {
    id?: number
    userid: number
    hash: string
    salt: string
    createdat?: Date | string
  }

  export type passwordhashUpdateInput = {
    hash?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutPasswordhashNestedInput
  }

  export type passwordhashUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type passwordhashCreateManyInput = {
    id?: number
    userid: number
    hash: string
    salt: string
    createdat?: Date | string
  }

  export type passwordhashUpdateManyMutationInput = {
    hash?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type passwordhashUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionlogCreateInput = {
    action: string
    createdat?: Date | string
    permision: permissionCreateNestedOneWithoutPermissionlogInput
  }

  export type permissionlogUncheckedCreateInput = {
    id?: number
    permissionid: number
    action: string
    createdat?: Date | string
  }

  export type permissionlogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    permision?: permissionUpdateOneRequiredWithoutPermissionlogNestedInput
  }

  export type permissionlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionid?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionlogCreateManyInput = {
    id?: number
    permissionid: number
    action: string
    createdat?: Date | string
  }

  export type permissionlogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionid?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userlogCreateInput = {
    action: string
    createat?: Date | string
    user: userCreateNestedOneWithoutUserlogInput
  }

  export type userlogUncheckedCreateInput = {
    id?: number
    userid: number
    action: string
    createat?: Date | string
  }

  export type userlogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUserlogNestedInput
  }

  export type userlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userlogCreateManyInput = {
    id?: number
    userid: number
    action: string
    createat?: Date | string
  }

  export type userlogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionCreateInput = {
    name: string
    description: string
    createdat?: Date | string
    permission: userCreateNestedOneWithoutPermissionInput
    permissionlog?: permissionlogCreateNestedManyWithoutPermisionInput
  }

  export type permissionUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    userid: number
    createdat?: Date | string
    permissionlog?: permissionlogUncheckedCreateNestedManyWithoutPermisionInput
  }

  export type permissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: userUpdateOneRequiredWithoutPermissionNestedInput
    permissionlog?: permissionlogUpdateManyWithoutPermisionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionlog?: permissionlogUncheckedUpdateManyWithoutPermisionNestedInput
  }

  export type permissionCreateManyInput = {
    id?: number
    name: string
    description: string
    userid: number
    createdat?: Date | string
  }

  export type permissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_profileCreateInput = {
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
    profile: userCreateNestedOneWithoutProfileInput
  }

  export type users_profileUncheckedCreateInput = {
    id?: number
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
    userid: number
  }

  export type users_profileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
    profile?: userUpdateOneRequiredWithoutProfileNestedInput
  }

  export type users_profileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type users_profileCreateManyInput = {
    id?: number
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
    userid: number
  }

  export type users_profileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
  }

  export type users_profileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type cookieCreateInput = {
    value: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutCookiesInput
  }

  export type cookieUncheckedCreateInput = {
    id?: number
    value: string
    userid: number
    createdat?: Date | string
  }

  export type cookieUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutCookiesNestedInput
  }

  export type cookieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cookieCreateManyInput = {
    id?: number
    value: string
    userid: number
    createdat?: Date | string
  }

  export type cookieUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cookieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumusecaseFilter<$PrismaModel = never> = {
    equals?: usecase | EnumusecaseFieldRefInput<$PrismaModel>
    in?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    notIn?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    not?: NestedEnumusecaseFilter<$PrismaModel> | usecase
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PasswordhashNullableRelationFilter = {
    is?: passwordhashWhereInput | null
    isNot?: passwordhashWhereInput | null
  }

  export type CookieListRelationFilter = {
    every?: cookieWhereInput
    some?: cookieWhereInput
    none?: cookieWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: permissionWhereInput
    some?: permissionWhereInput
    none?: permissionWhereInput
  }

  export type UserlogListRelationFilter = {
    every?: userlogWhereInput
    some?: userlogWhereInput
    none?: userlogWhereInput
  }

  export type WalletNullableRelationFilter = {
    is?: walletWhereInput | null
    isNot?: walletWhereInput | null
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type OrderListRelationFilter = {
    every?: orderWhereInput
    some?: orderWhereInput
    none?: orderWhereInput
  }

  export type Users_profileListRelationFilter = {
    every?: users_profileWhereInput
    some?: users_profileWhereInput
    none?: users_profileWhereInput
  }

  export type cookieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type users_profileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    usecase?: SortOrder
    createdat?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    usecase?: SortOrder
    createdat?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    usecase?: SortOrder
    createdat?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumusecaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: usecase | EnumusecaseFieldRefInput<$PrismaModel>
    in?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    notIn?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    not?: NestedEnumusecaseWithAggregatesFilter<$PrismaModel> | usecase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusecaseFilter<$PrismaModel>
    _max?: NestedEnumusecaseFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type League_teamsRelationFilter = {
    is?: league_teamsWhereInput
    isNot?: league_teamsWhereInput
  }

  export type statistics_teamCountOrderByAggregateInput = {
    league_team_id?: SortOrder
    fixtures?: SortOrder
    biggest?: SortOrder
    goals?: SortOrder
    clean_sheet?: SortOrder
    failed_to_score?: SortOrder
    penalty?: SortOrder
    lineups?: SortOrder
    cards?: SortOrder
  }

  export type statistics_teamAvgOrderByAggregateInput = {
    league_team_id?: SortOrder
  }

  export type statistics_teamMaxOrderByAggregateInput = {
    league_team_id?: SortOrder
  }

  export type statistics_teamMinOrderByAggregateInput = {
    league_team_id?: SortOrder
  }

  export type statistics_teamSumOrderByAggregateInput = {
    league_team_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type fixture_roundCountOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    seasson?: SortOrder
    league?: SortOrder
    leagues_teams_id?: SortOrder
    status?: SortOrder
    venus?: SortOrder
    date?: SortOrder
    goals?: SortOrder
    score?: SortOrder
    fulltime?: SortOrder
    extratime?: SortOrder
    penalty?: SortOrder
  }

  export type fixture_roundAvgOrderByAggregateInput = {
    id?: SortOrder
    seasson?: SortOrder
    leagues_teams_id?: SortOrder
  }

  export type fixture_roundMaxOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    seasson?: SortOrder
    leagues_teams_id?: SortOrder
    date?: SortOrder
  }

  export type fixture_roundMinOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    seasson?: SortOrder
    leagues_teams_id?: SortOrder
    date?: SortOrder
  }

  export type fixture_roundSumOrderByAggregateInput = {
    id?: SortOrder
    seasson?: SortOrder
    leagues_teams_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Team_playerListRelationFilter = {
    every?: team_playerWhereInput
    some?: team_playerWhereInput
    none?: team_playerWhereInput
  }

  export type team_playerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type football_playersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    age?: SortOrder
    birth?: SortOrder
    nationality?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    injured?: SortOrder
    photo?: SortOrder
    statistics?: SortOrder
  }

  export type football_playersAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type football_playersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    age?: SortOrder
    nationality?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    injured?: SortOrder
    photo?: SortOrder
  }

  export type football_playersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    age?: SortOrder
    nationality?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    injured?: SortOrder
    photo?: SortOrder
  }

  export type football_playersSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TeamRelationFilter = {
    is?: teamWhereInput
    isNot?: teamWhereInput
  }

  export type Football_playersRelationFilter = {
    is?: football_playersWhereInput
    isNot?: football_playersWhereInput
  }

  export type team_playerTeam_idPlayer_idCompoundUniqueInput = {
    team_id: number
    player_id: number
  }

  export type team_playerCountOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type team_playerAvgOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type team_playerMaxOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type team_playerMinOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type team_playerSumOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    userid?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    userid?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProductRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type orderCountOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdat?: SortOrder
  }

  export type orderAvgOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdat?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    createdat?: SortOrder
  }

  export type orderSumOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    userid?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
  }

  export type WalletmovementListRelationFilter = {
    every?: walletmovementWhereInput
    some?: walletmovementWhereInput
    none?: walletmovementWhereInput
  }

  export type walletmovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type walletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type walletAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
  }

  export type walletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type walletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type walletSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userid?: SortOrder
  }

  export type EnummovementtypeFilter<$PrismaModel = never> = {
    equals?: movementtype | EnummovementtypeFieldRefInput<$PrismaModel>
    in?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    notIn?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    not?: NestedEnummovementtypeFilter<$PrismaModel> | movementtype
  }

  export type WalletRelationFilter = {
    is?: walletWhereInput
    isNot?: walletWhereInput
  }

  export type walletmovementCountOrderByAggregateInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
    movementtype?: SortOrder
    createdat?: SortOrder
  }

  export type walletmovementAvgOrderByAggregateInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
  }

  export type walletmovementMaxOrderByAggregateInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
    movementtype?: SortOrder
    createdat?: SortOrder
  }

  export type walletmovementMinOrderByAggregateInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
    movementtype?: SortOrder
    createdat?: SortOrder
  }

  export type walletmovementSumOrderByAggregateInput = {
    id?: SortOrder
    walletid?: SortOrder
    amount?: SortOrder
  }

  export type EnummovementtypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: movementtype | EnummovementtypeFieldRefInput<$PrismaModel>
    in?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    notIn?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    not?: NestedEnummovementtypeWithAggregatesFilter<$PrismaModel> | movementtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummovementtypeFilter<$PrismaModel>
    _max?: NestedEnummovementtypeFilter<$PrismaModel>
  }

  export type EnumtypecupFilter<$PrismaModel = never> = {
    equals?: typecup | EnumtypecupFieldRefInput<$PrismaModel>
    in?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    notIn?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    not?: NestedEnumtypecupFilter<$PrismaModel> | typecup
  }

  export type League_teamsListRelationFilter = {
    every?: league_teamsWhereInput
    some?: league_teamsWhereInput
    none?: league_teamsWhereInput
  }

  export type league_teamsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type leaguesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cup?: SortOrder
    country?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type leaguesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type leaguesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cup?: SortOrder
    country?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type leaguesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cup?: SortOrder
    country?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type leaguesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumtypecupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: typecup | EnumtypecupFieldRefInput<$PrismaModel>
    in?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    notIn?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    not?: NestedEnumtypecupWithAggregatesFilter<$PrismaModel> | typecup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtypecupFilter<$PrismaModel>
    _max?: NestedEnumtypecupFilter<$PrismaModel>
  }

  export type LeaguesRelationFilter = {
    is?: leaguesWhereInput
    isNot?: leaguesWhereInput
  }

  export type Statistics_teamListRelationFilter = {
    every?: statistics_teamWhereInput
    some?: statistics_teamWhereInput
    none?: statistics_teamWhereInput
  }

  export type statistics_teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type league_teamsLeague_idTeam_idCompoundUniqueInput = {
    league_id: number
    team_id: number
  }

  export type league_teamsCountOrderByAggregateInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
  }

  export type league_teamsAvgOrderByAggregateInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
  }

  export type league_teamsMaxOrderByAggregateInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
  }

  export type league_teamsMinOrderByAggregateInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
  }

  export type league_teamsSumOrderByAggregateInput = {
    id?: SortOrder
    league_id?: SortOrder
    team_id?: SortOrder
  }

  export type countryCountOrderByAggregateInput = {
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type countryMaxOrderByAggregateInput = {
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type countryMinOrderByAggregateInput = {
    name?: SortOrder
    code?: SortOrder
    flag?: SortOrder
  }

  export type teamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    founded?: SortOrder
    national?: SortOrder
    logo?: SortOrder
    venues?: SortOrder
  }

  export type teamAvgOrderByAggregateInput = {
    id?: SortOrder
    founded?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    founded?: SortOrder
    national?: SortOrder
    logo?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    founded?: SortOrder
    national?: SortOrder
    logo?: SortOrder
  }

  export type teamSumOrderByAggregateInput = {
    id?: SortOrder
    founded?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type leadCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    createdat?: SortOrder
  }

  export type leadAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type leadMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    createdat?: SortOrder
  }

  export type leadMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    description?: SortOrder
    createdat?: SortOrder
  }

  export type leadSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type passwordhashCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
    salt?: SortOrder
    createdat?: SortOrder
  }

  export type passwordhashAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type passwordhashMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
    salt?: SortOrder
    createdat?: SortOrder
  }

  export type passwordhashMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    hash?: SortOrder
    salt?: SortOrder
    createdat?: SortOrder
  }

  export type passwordhashSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: permissionWhereInput
    isNot?: permissionWhereInput
  }

  export type permissionlogCountOrderByAggregateInput = {
    id?: SortOrder
    permissionid?: SortOrder
    action?: SortOrder
    createdat?: SortOrder
  }

  export type permissionlogAvgOrderByAggregateInput = {
    id?: SortOrder
    permissionid?: SortOrder
  }

  export type permissionlogMaxOrderByAggregateInput = {
    id?: SortOrder
    permissionid?: SortOrder
    action?: SortOrder
    createdat?: SortOrder
  }

  export type permissionlogMinOrderByAggregateInput = {
    id?: SortOrder
    permissionid?: SortOrder
    action?: SortOrder
    createdat?: SortOrder
  }

  export type permissionlogSumOrderByAggregateInput = {
    id?: SortOrder
    permissionid?: SortOrder
  }

  export type userlogCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    createat?: SortOrder
  }

  export type userlogAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type userlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    createat?: SortOrder
  }

  export type userlogMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    createat?: SortOrder
  }

  export type userlogSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type PermissionlogListRelationFilter = {
    every?: permissionlogWhereInput
    some?: permissionlogWhereInput
    none?: permissionlogWhereInput
  }

  export type permissionlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type permissionAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type permissionSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type users_profileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    street?: SortOrder
    phone_number?: SortOrder
    number_address?: SortOrder
    neigh?: SortOrder
    userid?: SortOrder
  }

  export type users_profileAvgOrderByAggregateInput = {
    id?: SortOrder
    number_address?: SortOrder
    userid?: SortOrder
  }

  export type users_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    street?: SortOrder
    phone_number?: SortOrder
    number_address?: SortOrder
    neigh?: SortOrder
    userid?: SortOrder
  }

  export type users_profileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    street?: SortOrder
    phone_number?: SortOrder
    number_address?: SortOrder
    neigh?: SortOrder
    userid?: SortOrder
  }

  export type users_profileSumOrderByAggregateInput = {
    id?: SortOrder
    number_address?: SortOrder
    userid?: SortOrder
  }

  export type cookieCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type cookieAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type cookieMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type cookieMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type cookieSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type passwordhashCreateNestedOneWithoutUserInput = {
    create?: XOR<passwordhashCreateWithoutUserInput, passwordhashUncheckedCreateWithoutUserInput>
    connectOrCreate?: passwordhashCreateOrConnectWithoutUserInput
    connect?: passwordhashWhereUniqueInput
  }

  export type cookieCreateNestedManyWithoutUserInput = {
    create?: XOR<cookieCreateWithoutUserInput, cookieUncheckedCreateWithoutUserInput> | cookieCreateWithoutUserInput[] | cookieUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cookieCreateOrConnectWithoutUserInput | cookieCreateOrConnectWithoutUserInput[]
    createMany?: cookieCreateManyUserInputEnvelope
    connect?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
  }

  export type permissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<permissionCreateWithoutPermissionInput, permissionUncheckedCreateWithoutPermissionInput> | permissionCreateWithoutPermissionInput[] | permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutPermissionInput | permissionCreateOrConnectWithoutPermissionInput[]
    createMany?: permissionCreateManyPermissionInputEnvelope
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
  }

  export type userlogCreateNestedManyWithoutUserInput = {
    create?: XOR<userlogCreateWithoutUserInput, userlogUncheckedCreateWithoutUserInput> | userlogCreateWithoutUserInput[] | userlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userlogCreateOrConnectWithoutUserInput | userlogCreateOrConnectWithoutUserInput[]
    createMany?: userlogCreateManyUserInputEnvelope
    connect?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
  }

  export type walletCreateNestedOneWithoutUserInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    connectOrCreate?: walletCreateOrConnectWithoutUserInput
    connect?: walletWhereUniqueInput
  }

  export type productCreateNestedManyWithoutUserInput = {
    create?: XOR<productCreateWithoutUserInput, productUncheckedCreateWithoutUserInput> | productCreateWithoutUserInput[] | productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: productCreateOrConnectWithoutUserInput | productCreateOrConnectWithoutUserInput[]
    createMany?: productCreateManyUserInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutUserInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type users_profileCreateNestedManyWithoutProfileInput = {
    create?: XOR<users_profileCreateWithoutProfileInput, users_profileUncheckedCreateWithoutProfileInput> | users_profileCreateWithoutProfileInput[] | users_profileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: users_profileCreateOrConnectWithoutProfileInput | users_profileCreateOrConnectWithoutProfileInput[]
    createMany?: users_profileCreateManyProfileInputEnvelope
    connect?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
  }

  export type passwordhashUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<passwordhashCreateWithoutUserInput, passwordhashUncheckedCreateWithoutUserInput>
    connectOrCreate?: passwordhashCreateOrConnectWithoutUserInput
    connect?: passwordhashWhereUniqueInput
  }

  export type cookieUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<cookieCreateWithoutUserInput, cookieUncheckedCreateWithoutUserInput> | cookieCreateWithoutUserInput[] | cookieUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cookieCreateOrConnectWithoutUserInput | cookieCreateOrConnectWithoutUserInput[]
    createMany?: cookieCreateManyUserInputEnvelope
    connect?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
  }

  export type permissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<permissionCreateWithoutPermissionInput, permissionUncheckedCreateWithoutPermissionInput> | permissionCreateWithoutPermissionInput[] | permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutPermissionInput | permissionCreateOrConnectWithoutPermissionInput[]
    createMany?: permissionCreateManyPermissionInputEnvelope
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
  }

  export type userlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userlogCreateWithoutUserInput, userlogUncheckedCreateWithoutUserInput> | userlogCreateWithoutUserInput[] | userlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userlogCreateOrConnectWithoutUserInput | userlogCreateOrConnectWithoutUserInput[]
    createMany?: userlogCreateManyUserInputEnvelope
    connect?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
  }

  export type walletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    connectOrCreate?: walletCreateOrConnectWithoutUserInput
    connect?: walletWhereUniqueInput
  }

  export type productUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<productCreateWithoutUserInput, productUncheckedCreateWithoutUserInput> | productCreateWithoutUserInput[] | productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: productCreateOrConnectWithoutUserInput | productCreateOrConnectWithoutUserInput[]
    createMany?: productCreateManyUserInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type users_profileUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<users_profileCreateWithoutProfileInput, users_profileUncheckedCreateWithoutProfileInput> | users_profileCreateWithoutProfileInput[] | users_profileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: users_profileCreateOrConnectWithoutProfileInput | users_profileCreateOrConnectWithoutProfileInput[]
    createMany?: users_profileCreateManyProfileInputEnvelope
    connect?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumusecaseFieldUpdateOperationsInput = {
    set?: usecase
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type passwordhashUpdateOneWithoutUserNestedInput = {
    create?: XOR<passwordhashCreateWithoutUserInput, passwordhashUncheckedCreateWithoutUserInput>
    connectOrCreate?: passwordhashCreateOrConnectWithoutUserInput
    upsert?: passwordhashUpsertWithoutUserInput
    disconnect?: passwordhashWhereInput | boolean
    delete?: passwordhashWhereInput | boolean
    connect?: passwordhashWhereUniqueInput
    update?: XOR<XOR<passwordhashUpdateToOneWithWhereWithoutUserInput, passwordhashUpdateWithoutUserInput>, passwordhashUncheckedUpdateWithoutUserInput>
  }

  export type cookieUpdateManyWithoutUserNestedInput = {
    create?: XOR<cookieCreateWithoutUserInput, cookieUncheckedCreateWithoutUserInput> | cookieCreateWithoutUserInput[] | cookieUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cookieCreateOrConnectWithoutUserInput | cookieCreateOrConnectWithoutUserInput[]
    upsert?: cookieUpsertWithWhereUniqueWithoutUserInput | cookieUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: cookieCreateManyUserInputEnvelope
    set?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    disconnect?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    delete?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    connect?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    update?: cookieUpdateWithWhereUniqueWithoutUserInput | cookieUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: cookieUpdateManyWithWhereWithoutUserInput | cookieUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: cookieScalarWhereInput | cookieScalarWhereInput[]
  }

  export type permissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<permissionCreateWithoutPermissionInput, permissionUncheckedCreateWithoutPermissionInput> | permissionCreateWithoutPermissionInput[] | permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutPermissionInput | permissionCreateOrConnectWithoutPermissionInput[]
    upsert?: permissionUpsertWithWhereUniqueWithoutPermissionInput | permissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: permissionCreateManyPermissionInputEnvelope
    set?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    disconnect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    delete?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    update?: permissionUpdateWithWhereUniqueWithoutPermissionInput | permissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: permissionUpdateManyWithWhereWithoutPermissionInput | permissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: permissionScalarWhereInput | permissionScalarWhereInput[]
  }

  export type userlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<userlogCreateWithoutUserInput, userlogUncheckedCreateWithoutUserInput> | userlogCreateWithoutUserInput[] | userlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userlogCreateOrConnectWithoutUserInput | userlogCreateOrConnectWithoutUserInput[]
    upsert?: userlogUpsertWithWhereUniqueWithoutUserInput | userlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userlogCreateManyUserInputEnvelope
    set?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    disconnect?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    delete?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    connect?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    update?: userlogUpdateWithWhereUniqueWithoutUserInput | userlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userlogUpdateManyWithWhereWithoutUserInput | userlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userlogScalarWhereInput | userlogScalarWhereInput[]
  }

  export type walletUpdateOneWithoutUserNestedInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    connectOrCreate?: walletCreateOrConnectWithoutUserInput
    upsert?: walletUpsertWithoutUserInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutUserInput, walletUpdateWithoutUserInput>, walletUncheckedUpdateWithoutUserInput>
  }

  export type productUpdateManyWithoutUserNestedInput = {
    create?: XOR<productCreateWithoutUserInput, productUncheckedCreateWithoutUserInput> | productCreateWithoutUserInput[] | productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: productCreateOrConnectWithoutUserInput | productCreateOrConnectWithoutUserInput[]
    upsert?: productUpsertWithWhereUniqueWithoutUserInput | productUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: productCreateManyUserInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutUserInput | productUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: productUpdateManyWithWhereWithoutUserInput | productUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type orderUpdateManyWithoutUserNestedInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutUserInput | orderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutUserInput | orderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: orderUpdateManyWithWhereWithoutUserInput | orderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type users_profileUpdateManyWithoutProfileNestedInput = {
    create?: XOR<users_profileCreateWithoutProfileInput, users_profileUncheckedCreateWithoutProfileInput> | users_profileCreateWithoutProfileInput[] | users_profileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: users_profileCreateOrConnectWithoutProfileInput | users_profileCreateOrConnectWithoutProfileInput[]
    upsert?: users_profileUpsertWithWhereUniqueWithoutProfileInput | users_profileUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: users_profileCreateManyProfileInputEnvelope
    set?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    disconnect?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    delete?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    connect?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    update?: users_profileUpdateWithWhereUniqueWithoutProfileInput | users_profileUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: users_profileUpdateManyWithWhereWithoutProfileInput | users_profileUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: users_profileScalarWhereInput | users_profileScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type passwordhashUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<passwordhashCreateWithoutUserInput, passwordhashUncheckedCreateWithoutUserInput>
    connectOrCreate?: passwordhashCreateOrConnectWithoutUserInput
    upsert?: passwordhashUpsertWithoutUserInput
    disconnect?: passwordhashWhereInput | boolean
    delete?: passwordhashWhereInput | boolean
    connect?: passwordhashWhereUniqueInput
    update?: XOR<XOR<passwordhashUpdateToOneWithWhereWithoutUserInput, passwordhashUpdateWithoutUserInput>, passwordhashUncheckedUpdateWithoutUserInput>
  }

  export type cookieUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<cookieCreateWithoutUserInput, cookieUncheckedCreateWithoutUserInput> | cookieCreateWithoutUserInput[] | cookieUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cookieCreateOrConnectWithoutUserInput | cookieCreateOrConnectWithoutUserInput[]
    upsert?: cookieUpsertWithWhereUniqueWithoutUserInput | cookieUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: cookieCreateManyUserInputEnvelope
    set?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    disconnect?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    delete?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    connect?: cookieWhereUniqueInput | cookieWhereUniqueInput[]
    update?: cookieUpdateWithWhereUniqueWithoutUserInput | cookieUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: cookieUpdateManyWithWhereWithoutUserInput | cookieUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: cookieScalarWhereInput | cookieScalarWhereInput[]
  }

  export type permissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<permissionCreateWithoutPermissionInput, permissionUncheckedCreateWithoutPermissionInput> | permissionCreateWithoutPermissionInput[] | permissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutPermissionInput | permissionCreateOrConnectWithoutPermissionInput[]
    upsert?: permissionUpsertWithWhereUniqueWithoutPermissionInput | permissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: permissionCreateManyPermissionInputEnvelope
    set?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    disconnect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    delete?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    update?: permissionUpdateWithWhereUniqueWithoutPermissionInput | permissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: permissionUpdateManyWithWhereWithoutPermissionInput | permissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: permissionScalarWhereInput | permissionScalarWhereInput[]
  }

  export type userlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userlogCreateWithoutUserInput, userlogUncheckedCreateWithoutUserInput> | userlogCreateWithoutUserInput[] | userlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userlogCreateOrConnectWithoutUserInput | userlogCreateOrConnectWithoutUserInput[]
    upsert?: userlogUpsertWithWhereUniqueWithoutUserInput | userlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userlogCreateManyUserInputEnvelope
    set?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    disconnect?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    delete?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    connect?: userlogWhereUniqueInput | userlogWhereUniqueInput[]
    update?: userlogUpdateWithWhereUniqueWithoutUserInput | userlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userlogUpdateManyWithWhereWithoutUserInput | userlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userlogScalarWhereInput | userlogScalarWhereInput[]
  }

  export type walletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    connectOrCreate?: walletCreateOrConnectWithoutUserInput
    upsert?: walletUpsertWithoutUserInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutUserInput, walletUpdateWithoutUserInput>, walletUncheckedUpdateWithoutUserInput>
  }

  export type productUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<productCreateWithoutUserInput, productUncheckedCreateWithoutUserInput> | productCreateWithoutUserInput[] | productUncheckedCreateWithoutUserInput[]
    connectOrCreate?: productCreateOrConnectWithoutUserInput | productCreateOrConnectWithoutUserInput[]
    upsert?: productUpsertWithWhereUniqueWithoutUserInput | productUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: productCreateManyUserInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutUserInput | productUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: productUpdateManyWithWhereWithoutUserInput | productUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput> | orderCreateWithoutUserInput[] | orderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: orderCreateOrConnectWithoutUserInput | orderCreateOrConnectWithoutUserInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutUserInput | orderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: orderCreateManyUserInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutUserInput | orderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: orderUpdateManyWithWhereWithoutUserInput | orderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type users_profileUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<users_profileCreateWithoutProfileInput, users_profileUncheckedCreateWithoutProfileInput> | users_profileCreateWithoutProfileInput[] | users_profileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: users_profileCreateOrConnectWithoutProfileInput | users_profileCreateOrConnectWithoutProfileInput[]
    upsert?: users_profileUpsertWithWhereUniqueWithoutProfileInput | users_profileUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: users_profileCreateManyProfileInputEnvelope
    set?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    disconnect?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    delete?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    connect?: users_profileWhereUniqueInput | users_profileWhereUniqueInput[]
    update?: users_profileUpdateWithWhereUniqueWithoutProfileInput | users_profileUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: users_profileUpdateManyWithWhereWithoutProfileInput | users_profileUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: users_profileScalarWhereInput | users_profileScalarWhereInput[]
  }

  export type league_teamsCreateNestedOneWithoutStatistics_teamInput = {
    create?: XOR<league_teamsCreateWithoutStatistics_teamInput, league_teamsUncheckedCreateWithoutStatistics_teamInput>
    connectOrCreate?: league_teamsCreateOrConnectWithoutStatistics_teamInput
    connect?: league_teamsWhereUniqueInput
  }

  export type league_teamsUpdateOneRequiredWithoutStatistics_teamNestedInput = {
    create?: XOR<league_teamsCreateWithoutStatistics_teamInput, league_teamsUncheckedCreateWithoutStatistics_teamInput>
    connectOrCreate?: league_teamsCreateOrConnectWithoutStatistics_teamInput
    upsert?: league_teamsUpsertWithoutStatistics_teamInput
    connect?: league_teamsWhereUniqueInput
    update?: XOR<XOR<league_teamsUpdateToOneWithWhereWithoutStatistics_teamInput, league_teamsUpdateWithoutStatistics_teamInput>, league_teamsUncheckedUpdateWithoutStatistics_teamInput>
  }

  export type team_playerCreateNestedManyWithoutPlayeridInput = {
    create?: XOR<team_playerCreateWithoutPlayeridInput, team_playerUncheckedCreateWithoutPlayeridInput> | team_playerCreateWithoutPlayeridInput[] | team_playerUncheckedCreateWithoutPlayeridInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutPlayeridInput | team_playerCreateOrConnectWithoutPlayeridInput[]
    createMany?: team_playerCreateManyPlayeridInputEnvelope
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
  }

  export type team_playerUncheckedCreateNestedManyWithoutPlayeridInput = {
    create?: XOR<team_playerCreateWithoutPlayeridInput, team_playerUncheckedCreateWithoutPlayeridInput> | team_playerCreateWithoutPlayeridInput[] | team_playerUncheckedCreateWithoutPlayeridInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutPlayeridInput | team_playerCreateOrConnectWithoutPlayeridInput[]
    createMany?: team_playerCreateManyPlayeridInputEnvelope
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type team_playerUpdateManyWithoutPlayeridNestedInput = {
    create?: XOR<team_playerCreateWithoutPlayeridInput, team_playerUncheckedCreateWithoutPlayeridInput> | team_playerCreateWithoutPlayeridInput[] | team_playerUncheckedCreateWithoutPlayeridInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutPlayeridInput | team_playerCreateOrConnectWithoutPlayeridInput[]
    upsert?: team_playerUpsertWithWhereUniqueWithoutPlayeridInput | team_playerUpsertWithWhereUniqueWithoutPlayeridInput[]
    createMany?: team_playerCreateManyPlayeridInputEnvelope
    set?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    disconnect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    delete?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    update?: team_playerUpdateWithWhereUniqueWithoutPlayeridInput | team_playerUpdateWithWhereUniqueWithoutPlayeridInput[]
    updateMany?: team_playerUpdateManyWithWhereWithoutPlayeridInput | team_playerUpdateManyWithWhereWithoutPlayeridInput[]
    deleteMany?: team_playerScalarWhereInput | team_playerScalarWhereInput[]
  }

  export type team_playerUncheckedUpdateManyWithoutPlayeridNestedInput = {
    create?: XOR<team_playerCreateWithoutPlayeridInput, team_playerUncheckedCreateWithoutPlayeridInput> | team_playerCreateWithoutPlayeridInput[] | team_playerUncheckedCreateWithoutPlayeridInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutPlayeridInput | team_playerCreateOrConnectWithoutPlayeridInput[]
    upsert?: team_playerUpsertWithWhereUniqueWithoutPlayeridInput | team_playerUpsertWithWhereUniqueWithoutPlayeridInput[]
    createMany?: team_playerCreateManyPlayeridInputEnvelope
    set?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    disconnect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    delete?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    update?: team_playerUpdateWithWhereUniqueWithoutPlayeridInput | team_playerUpdateWithWhereUniqueWithoutPlayeridInput[]
    updateMany?: team_playerUpdateManyWithWhereWithoutPlayeridInput | team_playerUpdateManyWithWhereWithoutPlayeridInput[]
    deleteMany?: team_playerScalarWhereInput | team_playerScalarWhereInput[]
  }

  export type teamCreateNestedOneWithoutPlayer_teamInput = {
    create?: XOR<teamCreateWithoutPlayer_teamInput, teamUncheckedCreateWithoutPlayer_teamInput>
    connectOrCreate?: teamCreateOrConnectWithoutPlayer_teamInput
    connect?: teamWhereUniqueInput
  }

  export type football_playersCreateNestedOneWithoutTeam_playerInput = {
    create?: XOR<football_playersCreateWithoutTeam_playerInput, football_playersUncheckedCreateWithoutTeam_playerInput>
    connectOrCreate?: football_playersCreateOrConnectWithoutTeam_playerInput
    connect?: football_playersWhereUniqueInput
  }

  export type teamUpdateOneRequiredWithoutPlayer_teamNestedInput = {
    create?: XOR<teamCreateWithoutPlayer_teamInput, teamUncheckedCreateWithoutPlayer_teamInput>
    connectOrCreate?: teamCreateOrConnectWithoutPlayer_teamInput
    upsert?: teamUpsertWithoutPlayer_teamInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutPlayer_teamInput, teamUpdateWithoutPlayer_teamInput>, teamUncheckedUpdateWithoutPlayer_teamInput>
  }

  export type football_playersUpdateOneRequiredWithoutTeam_playerNestedInput = {
    create?: XOR<football_playersCreateWithoutTeam_playerInput, football_playersUncheckedCreateWithoutTeam_playerInput>
    connectOrCreate?: football_playersCreateOrConnectWithoutTeam_playerInput
    upsert?: football_playersUpsertWithoutTeam_playerInput
    connect?: football_playersWhereUniqueInput
    update?: XOR<XOR<football_playersUpdateToOneWithWhereWithoutTeam_playerInput, football_playersUpdateWithoutTeam_playerInput>, football_playersUncheckedUpdateWithoutTeam_playerInput>
  }

  export type userCreateNestedOneWithoutProductInput = {
    create?: XOR<userCreateWithoutProductInput, userUncheckedCreateWithoutProductInput>
    connectOrCreate?: userCreateOrConnectWithoutProductInput
    connect?: userWhereUniqueInput
  }

  export type orderCreateNestedManyWithoutProductInput = {
    create?: XOR<orderCreateWithoutProductInput, orderUncheckedCreateWithoutProductInput> | orderCreateWithoutProductInput[] | orderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderCreateOrConnectWithoutProductInput | orderCreateOrConnectWithoutProductInput[]
    createMany?: orderCreateManyProductInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<orderCreateWithoutProductInput, orderUncheckedCreateWithoutProductInput> | orderCreateWithoutProductInput[] | orderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderCreateOrConnectWithoutProductInput | orderCreateOrConnectWithoutProductInput[]
    createMany?: orderCreateManyProductInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<userCreateWithoutProductInput, userUncheckedCreateWithoutProductInput>
    connectOrCreate?: userCreateOrConnectWithoutProductInput
    upsert?: userUpsertWithoutProductInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProductInput, userUpdateWithoutProductInput>, userUncheckedUpdateWithoutProductInput>
  }

  export type orderUpdateManyWithoutProductNestedInput = {
    create?: XOR<orderCreateWithoutProductInput, orderUncheckedCreateWithoutProductInput> | orderCreateWithoutProductInput[] | orderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderCreateOrConnectWithoutProductInput | orderCreateOrConnectWithoutProductInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutProductInput | orderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: orderCreateManyProductInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutProductInput | orderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: orderUpdateManyWithWhereWithoutProductInput | orderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<orderCreateWithoutProductInput, orderUncheckedCreateWithoutProductInput> | orderCreateWithoutProductInput[] | orderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderCreateOrConnectWithoutProductInput | orderCreateOrConnectWithoutProductInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutProductInput | orderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: orderCreateManyProductInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutProductInput | orderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: orderUpdateManyWithWhereWithoutProductInput | orderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type productCreateNestedOneWithoutOrdersInput = {
    create?: XOR<productCreateWithoutOrdersInput, productUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: productCreateOrConnectWithoutOrdersInput
    connect?: productWhereUniqueInput
  }

  export type userCreateNestedOneWithoutOrderInput = {
    create?: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutOrderInput
    connect?: userWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<productCreateWithoutOrdersInput, productUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: productCreateOrConnectWithoutOrdersInput
    upsert?: productUpsertWithoutOrdersInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutOrdersInput, productUpdateWithoutOrdersInput>, productUncheckedUpdateWithoutOrdersInput>
  }

  export type userUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutOrderInput
    upsert?: userUpsertWithoutOrderInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOrderInput, userUpdateWithoutOrderInput>, userUncheckedUpdateWithoutOrderInput>
  }

  export type userCreateNestedOneWithoutWalletInput = {
    create?: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    connectOrCreate?: userCreateOrConnectWithoutWalletInput
    connect?: userWhereUniqueInput
  }

  export type walletmovementCreateNestedManyWithoutWalletInput = {
    create?: XOR<walletmovementCreateWithoutWalletInput, walletmovementUncheckedCreateWithoutWalletInput> | walletmovementCreateWithoutWalletInput[] | walletmovementUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: walletmovementCreateOrConnectWithoutWalletInput | walletmovementCreateOrConnectWithoutWalletInput[]
    createMany?: walletmovementCreateManyWalletInputEnvelope
    connect?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
  }

  export type walletmovementUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<walletmovementCreateWithoutWalletInput, walletmovementUncheckedCreateWithoutWalletInput> | walletmovementCreateWithoutWalletInput[] | walletmovementUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: walletmovementCreateOrConnectWithoutWalletInput | walletmovementCreateOrConnectWithoutWalletInput[]
    createMany?: walletmovementCreateManyWalletInputEnvelope
    connect?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    connectOrCreate?: userCreateOrConnectWithoutWalletInput
    upsert?: userUpsertWithoutWalletInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutWalletInput, userUpdateWithoutWalletInput>, userUncheckedUpdateWithoutWalletInput>
  }

  export type walletmovementUpdateManyWithoutWalletNestedInput = {
    create?: XOR<walletmovementCreateWithoutWalletInput, walletmovementUncheckedCreateWithoutWalletInput> | walletmovementCreateWithoutWalletInput[] | walletmovementUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: walletmovementCreateOrConnectWithoutWalletInput | walletmovementCreateOrConnectWithoutWalletInput[]
    upsert?: walletmovementUpsertWithWhereUniqueWithoutWalletInput | walletmovementUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: walletmovementCreateManyWalletInputEnvelope
    set?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    disconnect?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    delete?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    connect?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    update?: walletmovementUpdateWithWhereUniqueWithoutWalletInput | walletmovementUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: walletmovementUpdateManyWithWhereWithoutWalletInput | walletmovementUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: walletmovementScalarWhereInput | walletmovementScalarWhereInput[]
  }

  export type walletmovementUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<walletmovementCreateWithoutWalletInput, walletmovementUncheckedCreateWithoutWalletInput> | walletmovementCreateWithoutWalletInput[] | walletmovementUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: walletmovementCreateOrConnectWithoutWalletInput | walletmovementCreateOrConnectWithoutWalletInput[]
    upsert?: walletmovementUpsertWithWhereUniqueWithoutWalletInput | walletmovementUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: walletmovementCreateManyWalletInputEnvelope
    set?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    disconnect?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    delete?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    connect?: walletmovementWhereUniqueInput | walletmovementWhereUniqueInput[]
    update?: walletmovementUpdateWithWhereUniqueWithoutWalletInput | walletmovementUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: walletmovementUpdateManyWithWhereWithoutWalletInput | walletmovementUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: walletmovementScalarWhereInput | walletmovementScalarWhereInput[]
  }

  export type walletCreateNestedOneWithoutWalletmovementInput = {
    create?: XOR<walletCreateWithoutWalletmovementInput, walletUncheckedCreateWithoutWalletmovementInput>
    connectOrCreate?: walletCreateOrConnectWithoutWalletmovementInput
    connect?: walletWhereUniqueInput
  }

  export type EnummovementtypeFieldUpdateOperationsInput = {
    set?: movementtype
  }

  export type walletUpdateOneRequiredWithoutWalletmovementNestedInput = {
    create?: XOR<walletCreateWithoutWalletmovementInput, walletUncheckedCreateWithoutWalletmovementInput>
    connectOrCreate?: walletCreateOrConnectWithoutWalletmovementInput
    upsert?: walletUpsertWithoutWalletmovementInput
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutWalletmovementInput, walletUpdateWithoutWalletmovementInput>, walletUncheckedUpdateWithoutWalletmovementInput>
  }

  export type league_teamsCreateNestedManyWithoutLeaguesInput = {
    create?: XOR<league_teamsCreateWithoutLeaguesInput, league_teamsUncheckedCreateWithoutLeaguesInput> | league_teamsCreateWithoutLeaguesInput[] | league_teamsUncheckedCreateWithoutLeaguesInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutLeaguesInput | league_teamsCreateOrConnectWithoutLeaguesInput[]
    createMany?: league_teamsCreateManyLeaguesInputEnvelope
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
  }

  export type league_teamsUncheckedCreateNestedManyWithoutLeaguesInput = {
    create?: XOR<league_teamsCreateWithoutLeaguesInput, league_teamsUncheckedCreateWithoutLeaguesInput> | league_teamsCreateWithoutLeaguesInput[] | league_teamsUncheckedCreateWithoutLeaguesInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutLeaguesInput | league_teamsCreateOrConnectWithoutLeaguesInput[]
    createMany?: league_teamsCreateManyLeaguesInputEnvelope
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
  }

  export type EnumtypecupFieldUpdateOperationsInput = {
    set?: typecup
  }

  export type league_teamsUpdateManyWithoutLeaguesNestedInput = {
    create?: XOR<league_teamsCreateWithoutLeaguesInput, league_teamsUncheckedCreateWithoutLeaguesInput> | league_teamsCreateWithoutLeaguesInput[] | league_teamsUncheckedCreateWithoutLeaguesInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutLeaguesInput | league_teamsCreateOrConnectWithoutLeaguesInput[]
    upsert?: league_teamsUpsertWithWhereUniqueWithoutLeaguesInput | league_teamsUpsertWithWhereUniqueWithoutLeaguesInput[]
    createMany?: league_teamsCreateManyLeaguesInputEnvelope
    set?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    disconnect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    delete?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    update?: league_teamsUpdateWithWhereUniqueWithoutLeaguesInput | league_teamsUpdateWithWhereUniqueWithoutLeaguesInput[]
    updateMany?: league_teamsUpdateManyWithWhereWithoutLeaguesInput | league_teamsUpdateManyWithWhereWithoutLeaguesInput[]
    deleteMany?: league_teamsScalarWhereInput | league_teamsScalarWhereInput[]
  }

  export type league_teamsUncheckedUpdateManyWithoutLeaguesNestedInput = {
    create?: XOR<league_teamsCreateWithoutLeaguesInput, league_teamsUncheckedCreateWithoutLeaguesInput> | league_teamsCreateWithoutLeaguesInput[] | league_teamsUncheckedCreateWithoutLeaguesInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutLeaguesInput | league_teamsCreateOrConnectWithoutLeaguesInput[]
    upsert?: league_teamsUpsertWithWhereUniqueWithoutLeaguesInput | league_teamsUpsertWithWhereUniqueWithoutLeaguesInput[]
    createMany?: league_teamsCreateManyLeaguesInputEnvelope
    set?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    disconnect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    delete?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    update?: league_teamsUpdateWithWhereUniqueWithoutLeaguesInput | league_teamsUpdateWithWhereUniqueWithoutLeaguesInput[]
    updateMany?: league_teamsUpdateManyWithWhereWithoutLeaguesInput | league_teamsUpdateManyWithWhereWithoutLeaguesInput[]
    deleteMany?: league_teamsScalarWhereInput | league_teamsScalarWhereInput[]
  }

  export type leaguesCreateNestedOneWithoutLeague_teamsInput = {
    create?: XOR<leaguesCreateWithoutLeague_teamsInput, leaguesUncheckedCreateWithoutLeague_teamsInput>
    connectOrCreate?: leaguesCreateOrConnectWithoutLeague_teamsInput
    connect?: leaguesWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutLeague_teamsInput = {
    create?: XOR<teamCreateWithoutLeague_teamsInput, teamUncheckedCreateWithoutLeague_teamsInput>
    connectOrCreate?: teamCreateOrConnectWithoutLeague_teamsInput
    connect?: teamWhereUniqueInput
  }

  export type statistics_teamCreateNestedManyWithoutLeague_teamidInput = {
    create?: XOR<statistics_teamCreateWithoutLeague_teamidInput, statistics_teamUncheckedCreateWithoutLeague_teamidInput> | statistics_teamCreateWithoutLeague_teamidInput[] | statistics_teamUncheckedCreateWithoutLeague_teamidInput[]
    connectOrCreate?: statistics_teamCreateOrConnectWithoutLeague_teamidInput | statistics_teamCreateOrConnectWithoutLeague_teamidInput[]
    createMany?: statistics_teamCreateManyLeague_teamidInputEnvelope
    connect?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
  }

  export type statistics_teamUncheckedCreateNestedManyWithoutLeague_teamidInput = {
    create?: XOR<statistics_teamCreateWithoutLeague_teamidInput, statistics_teamUncheckedCreateWithoutLeague_teamidInput> | statistics_teamCreateWithoutLeague_teamidInput[] | statistics_teamUncheckedCreateWithoutLeague_teamidInput[]
    connectOrCreate?: statistics_teamCreateOrConnectWithoutLeague_teamidInput | statistics_teamCreateOrConnectWithoutLeague_teamidInput[]
    createMany?: statistics_teamCreateManyLeague_teamidInputEnvelope
    connect?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
  }

  export type leaguesUpdateOneRequiredWithoutLeague_teamsNestedInput = {
    create?: XOR<leaguesCreateWithoutLeague_teamsInput, leaguesUncheckedCreateWithoutLeague_teamsInput>
    connectOrCreate?: leaguesCreateOrConnectWithoutLeague_teamsInput
    upsert?: leaguesUpsertWithoutLeague_teamsInput
    connect?: leaguesWhereUniqueInput
    update?: XOR<XOR<leaguesUpdateToOneWithWhereWithoutLeague_teamsInput, leaguesUpdateWithoutLeague_teamsInput>, leaguesUncheckedUpdateWithoutLeague_teamsInput>
  }

  export type teamUpdateOneRequiredWithoutLeague_teamsNestedInput = {
    create?: XOR<teamCreateWithoutLeague_teamsInput, teamUncheckedCreateWithoutLeague_teamsInput>
    connectOrCreate?: teamCreateOrConnectWithoutLeague_teamsInput
    upsert?: teamUpsertWithoutLeague_teamsInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutLeague_teamsInput, teamUpdateWithoutLeague_teamsInput>, teamUncheckedUpdateWithoutLeague_teamsInput>
  }

  export type statistics_teamUpdateManyWithoutLeague_teamidNestedInput = {
    create?: XOR<statistics_teamCreateWithoutLeague_teamidInput, statistics_teamUncheckedCreateWithoutLeague_teamidInput> | statistics_teamCreateWithoutLeague_teamidInput[] | statistics_teamUncheckedCreateWithoutLeague_teamidInput[]
    connectOrCreate?: statistics_teamCreateOrConnectWithoutLeague_teamidInput | statistics_teamCreateOrConnectWithoutLeague_teamidInput[]
    upsert?: statistics_teamUpsertWithWhereUniqueWithoutLeague_teamidInput | statistics_teamUpsertWithWhereUniqueWithoutLeague_teamidInput[]
    createMany?: statistics_teamCreateManyLeague_teamidInputEnvelope
    set?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    disconnect?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    delete?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    connect?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    update?: statistics_teamUpdateWithWhereUniqueWithoutLeague_teamidInput | statistics_teamUpdateWithWhereUniqueWithoutLeague_teamidInput[]
    updateMany?: statistics_teamUpdateManyWithWhereWithoutLeague_teamidInput | statistics_teamUpdateManyWithWhereWithoutLeague_teamidInput[]
    deleteMany?: statistics_teamScalarWhereInput | statistics_teamScalarWhereInput[]
  }

  export type statistics_teamUncheckedUpdateManyWithoutLeague_teamidNestedInput = {
    create?: XOR<statistics_teamCreateWithoutLeague_teamidInput, statistics_teamUncheckedCreateWithoutLeague_teamidInput> | statistics_teamCreateWithoutLeague_teamidInput[] | statistics_teamUncheckedCreateWithoutLeague_teamidInput[]
    connectOrCreate?: statistics_teamCreateOrConnectWithoutLeague_teamidInput | statistics_teamCreateOrConnectWithoutLeague_teamidInput[]
    upsert?: statistics_teamUpsertWithWhereUniqueWithoutLeague_teamidInput | statistics_teamUpsertWithWhereUniqueWithoutLeague_teamidInput[]
    createMany?: statistics_teamCreateManyLeague_teamidInputEnvelope
    set?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    disconnect?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    delete?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    connect?: statistics_teamWhereUniqueInput | statistics_teamWhereUniqueInput[]
    update?: statistics_teamUpdateWithWhereUniqueWithoutLeague_teamidInput | statistics_teamUpdateWithWhereUniqueWithoutLeague_teamidInput[]
    updateMany?: statistics_teamUpdateManyWithWhereWithoutLeague_teamidInput | statistics_teamUpdateManyWithWhereWithoutLeague_teamidInput[]
    deleteMany?: statistics_teamScalarWhereInput | statistics_teamScalarWhereInput[]
  }

  export type league_teamsCreateNestedManyWithoutTeamidInput = {
    create?: XOR<league_teamsCreateWithoutTeamidInput, league_teamsUncheckedCreateWithoutTeamidInput> | league_teamsCreateWithoutTeamidInput[] | league_teamsUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutTeamidInput | league_teamsCreateOrConnectWithoutTeamidInput[]
    createMany?: league_teamsCreateManyTeamidInputEnvelope
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
  }

  export type team_playerCreateNestedManyWithoutTeamidInput = {
    create?: XOR<team_playerCreateWithoutTeamidInput, team_playerUncheckedCreateWithoutTeamidInput> | team_playerCreateWithoutTeamidInput[] | team_playerUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutTeamidInput | team_playerCreateOrConnectWithoutTeamidInput[]
    createMany?: team_playerCreateManyTeamidInputEnvelope
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
  }

  export type league_teamsUncheckedCreateNestedManyWithoutTeamidInput = {
    create?: XOR<league_teamsCreateWithoutTeamidInput, league_teamsUncheckedCreateWithoutTeamidInput> | league_teamsCreateWithoutTeamidInput[] | league_teamsUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutTeamidInput | league_teamsCreateOrConnectWithoutTeamidInput[]
    createMany?: league_teamsCreateManyTeamidInputEnvelope
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
  }

  export type team_playerUncheckedCreateNestedManyWithoutTeamidInput = {
    create?: XOR<team_playerCreateWithoutTeamidInput, team_playerUncheckedCreateWithoutTeamidInput> | team_playerCreateWithoutTeamidInput[] | team_playerUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutTeamidInput | team_playerCreateOrConnectWithoutTeamidInput[]
    createMany?: team_playerCreateManyTeamidInputEnvelope
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
  }

  export type league_teamsUpdateManyWithoutTeamidNestedInput = {
    create?: XOR<league_teamsCreateWithoutTeamidInput, league_teamsUncheckedCreateWithoutTeamidInput> | league_teamsCreateWithoutTeamidInput[] | league_teamsUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutTeamidInput | league_teamsCreateOrConnectWithoutTeamidInput[]
    upsert?: league_teamsUpsertWithWhereUniqueWithoutTeamidInput | league_teamsUpsertWithWhereUniqueWithoutTeamidInput[]
    createMany?: league_teamsCreateManyTeamidInputEnvelope
    set?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    disconnect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    delete?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    update?: league_teamsUpdateWithWhereUniqueWithoutTeamidInput | league_teamsUpdateWithWhereUniqueWithoutTeamidInput[]
    updateMany?: league_teamsUpdateManyWithWhereWithoutTeamidInput | league_teamsUpdateManyWithWhereWithoutTeamidInput[]
    deleteMany?: league_teamsScalarWhereInput | league_teamsScalarWhereInput[]
  }

  export type team_playerUpdateManyWithoutTeamidNestedInput = {
    create?: XOR<team_playerCreateWithoutTeamidInput, team_playerUncheckedCreateWithoutTeamidInput> | team_playerCreateWithoutTeamidInput[] | team_playerUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutTeamidInput | team_playerCreateOrConnectWithoutTeamidInput[]
    upsert?: team_playerUpsertWithWhereUniqueWithoutTeamidInput | team_playerUpsertWithWhereUniqueWithoutTeamidInput[]
    createMany?: team_playerCreateManyTeamidInputEnvelope
    set?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    disconnect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    delete?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    update?: team_playerUpdateWithWhereUniqueWithoutTeamidInput | team_playerUpdateWithWhereUniqueWithoutTeamidInput[]
    updateMany?: team_playerUpdateManyWithWhereWithoutTeamidInput | team_playerUpdateManyWithWhereWithoutTeamidInput[]
    deleteMany?: team_playerScalarWhereInput | team_playerScalarWhereInput[]
  }

  export type league_teamsUncheckedUpdateManyWithoutTeamidNestedInput = {
    create?: XOR<league_teamsCreateWithoutTeamidInput, league_teamsUncheckedCreateWithoutTeamidInput> | league_teamsCreateWithoutTeamidInput[] | league_teamsUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: league_teamsCreateOrConnectWithoutTeamidInput | league_teamsCreateOrConnectWithoutTeamidInput[]
    upsert?: league_teamsUpsertWithWhereUniqueWithoutTeamidInput | league_teamsUpsertWithWhereUniqueWithoutTeamidInput[]
    createMany?: league_teamsCreateManyTeamidInputEnvelope
    set?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    disconnect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    delete?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    connect?: league_teamsWhereUniqueInput | league_teamsWhereUniqueInput[]
    update?: league_teamsUpdateWithWhereUniqueWithoutTeamidInput | league_teamsUpdateWithWhereUniqueWithoutTeamidInput[]
    updateMany?: league_teamsUpdateManyWithWhereWithoutTeamidInput | league_teamsUpdateManyWithWhereWithoutTeamidInput[]
    deleteMany?: league_teamsScalarWhereInput | league_teamsScalarWhereInput[]
  }

  export type team_playerUncheckedUpdateManyWithoutTeamidNestedInput = {
    create?: XOR<team_playerCreateWithoutTeamidInput, team_playerUncheckedCreateWithoutTeamidInput> | team_playerCreateWithoutTeamidInput[] | team_playerUncheckedCreateWithoutTeamidInput[]
    connectOrCreate?: team_playerCreateOrConnectWithoutTeamidInput | team_playerCreateOrConnectWithoutTeamidInput[]
    upsert?: team_playerUpsertWithWhereUniqueWithoutTeamidInput | team_playerUpsertWithWhereUniqueWithoutTeamidInput[]
    createMany?: team_playerCreateManyTeamidInputEnvelope
    set?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    disconnect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    delete?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    connect?: team_playerWhereUniqueInput | team_playerWhereUniqueInput[]
    update?: team_playerUpdateWithWhereUniqueWithoutTeamidInput | team_playerUpdateWithWhereUniqueWithoutTeamidInput[]
    updateMany?: team_playerUpdateManyWithWhereWithoutTeamidInput | team_playerUpdateManyWithWhereWithoutTeamidInput[]
    deleteMany?: team_playerScalarWhereInput | team_playerScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userCreateNestedOneWithoutPasswordhashInput = {
    create?: XOR<userCreateWithoutPasswordhashInput, userUncheckedCreateWithoutPasswordhashInput>
    connectOrCreate?: userCreateOrConnectWithoutPasswordhashInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutPasswordhashNestedInput = {
    create?: XOR<userCreateWithoutPasswordhashInput, userUncheckedCreateWithoutPasswordhashInput>
    connectOrCreate?: userCreateOrConnectWithoutPasswordhashInput
    upsert?: userUpsertWithoutPasswordhashInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPasswordhashInput, userUpdateWithoutPasswordhashInput>, userUncheckedUpdateWithoutPasswordhashInput>
  }

  export type permissionCreateNestedOneWithoutPermissionlogInput = {
    create?: XOR<permissionCreateWithoutPermissionlogInput, permissionUncheckedCreateWithoutPermissionlogInput>
    connectOrCreate?: permissionCreateOrConnectWithoutPermissionlogInput
    connect?: permissionWhereUniqueInput
  }

  export type permissionUpdateOneRequiredWithoutPermissionlogNestedInput = {
    create?: XOR<permissionCreateWithoutPermissionlogInput, permissionUncheckedCreateWithoutPermissionlogInput>
    connectOrCreate?: permissionCreateOrConnectWithoutPermissionlogInput
    upsert?: permissionUpsertWithoutPermissionlogInput
    connect?: permissionWhereUniqueInput
    update?: XOR<XOR<permissionUpdateToOneWithWhereWithoutPermissionlogInput, permissionUpdateWithoutPermissionlogInput>, permissionUncheckedUpdateWithoutPermissionlogInput>
  }

  export type userCreateNestedOneWithoutUserlogInput = {
    create?: XOR<userCreateWithoutUserlogInput, userUncheckedCreateWithoutUserlogInput>
    connectOrCreate?: userCreateOrConnectWithoutUserlogInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserlogNestedInput = {
    create?: XOR<userCreateWithoutUserlogInput, userUncheckedCreateWithoutUserlogInput>
    connectOrCreate?: userCreateOrConnectWithoutUserlogInput
    upsert?: userUpsertWithoutUserlogInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserlogInput, userUpdateWithoutUserlogInput>, userUncheckedUpdateWithoutUserlogInput>
  }

  export type userCreateNestedOneWithoutPermissionInput = {
    create?: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: userCreateOrConnectWithoutPermissionInput
    connect?: userWhereUniqueInput
  }

  export type permissionlogCreateNestedManyWithoutPermisionInput = {
    create?: XOR<permissionlogCreateWithoutPermisionInput, permissionlogUncheckedCreateWithoutPermisionInput> | permissionlogCreateWithoutPermisionInput[] | permissionlogUncheckedCreateWithoutPermisionInput[]
    connectOrCreate?: permissionlogCreateOrConnectWithoutPermisionInput | permissionlogCreateOrConnectWithoutPermisionInput[]
    createMany?: permissionlogCreateManyPermisionInputEnvelope
    connect?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
  }

  export type permissionlogUncheckedCreateNestedManyWithoutPermisionInput = {
    create?: XOR<permissionlogCreateWithoutPermisionInput, permissionlogUncheckedCreateWithoutPermisionInput> | permissionlogCreateWithoutPermisionInput[] | permissionlogUncheckedCreateWithoutPermisionInput[]
    connectOrCreate?: permissionlogCreateOrConnectWithoutPermisionInput | permissionlogCreateOrConnectWithoutPermisionInput[]
    createMany?: permissionlogCreateManyPermisionInputEnvelope
    connect?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutPermissionNestedInput = {
    create?: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: userCreateOrConnectWithoutPermissionInput
    upsert?: userUpsertWithoutPermissionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPermissionInput, userUpdateWithoutPermissionInput>, userUncheckedUpdateWithoutPermissionInput>
  }

  export type permissionlogUpdateManyWithoutPermisionNestedInput = {
    create?: XOR<permissionlogCreateWithoutPermisionInput, permissionlogUncheckedCreateWithoutPermisionInput> | permissionlogCreateWithoutPermisionInput[] | permissionlogUncheckedCreateWithoutPermisionInput[]
    connectOrCreate?: permissionlogCreateOrConnectWithoutPermisionInput | permissionlogCreateOrConnectWithoutPermisionInput[]
    upsert?: permissionlogUpsertWithWhereUniqueWithoutPermisionInput | permissionlogUpsertWithWhereUniqueWithoutPermisionInput[]
    createMany?: permissionlogCreateManyPermisionInputEnvelope
    set?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    disconnect?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    delete?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    connect?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    update?: permissionlogUpdateWithWhereUniqueWithoutPermisionInput | permissionlogUpdateWithWhereUniqueWithoutPermisionInput[]
    updateMany?: permissionlogUpdateManyWithWhereWithoutPermisionInput | permissionlogUpdateManyWithWhereWithoutPermisionInput[]
    deleteMany?: permissionlogScalarWhereInput | permissionlogScalarWhereInput[]
  }

  export type permissionlogUncheckedUpdateManyWithoutPermisionNestedInput = {
    create?: XOR<permissionlogCreateWithoutPermisionInput, permissionlogUncheckedCreateWithoutPermisionInput> | permissionlogCreateWithoutPermisionInput[] | permissionlogUncheckedCreateWithoutPermisionInput[]
    connectOrCreate?: permissionlogCreateOrConnectWithoutPermisionInput | permissionlogCreateOrConnectWithoutPermisionInput[]
    upsert?: permissionlogUpsertWithWhereUniqueWithoutPermisionInput | permissionlogUpsertWithWhereUniqueWithoutPermisionInput[]
    createMany?: permissionlogCreateManyPermisionInputEnvelope
    set?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    disconnect?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    delete?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    connect?: permissionlogWhereUniqueInput | permissionlogWhereUniqueInput[]
    update?: permissionlogUpdateWithWhereUniqueWithoutPermisionInput | permissionlogUpdateWithWhereUniqueWithoutPermisionInput[]
    updateMany?: permissionlogUpdateManyWithWhereWithoutPermisionInput | permissionlogUpdateManyWithWhereWithoutPermisionInput[]
    deleteMany?: permissionlogScalarWhereInput | permissionlogScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutProfileInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    upsert?: userUpsertWithoutProfileInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProfileInput, userUpdateWithoutProfileInput>, userUncheckedUpdateWithoutProfileInput>
  }

  export type userCreateNestedOneWithoutCookiesInput = {
    create?: XOR<userCreateWithoutCookiesInput, userUncheckedCreateWithoutCookiesInput>
    connectOrCreate?: userCreateOrConnectWithoutCookiesInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCookiesNestedInput = {
    create?: XOR<userCreateWithoutCookiesInput, userUncheckedCreateWithoutCookiesInput>
    connectOrCreate?: userCreateOrConnectWithoutCookiesInput
    upsert?: userUpsertWithoutCookiesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCookiesInput, userUpdateWithoutCookiesInput>, userUncheckedUpdateWithoutCookiesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumusecaseFilter<$PrismaModel = never> = {
    equals?: usecase | EnumusecaseFieldRefInput<$PrismaModel>
    in?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    notIn?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    not?: NestedEnumusecaseFilter<$PrismaModel> | usecase
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumusecaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: usecase | EnumusecaseFieldRefInput<$PrismaModel>
    in?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    notIn?: usecase[] | ListEnumusecaseFieldRefInput<$PrismaModel>
    not?: NestedEnumusecaseWithAggregatesFilter<$PrismaModel> | usecase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusecaseFilter<$PrismaModel>
    _max?: NestedEnumusecaseFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnummovementtypeFilter<$PrismaModel = never> = {
    equals?: movementtype | EnummovementtypeFieldRefInput<$PrismaModel>
    in?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    notIn?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    not?: NestedEnummovementtypeFilter<$PrismaModel> | movementtype
  }

  export type NestedEnummovementtypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: movementtype | EnummovementtypeFieldRefInput<$PrismaModel>
    in?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    notIn?: movementtype[] | ListEnummovementtypeFieldRefInput<$PrismaModel>
    not?: NestedEnummovementtypeWithAggregatesFilter<$PrismaModel> | movementtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummovementtypeFilter<$PrismaModel>
    _max?: NestedEnummovementtypeFilter<$PrismaModel>
  }

  export type NestedEnumtypecupFilter<$PrismaModel = never> = {
    equals?: typecup | EnumtypecupFieldRefInput<$PrismaModel>
    in?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    notIn?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    not?: NestedEnumtypecupFilter<$PrismaModel> | typecup
  }

  export type NestedEnumtypecupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: typecup | EnumtypecupFieldRefInput<$PrismaModel>
    in?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    notIn?: typecup[] | ListEnumtypecupFieldRefInput<$PrismaModel>
    not?: NestedEnumtypecupWithAggregatesFilter<$PrismaModel> | typecup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtypecupFilter<$PrismaModel>
    _max?: NestedEnumtypecupFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type passwordhashCreateWithoutUserInput = {
    hash: string
    salt: string
    createdat?: Date | string
  }

  export type passwordhashUncheckedCreateWithoutUserInput = {
    id?: number
    hash: string
    salt: string
    createdat?: Date | string
  }

  export type passwordhashCreateOrConnectWithoutUserInput = {
    where: passwordhashWhereUniqueInput
    create: XOR<passwordhashCreateWithoutUserInput, passwordhashUncheckedCreateWithoutUserInput>
  }

  export type cookieCreateWithoutUserInput = {
    value: string
    createdat?: Date | string
  }

  export type cookieUncheckedCreateWithoutUserInput = {
    id?: number
    value: string
    createdat?: Date | string
  }

  export type cookieCreateOrConnectWithoutUserInput = {
    where: cookieWhereUniqueInput
    create: XOR<cookieCreateWithoutUserInput, cookieUncheckedCreateWithoutUserInput>
  }

  export type cookieCreateManyUserInputEnvelope = {
    data: cookieCreateManyUserInput | cookieCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type permissionCreateWithoutPermissionInput = {
    name: string
    description: string
    createdat?: Date | string
    permissionlog?: permissionlogCreateNestedManyWithoutPermisionInput
  }

  export type permissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    name: string
    description: string
    createdat?: Date | string
    permissionlog?: permissionlogUncheckedCreateNestedManyWithoutPermisionInput
  }

  export type permissionCreateOrConnectWithoutPermissionInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutPermissionInput, permissionUncheckedCreateWithoutPermissionInput>
  }

  export type permissionCreateManyPermissionInputEnvelope = {
    data: permissionCreateManyPermissionInput | permissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type userlogCreateWithoutUserInput = {
    action: string
    createat?: Date | string
  }

  export type userlogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    createat?: Date | string
  }

  export type userlogCreateOrConnectWithoutUserInput = {
    where: userlogWhereUniqueInput
    create: XOR<userlogCreateWithoutUserInput, userlogUncheckedCreateWithoutUserInput>
  }

  export type userlogCreateManyUserInputEnvelope = {
    data: userlogCreateManyUserInput | userlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type walletCreateWithoutUserInput = {
    balance?: number
    createdat?: Date | string
    walletmovement?: walletmovementCreateNestedManyWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutUserInput = {
    id?: number
    balance?: number
    createdat?: Date | string
    walletmovement?: walletmovementUncheckedCreateNestedManyWithoutWalletInput
  }

  export type walletCreateOrConnectWithoutUserInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
  }

  export type productCreateWithoutUserInput = {
    name: string
    description: string
    price: number
    createdat?: Date | string
    orders?: orderCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    description: string
    price: number
    createdat?: Date | string
    orders?: orderUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutUserInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutUserInput, productUncheckedCreateWithoutUserInput>
  }

  export type productCreateManyUserInputEnvelope = {
    data: productCreateManyUserInput | productCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutUserInput = {
    quantity: number
    total: number
    createdat?: Date | string
    product: productCreateNestedOneWithoutOrdersInput
  }

  export type orderUncheckedCreateWithoutUserInput = {
    id?: number
    productid: number
    quantity: number
    total: number
    createdat?: Date | string
  }

  export type orderCreateOrConnectWithoutUserInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput>
  }

  export type orderCreateManyUserInputEnvelope = {
    data: orderCreateManyUserInput | orderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type users_profileCreateWithoutProfileInput = {
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
  }

  export type users_profileUncheckedCreateWithoutProfileInput = {
    id?: number
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
  }

  export type users_profileCreateOrConnectWithoutProfileInput = {
    where: users_profileWhereUniqueInput
    create: XOR<users_profileCreateWithoutProfileInput, users_profileUncheckedCreateWithoutProfileInput>
  }

  export type users_profileCreateManyProfileInputEnvelope = {
    data: users_profileCreateManyProfileInput | users_profileCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type passwordhashUpsertWithoutUserInput = {
    update: XOR<passwordhashUpdateWithoutUserInput, passwordhashUncheckedUpdateWithoutUserInput>
    create: XOR<passwordhashCreateWithoutUserInput, passwordhashUncheckedCreateWithoutUserInput>
    where?: passwordhashWhereInput
  }

  export type passwordhashUpdateToOneWithWhereWithoutUserInput = {
    where?: passwordhashWhereInput
    data: XOR<passwordhashUpdateWithoutUserInput, passwordhashUncheckedUpdateWithoutUserInput>
  }

  export type passwordhashUpdateWithoutUserInput = {
    hash?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type passwordhashUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cookieUpsertWithWhereUniqueWithoutUserInput = {
    where: cookieWhereUniqueInput
    update: XOR<cookieUpdateWithoutUserInput, cookieUncheckedUpdateWithoutUserInput>
    create: XOR<cookieCreateWithoutUserInput, cookieUncheckedCreateWithoutUserInput>
  }

  export type cookieUpdateWithWhereUniqueWithoutUserInput = {
    where: cookieWhereUniqueInput
    data: XOR<cookieUpdateWithoutUserInput, cookieUncheckedUpdateWithoutUserInput>
  }

  export type cookieUpdateManyWithWhereWithoutUserInput = {
    where: cookieScalarWhereInput
    data: XOR<cookieUpdateManyMutationInput, cookieUncheckedUpdateManyWithoutUserInput>
  }

  export type cookieScalarWhereInput = {
    AND?: cookieScalarWhereInput | cookieScalarWhereInput[]
    OR?: cookieScalarWhereInput[]
    NOT?: cookieScalarWhereInput | cookieScalarWhereInput[]
    id?: IntFilter<"cookie"> | number
    value?: StringFilter<"cookie"> | string
    userid?: IntFilter<"cookie"> | number
    createdat?: DateTimeFilter<"cookie"> | Date | string
  }

  export type permissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: permissionWhereUniqueInput
    update: XOR<permissionUpdateWithoutPermissionInput, permissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<permissionCreateWithoutPermissionInput, permissionUncheckedCreateWithoutPermissionInput>
  }

  export type permissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: permissionWhereUniqueInput
    data: XOR<permissionUpdateWithoutPermissionInput, permissionUncheckedUpdateWithoutPermissionInput>
  }

  export type permissionUpdateManyWithWhereWithoutPermissionInput = {
    where: permissionScalarWhereInput
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type permissionScalarWhereInput = {
    AND?: permissionScalarWhereInput | permissionScalarWhereInput[]
    OR?: permissionScalarWhereInput[]
    NOT?: permissionScalarWhereInput | permissionScalarWhereInput[]
    id?: IntFilter<"permission"> | number
    name?: StringFilter<"permission"> | string
    description?: StringFilter<"permission"> | string
    userid?: IntFilter<"permission"> | number
    createdat?: DateTimeFilter<"permission"> | Date | string
  }

  export type userlogUpsertWithWhereUniqueWithoutUserInput = {
    where: userlogWhereUniqueInput
    update: XOR<userlogUpdateWithoutUserInput, userlogUncheckedUpdateWithoutUserInput>
    create: XOR<userlogCreateWithoutUserInput, userlogUncheckedCreateWithoutUserInput>
  }

  export type userlogUpdateWithWhereUniqueWithoutUserInput = {
    where: userlogWhereUniqueInput
    data: XOR<userlogUpdateWithoutUserInput, userlogUncheckedUpdateWithoutUserInput>
  }

  export type userlogUpdateManyWithWhereWithoutUserInput = {
    where: userlogScalarWhereInput
    data: XOR<userlogUpdateManyMutationInput, userlogUncheckedUpdateManyWithoutUserInput>
  }

  export type userlogScalarWhereInput = {
    AND?: userlogScalarWhereInput | userlogScalarWhereInput[]
    OR?: userlogScalarWhereInput[]
    NOT?: userlogScalarWhereInput | userlogScalarWhereInput[]
    id?: IntFilter<"userlog"> | number
    userid?: IntFilter<"userlog"> | number
    action?: StringFilter<"userlog"> | string
    createat?: DateTimeFilter<"userlog"> | Date | string
  }

  export type walletUpsertWithoutUserInput = {
    update: XOR<walletUpdateWithoutUserInput, walletUncheckedUpdateWithoutUserInput>
    create: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutUserInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutUserInput, walletUncheckedUpdateWithoutUserInput>
  }

  export type walletUpdateWithoutUserInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    walletmovement?: walletmovementUpdateManyWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    walletmovement?: walletmovementUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type productUpsertWithWhereUniqueWithoutUserInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutUserInput, productUncheckedUpdateWithoutUserInput>
    create: XOR<productCreateWithoutUserInput, productUncheckedCreateWithoutUserInput>
  }

  export type productUpdateWithWhereUniqueWithoutUserInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutUserInput, productUncheckedUpdateWithoutUserInput>
  }

  export type productUpdateManyWithWhereWithoutUserInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutUserInput>
  }

  export type productScalarWhereInput = {
    AND?: productScalarWhereInput | productScalarWhereInput[]
    OR?: productScalarWhereInput[]
    NOT?: productScalarWhereInput | productScalarWhereInput[]
    id?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    description?: StringFilter<"product"> | string
    price?: FloatFilter<"product"> | number
    userid?: IntFilter<"product"> | number
    createdat?: DateTimeFilter<"product"> | Date | string
  }

  export type orderUpsertWithWhereUniqueWithoutUserInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutUserInput, orderUncheckedUpdateWithoutUserInput>
    create: XOR<orderCreateWithoutUserInput, orderUncheckedCreateWithoutUserInput>
  }

  export type orderUpdateWithWhereUniqueWithoutUserInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutUserInput, orderUncheckedUpdateWithoutUserInput>
  }

  export type orderUpdateManyWithWhereWithoutUserInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutUserInput>
  }

  export type orderScalarWhereInput = {
    AND?: orderScalarWhereInput | orderScalarWhereInput[]
    OR?: orderScalarWhereInput[]
    NOT?: orderScalarWhereInput | orderScalarWhereInput[]
    id?: IntFilter<"order"> | number
    productid?: IntFilter<"order"> | number
    userid?: IntFilter<"order"> | number
    quantity?: IntFilter<"order"> | number
    total?: FloatFilter<"order"> | number
    createdat?: DateTimeFilter<"order"> | Date | string
  }

  export type users_profileUpsertWithWhereUniqueWithoutProfileInput = {
    where: users_profileWhereUniqueInput
    update: XOR<users_profileUpdateWithoutProfileInput, users_profileUncheckedUpdateWithoutProfileInput>
    create: XOR<users_profileCreateWithoutProfileInput, users_profileUncheckedCreateWithoutProfileInput>
  }

  export type users_profileUpdateWithWhereUniqueWithoutProfileInput = {
    where: users_profileWhereUniqueInput
    data: XOR<users_profileUpdateWithoutProfileInput, users_profileUncheckedUpdateWithoutProfileInput>
  }

  export type users_profileUpdateManyWithWhereWithoutProfileInput = {
    where: users_profileScalarWhereInput
    data: XOR<users_profileUpdateManyMutationInput, users_profileUncheckedUpdateManyWithoutProfileInput>
  }

  export type users_profileScalarWhereInput = {
    AND?: users_profileScalarWhereInput | users_profileScalarWhereInput[]
    OR?: users_profileScalarWhereInput[]
    NOT?: users_profileScalarWhereInput | users_profileScalarWhereInput[]
    id?: IntFilter<"users_profile"> | number
    name?: StringFilter<"users_profile"> | string
    lastname?: StringFilter<"users_profile"> | string
    street?: StringFilter<"users_profile"> | string
    phone_number?: StringFilter<"users_profile"> | string
    number_address?: IntFilter<"users_profile"> | number
    neigh?: StringFilter<"users_profile"> | string
    userid?: IntFilter<"users_profile"> | number
  }

  export type league_teamsCreateWithoutStatistics_teamInput = {
    leagues: leaguesCreateNestedOneWithoutLeague_teamsInput
    teamid: teamCreateNestedOneWithoutLeague_teamsInput
  }

  export type league_teamsUncheckedCreateWithoutStatistics_teamInput = {
    id?: number
    league_id: number
    team_id: number
  }

  export type league_teamsCreateOrConnectWithoutStatistics_teamInput = {
    where: league_teamsWhereUniqueInput
    create: XOR<league_teamsCreateWithoutStatistics_teamInput, league_teamsUncheckedCreateWithoutStatistics_teamInput>
  }

  export type league_teamsUpsertWithoutStatistics_teamInput = {
    update: XOR<league_teamsUpdateWithoutStatistics_teamInput, league_teamsUncheckedUpdateWithoutStatistics_teamInput>
    create: XOR<league_teamsCreateWithoutStatistics_teamInput, league_teamsUncheckedCreateWithoutStatistics_teamInput>
    where?: league_teamsWhereInput
  }

  export type league_teamsUpdateToOneWithWhereWithoutStatistics_teamInput = {
    where?: league_teamsWhereInput
    data: XOR<league_teamsUpdateWithoutStatistics_teamInput, league_teamsUncheckedUpdateWithoutStatistics_teamInput>
  }

  export type league_teamsUpdateWithoutStatistics_teamInput = {
    leagues?: leaguesUpdateOneRequiredWithoutLeague_teamsNestedInput
    teamid?: teamUpdateOneRequiredWithoutLeague_teamsNestedInput
  }

  export type league_teamsUncheckedUpdateWithoutStatistics_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    league_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
  }

  export type team_playerCreateWithoutPlayeridInput = {
    teamid: teamCreateNestedOneWithoutPlayer_teamInput
  }

  export type team_playerUncheckedCreateWithoutPlayeridInput = {
    id?: number
    team_id: number
  }

  export type team_playerCreateOrConnectWithoutPlayeridInput = {
    where: team_playerWhereUniqueInput
    create: XOR<team_playerCreateWithoutPlayeridInput, team_playerUncheckedCreateWithoutPlayeridInput>
  }

  export type team_playerCreateManyPlayeridInputEnvelope = {
    data: team_playerCreateManyPlayeridInput | team_playerCreateManyPlayeridInput[]
    skipDuplicates?: boolean
  }

  export type team_playerUpsertWithWhereUniqueWithoutPlayeridInput = {
    where: team_playerWhereUniqueInput
    update: XOR<team_playerUpdateWithoutPlayeridInput, team_playerUncheckedUpdateWithoutPlayeridInput>
    create: XOR<team_playerCreateWithoutPlayeridInput, team_playerUncheckedCreateWithoutPlayeridInput>
  }

  export type team_playerUpdateWithWhereUniqueWithoutPlayeridInput = {
    where: team_playerWhereUniqueInput
    data: XOR<team_playerUpdateWithoutPlayeridInput, team_playerUncheckedUpdateWithoutPlayeridInput>
  }

  export type team_playerUpdateManyWithWhereWithoutPlayeridInput = {
    where: team_playerScalarWhereInput
    data: XOR<team_playerUpdateManyMutationInput, team_playerUncheckedUpdateManyWithoutPlayeridInput>
  }

  export type team_playerScalarWhereInput = {
    AND?: team_playerScalarWhereInput | team_playerScalarWhereInput[]
    OR?: team_playerScalarWhereInput[]
    NOT?: team_playerScalarWhereInput | team_playerScalarWhereInput[]
    id?: IntFilter<"team_player"> | number
    team_id?: IntFilter<"team_player"> | number
    player_id?: IntFilter<"team_player"> | number
  }

  export type teamCreateWithoutPlayer_teamInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsCreateNestedManyWithoutTeamidInput
  }

  export type teamUncheckedCreateWithoutPlayer_teamInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsUncheckedCreateNestedManyWithoutTeamidInput
  }

  export type teamCreateOrConnectWithoutPlayer_teamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutPlayer_teamInput, teamUncheckedCreateWithoutPlayer_teamInput>
  }

  export type football_playersCreateWithoutTeam_playerInput = {
    name: string
    lastname: string
    age: number
    birth: JsonNullValueInput | InputJsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: JsonNullValueInput | InputJsonValue
  }

  export type football_playersUncheckedCreateWithoutTeam_playerInput = {
    id?: number
    name: string
    lastname: string
    age: number
    birth: JsonNullValueInput | InputJsonValue
    nationality: string
    height: string
    weight: string
    injured: boolean
    photo: string
    statistics: JsonNullValueInput | InputJsonValue
  }

  export type football_playersCreateOrConnectWithoutTeam_playerInput = {
    where: football_playersWhereUniqueInput
    create: XOR<football_playersCreateWithoutTeam_playerInput, football_playersUncheckedCreateWithoutTeam_playerInput>
  }

  export type teamUpsertWithoutPlayer_teamInput = {
    update: XOR<teamUpdateWithoutPlayer_teamInput, teamUncheckedUpdateWithoutPlayer_teamInput>
    create: XOR<teamCreateWithoutPlayer_teamInput, teamUncheckedCreateWithoutPlayer_teamInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutPlayer_teamInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutPlayer_teamInput, teamUncheckedUpdateWithoutPlayer_teamInput>
  }

  export type teamUpdateWithoutPlayer_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsUpdateManyWithoutTeamidNestedInput
  }

  export type teamUncheckedUpdateWithoutPlayer_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
    league_teams?: league_teamsUncheckedUpdateManyWithoutTeamidNestedInput
  }

  export type football_playersUpsertWithoutTeam_playerInput = {
    update: XOR<football_playersUpdateWithoutTeam_playerInput, football_playersUncheckedUpdateWithoutTeam_playerInput>
    create: XOR<football_playersCreateWithoutTeam_playerInput, football_playersUncheckedCreateWithoutTeam_playerInput>
    where?: football_playersWhereInput
  }

  export type football_playersUpdateToOneWithWhereWithoutTeam_playerInput = {
    where?: football_playersWhereInput
    data: XOR<football_playersUpdateWithoutTeam_playerInput, football_playersUncheckedUpdateWithoutTeam_playerInput>
  }

  export type football_playersUpdateWithoutTeam_playerInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    birth?: JsonNullValueInput | InputJsonValue
    nationality?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    injured?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    statistics?: JsonNullValueInput | InputJsonValue
  }

  export type football_playersUncheckedUpdateWithoutTeam_playerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    birth?: JsonNullValueInput | InputJsonValue
    nationality?: StringFieldUpdateOperationsInput | string
    height?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    injured?: BoolFieldUpdateOperationsInput | boolean
    photo?: StringFieldUpdateOperationsInput | string
    statistics?: JsonNullValueInput | InputJsonValue
  }

  export type userCreateWithoutProductInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutProductInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutProductInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProductInput, userUncheckedCreateWithoutProductInput>
  }

  export type orderCreateWithoutProductInput = {
    quantity: number
    total: number
    createdat?: Date | string
    user: userCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutProductInput = {
    id?: number
    userid: number
    quantity: number
    total: number
    createdat?: Date | string
  }

  export type orderCreateOrConnectWithoutProductInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutProductInput, orderUncheckedCreateWithoutProductInput>
  }

  export type orderCreateManyProductInputEnvelope = {
    data: orderCreateManyProductInput | orderCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutProductInput = {
    update: XOR<userUpdateWithoutProductInput, userUncheckedUpdateWithoutProductInput>
    create: XOR<userCreateWithoutProductInput, userUncheckedCreateWithoutProductInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProductInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProductInput, userUncheckedUpdateWithoutProductInput>
  }

  export type userUpdateWithoutProductInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type orderUpsertWithWhereUniqueWithoutProductInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutProductInput, orderUncheckedUpdateWithoutProductInput>
    create: XOR<orderCreateWithoutProductInput, orderUncheckedCreateWithoutProductInput>
  }

  export type orderUpdateWithWhereUniqueWithoutProductInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutProductInput, orderUncheckedUpdateWithoutProductInput>
  }

  export type orderUpdateManyWithWhereWithoutProductInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutProductInput>
  }

  export type productCreateWithoutOrdersInput = {
    name: string
    description: string
    price: number
    createdat?: Date | string
    user: userCreateNestedOneWithoutProductInput
  }

  export type productUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    description: string
    price: number
    userid: number
    createdat?: Date | string
  }

  export type productCreateOrConnectWithoutOrdersInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutOrdersInput, productUncheckedCreateWithoutOrdersInput>
  }

  export type userCreateWithoutOrderInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutOrderInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutOrderInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
  }

  export type productUpsertWithoutOrdersInput = {
    update: XOR<productUpdateWithoutOrdersInput, productUncheckedUpdateWithoutOrdersInput>
    create: XOR<productCreateWithoutOrdersInput, productUncheckedCreateWithoutOrdersInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutOrdersInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutOrdersInput, productUncheckedUpdateWithoutOrdersInput>
  }

  export type productUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutOrderInput = {
    update: XOR<userUpdateWithoutOrderInput, userUncheckedUpdateWithoutOrderInput>
    create: XOR<userCreateWithoutOrderInput, userUncheckedCreateWithoutOrderInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOrderInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOrderInput, userUncheckedUpdateWithoutOrderInput>
  }

  export type userUpdateWithoutOrderInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type userCreateWithoutWalletInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutWalletInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutWalletInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
  }

  export type walletmovementCreateWithoutWalletInput = {
    amount: number
    movementtype: movementtype
    createdat?: Date | string
  }

  export type walletmovementUncheckedCreateWithoutWalletInput = {
    id?: number
    amount: number
    movementtype: movementtype
    createdat?: Date | string
  }

  export type walletmovementCreateOrConnectWithoutWalletInput = {
    where: walletmovementWhereUniqueInput
    create: XOR<walletmovementCreateWithoutWalletInput, walletmovementUncheckedCreateWithoutWalletInput>
  }

  export type walletmovementCreateManyWalletInputEnvelope = {
    data: walletmovementCreateManyWalletInput | walletmovementCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutWalletInput = {
    update: XOR<userUpdateWithoutWalletInput, userUncheckedUpdateWithoutWalletInput>
    create: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutWalletInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutWalletInput, userUncheckedUpdateWithoutWalletInput>
  }

  export type userUpdateWithoutWalletInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type walletmovementUpsertWithWhereUniqueWithoutWalletInput = {
    where: walletmovementWhereUniqueInput
    update: XOR<walletmovementUpdateWithoutWalletInput, walletmovementUncheckedUpdateWithoutWalletInput>
    create: XOR<walletmovementCreateWithoutWalletInput, walletmovementUncheckedCreateWithoutWalletInput>
  }

  export type walletmovementUpdateWithWhereUniqueWithoutWalletInput = {
    where: walletmovementWhereUniqueInput
    data: XOR<walletmovementUpdateWithoutWalletInput, walletmovementUncheckedUpdateWithoutWalletInput>
  }

  export type walletmovementUpdateManyWithWhereWithoutWalletInput = {
    where: walletmovementScalarWhereInput
    data: XOR<walletmovementUpdateManyMutationInput, walletmovementUncheckedUpdateManyWithoutWalletInput>
  }

  export type walletmovementScalarWhereInput = {
    AND?: walletmovementScalarWhereInput | walletmovementScalarWhereInput[]
    OR?: walletmovementScalarWhereInput[]
    NOT?: walletmovementScalarWhereInput | walletmovementScalarWhereInput[]
    id?: IntFilter<"walletmovement"> | number
    walletid?: IntFilter<"walletmovement"> | number
    amount?: FloatFilter<"walletmovement"> | number
    movementtype?: EnummovementtypeFilter<"walletmovement"> | movementtype
    createdat?: DateTimeFilter<"walletmovement"> | Date | string
  }

  export type walletCreateWithoutWalletmovementInput = {
    balance?: number
    createdat?: Date | string
    user: userCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutWalletmovementInput = {
    id?: number
    balance?: number
    userid: number
    createdat?: Date | string
  }

  export type walletCreateOrConnectWithoutWalletmovementInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutWalletmovementInput, walletUncheckedCreateWithoutWalletmovementInput>
  }

  export type walletUpsertWithoutWalletmovementInput = {
    update: XOR<walletUpdateWithoutWalletmovementInput, walletUncheckedUpdateWithoutWalletmovementInput>
    create: XOR<walletCreateWithoutWalletmovementInput, walletUncheckedCreateWithoutWalletmovementInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutWalletmovementInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutWalletmovementInput, walletUncheckedUpdateWithoutWalletmovementInput>
  }

  export type walletUpdateWithoutWalletmovementInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutWalletmovementInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type league_teamsCreateWithoutLeaguesInput = {
    teamid: teamCreateNestedOneWithoutLeague_teamsInput
    statistics_team?: statistics_teamCreateNestedManyWithoutLeague_teamidInput
  }

  export type league_teamsUncheckedCreateWithoutLeaguesInput = {
    id?: number
    team_id: number
    statistics_team?: statistics_teamUncheckedCreateNestedManyWithoutLeague_teamidInput
  }

  export type league_teamsCreateOrConnectWithoutLeaguesInput = {
    where: league_teamsWhereUniqueInput
    create: XOR<league_teamsCreateWithoutLeaguesInput, league_teamsUncheckedCreateWithoutLeaguesInput>
  }

  export type league_teamsCreateManyLeaguesInputEnvelope = {
    data: league_teamsCreateManyLeaguesInput | league_teamsCreateManyLeaguesInput[]
    skipDuplicates?: boolean
  }

  export type league_teamsUpsertWithWhereUniqueWithoutLeaguesInput = {
    where: league_teamsWhereUniqueInput
    update: XOR<league_teamsUpdateWithoutLeaguesInput, league_teamsUncheckedUpdateWithoutLeaguesInput>
    create: XOR<league_teamsCreateWithoutLeaguesInput, league_teamsUncheckedCreateWithoutLeaguesInput>
  }

  export type league_teamsUpdateWithWhereUniqueWithoutLeaguesInput = {
    where: league_teamsWhereUniqueInput
    data: XOR<league_teamsUpdateWithoutLeaguesInput, league_teamsUncheckedUpdateWithoutLeaguesInput>
  }

  export type league_teamsUpdateManyWithWhereWithoutLeaguesInput = {
    where: league_teamsScalarWhereInput
    data: XOR<league_teamsUpdateManyMutationInput, league_teamsUncheckedUpdateManyWithoutLeaguesInput>
  }

  export type league_teamsScalarWhereInput = {
    AND?: league_teamsScalarWhereInput | league_teamsScalarWhereInput[]
    OR?: league_teamsScalarWhereInput[]
    NOT?: league_teamsScalarWhereInput | league_teamsScalarWhereInput[]
    id?: IntFilter<"league_teams"> | number
    league_id?: IntFilter<"league_teams"> | number
    team_id?: IntFilter<"league_teams"> | number
  }

  export type leaguesCreateWithoutLeague_teamsInput = {
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
  }

  export type leaguesUncheckedCreateWithoutLeague_teamsInput = {
    id: number
    name: string
    cup: typecup
    country: string
    code: string
    flag: string
  }

  export type leaguesCreateOrConnectWithoutLeague_teamsInput = {
    where: leaguesWhereUniqueInput
    create: XOR<leaguesCreateWithoutLeague_teamsInput, leaguesUncheckedCreateWithoutLeague_teamsInput>
  }

  export type teamCreateWithoutLeague_teamsInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
    player_team?: team_playerCreateNestedManyWithoutTeamidInput
  }

  export type teamUncheckedCreateWithoutLeague_teamsInput = {
    id: number
    name: string
    code: string
    founded: number
    national: boolean
    logo: string
    venues: JsonNullValueInput | InputJsonValue
    player_team?: team_playerUncheckedCreateNestedManyWithoutTeamidInput
  }

  export type teamCreateOrConnectWithoutLeague_teamsInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutLeague_teamsInput, teamUncheckedCreateWithoutLeague_teamsInput>
  }

  export type statistics_teamCreateWithoutLeague_teamidInput = {
    fixtures: JsonNullValueInput | InputJsonValue
    biggest: JsonNullValueInput | InputJsonValue
    goals: JsonNullValueInput | InputJsonValue
    clean_sheet: JsonNullValueInput | InputJsonValue
    failed_to_score: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
    lineups: JsonNullValueInput | InputJsonValue
    cards: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUncheckedCreateWithoutLeague_teamidInput = {
    fixtures: JsonNullValueInput | InputJsonValue
    biggest: JsonNullValueInput | InputJsonValue
    goals: JsonNullValueInput | InputJsonValue
    clean_sheet: JsonNullValueInput | InputJsonValue
    failed_to_score: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
    lineups: JsonNullValueInput | InputJsonValue
    cards: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamCreateOrConnectWithoutLeague_teamidInput = {
    where: statistics_teamWhereUniqueInput
    create: XOR<statistics_teamCreateWithoutLeague_teamidInput, statistics_teamUncheckedCreateWithoutLeague_teamidInput>
  }

  export type statistics_teamCreateManyLeague_teamidInputEnvelope = {
    data: statistics_teamCreateManyLeague_teamidInput | statistics_teamCreateManyLeague_teamidInput[]
    skipDuplicates?: boolean
  }

  export type leaguesUpsertWithoutLeague_teamsInput = {
    update: XOR<leaguesUpdateWithoutLeague_teamsInput, leaguesUncheckedUpdateWithoutLeague_teamsInput>
    create: XOR<leaguesCreateWithoutLeague_teamsInput, leaguesUncheckedCreateWithoutLeague_teamsInput>
    where?: leaguesWhereInput
  }

  export type leaguesUpdateToOneWithWhereWithoutLeague_teamsInput = {
    where?: leaguesWhereInput
    data: XOR<leaguesUpdateWithoutLeague_teamsInput, leaguesUncheckedUpdateWithoutLeague_teamsInput>
  }

  export type leaguesUpdateWithoutLeague_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cup?: EnumtypecupFieldUpdateOperationsInput | typecup
    country?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type leaguesUncheckedUpdateWithoutLeague_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cup?: EnumtypecupFieldUpdateOperationsInput | typecup
    country?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    flag?: StringFieldUpdateOperationsInput | string
  }

  export type teamUpsertWithoutLeague_teamsInput = {
    update: XOR<teamUpdateWithoutLeague_teamsInput, teamUncheckedUpdateWithoutLeague_teamsInput>
    create: XOR<teamCreateWithoutLeague_teamsInput, teamUncheckedCreateWithoutLeague_teamsInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutLeague_teamsInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutLeague_teamsInput, teamUncheckedUpdateWithoutLeague_teamsInput>
  }

  export type teamUpdateWithoutLeague_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
    player_team?: team_playerUpdateManyWithoutTeamidNestedInput
  }

  export type teamUncheckedUpdateWithoutLeague_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    founded?: IntFieldUpdateOperationsInput | number
    national?: BoolFieldUpdateOperationsInput | boolean
    logo?: StringFieldUpdateOperationsInput | string
    venues?: JsonNullValueInput | InputJsonValue
    player_team?: team_playerUncheckedUpdateManyWithoutTeamidNestedInput
  }

  export type statistics_teamUpsertWithWhereUniqueWithoutLeague_teamidInput = {
    where: statistics_teamWhereUniqueInput
    update: XOR<statistics_teamUpdateWithoutLeague_teamidInput, statistics_teamUncheckedUpdateWithoutLeague_teamidInput>
    create: XOR<statistics_teamCreateWithoutLeague_teamidInput, statistics_teamUncheckedCreateWithoutLeague_teamidInput>
  }

  export type statistics_teamUpdateWithWhereUniqueWithoutLeague_teamidInput = {
    where: statistics_teamWhereUniqueInput
    data: XOR<statistics_teamUpdateWithoutLeague_teamidInput, statistics_teamUncheckedUpdateWithoutLeague_teamidInput>
  }

  export type statistics_teamUpdateManyWithWhereWithoutLeague_teamidInput = {
    where: statistics_teamScalarWhereInput
    data: XOR<statistics_teamUpdateManyMutationInput, statistics_teamUncheckedUpdateManyWithoutLeague_teamidInput>
  }

  export type statistics_teamScalarWhereInput = {
    AND?: statistics_teamScalarWhereInput | statistics_teamScalarWhereInput[]
    OR?: statistics_teamScalarWhereInput[]
    NOT?: statistics_teamScalarWhereInput | statistics_teamScalarWhereInput[]
    league_team_id?: IntFilter<"statistics_team"> | number
    fixtures?: JsonFilter<"statistics_team">
    biggest?: JsonFilter<"statistics_team">
    goals?: JsonFilter<"statistics_team">
    clean_sheet?: JsonFilter<"statistics_team">
    failed_to_score?: JsonFilter<"statistics_team">
    penalty?: JsonFilter<"statistics_team">
    lineups?: JsonFilter<"statistics_team">
    cards?: JsonFilter<"statistics_team">
  }

  export type league_teamsCreateWithoutTeamidInput = {
    leagues: leaguesCreateNestedOneWithoutLeague_teamsInput
    statistics_team?: statistics_teamCreateNestedManyWithoutLeague_teamidInput
  }

  export type league_teamsUncheckedCreateWithoutTeamidInput = {
    id?: number
    league_id: number
    statistics_team?: statistics_teamUncheckedCreateNestedManyWithoutLeague_teamidInput
  }

  export type league_teamsCreateOrConnectWithoutTeamidInput = {
    where: league_teamsWhereUniqueInput
    create: XOR<league_teamsCreateWithoutTeamidInput, league_teamsUncheckedCreateWithoutTeamidInput>
  }

  export type league_teamsCreateManyTeamidInputEnvelope = {
    data: league_teamsCreateManyTeamidInput | league_teamsCreateManyTeamidInput[]
    skipDuplicates?: boolean
  }

  export type team_playerCreateWithoutTeamidInput = {
    playerid: football_playersCreateNestedOneWithoutTeam_playerInput
  }

  export type team_playerUncheckedCreateWithoutTeamidInput = {
    id?: number
    player_id: number
  }

  export type team_playerCreateOrConnectWithoutTeamidInput = {
    where: team_playerWhereUniqueInput
    create: XOR<team_playerCreateWithoutTeamidInput, team_playerUncheckedCreateWithoutTeamidInput>
  }

  export type team_playerCreateManyTeamidInputEnvelope = {
    data: team_playerCreateManyTeamidInput | team_playerCreateManyTeamidInput[]
    skipDuplicates?: boolean
  }

  export type league_teamsUpsertWithWhereUniqueWithoutTeamidInput = {
    where: league_teamsWhereUniqueInput
    update: XOR<league_teamsUpdateWithoutTeamidInput, league_teamsUncheckedUpdateWithoutTeamidInput>
    create: XOR<league_teamsCreateWithoutTeamidInput, league_teamsUncheckedCreateWithoutTeamidInput>
  }

  export type league_teamsUpdateWithWhereUniqueWithoutTeamidInput = {
    where: league_teamsWhereUniqueInput
    data: XOR<league_teamsUpdateWithoutTeamidInput, league_teamsUncheckedUpdateWithoutTeamidInput>
  }

  export type league_teamsUpdateManyWithWhereWithoutTeamidInput = {
    where: league_teamsScalarWhereInput
    data: XOR<league_teamsUpdateManyMutationInput, league_teamsUncheckedUpdateManyWithoutTeamidInput>
  }

  export type team_playerUpsertWithWhereUniqueWithoutTeamidInput = {
    where: team_playerWhereUniqueInput
    update: XOR<team_playerUpdateWithoutTeamidInput, team_playerUncheckedUpdateWithoutTeamidInput>
    create: XOR<team_playerCreateWithoutTeamidInput, team_playerUncheckedCreateWithoutTeamidInput>
  }

  export type team_playerUpdateWithWhereUniqueWithoutTeamidInput = {
    where: team_playerWhereUniqueInput
    data: XOR<team_playerUpdateWithoutTeamidInput, team_playerUncheckedUpdateWithoutTeamidInput>
  }

  export type team_playerUpdateManyWithWhereWithoutTeamidInput = {
    where: team_playerScalarWhereInput
    data: XOR<team_playerUpdateManyMutationInput, team_playerUncheckedUpdateManyWithoutTeamidInput>
  }

  export type userCreateWithoutPasswordhashInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutPasswordhashInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutPasswordhashInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPasswordhashInput, userUncheckedCreateWithoutPasswordhashInput>
  }

  export type userUpsertWithoutPasswordhashInput = {
    update: XOR<userUpdateWithoutPasswordhashInput, userUncheckedUpdateWithoutPasswordhashInput>
    create: XOR<userCreateWithoutPasswordhashInput, userUncheckedCreateWithoutPasswordhashInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPasswordhashInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPasswordhashInput, userUncheckedUpdateWithoutPasswordhashInput>
  }

  export type userUpdateWithoutPasswordhashInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutPasswordhashInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type permissionCreateWithoutPermissionlogInput = {
    name: string
    description: string
    createdat?: Date | string
    permission: userCreateNestedOneWithoutPermissionInput
  }

  export type permissionUncheckedCreateWithoutPermissionlogInput = {
    id?: number
    name: string
    description: string
    userid: number
    createdat?: Date | string
  }

  export type permissionCreateOrConnectWithoutPermissionlogInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutPermissionlogInput, permissionUncheckedCreateWithoutPermissionlogInput>
  }

  export type permissionUpsertWithoutPermissionlogInput = {
    update: XOR<permissionUpdateWithoutPermissionlogInput, permissionUncheckedUpdateWithoutPermissionlogInput>
    create: XOR<permissionCreateWithoutPermissionlogInput, permissionUncheckedCreateWithoutPermissionlogInput>
    where?: permissionWhereInput
  }

  export type permissionUpdateToOneWithWhereWithoutPermissionlogInput = {
    where?: permissionWhereInput
    data: XOR<permissionUpdateWithoutPermissionlogInput, permissionUncheckedUpdateWithoutPermissionlogInput>
  }

  export type permissionUpdateWithoutPermissionlogInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: userUpdateOneRequiredWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateWithoutPermissionlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateWithoutUserlogInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutUserlogInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutUserlogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserlogInput, userUncheckedCreateWithoutUserlogInput>
  }

  export type userUpsertWithoutUserlogInput = {
    update: XOR<userUpdateWithoutUserlogInput, userUncheckedUpdateWithoutUserlogInput>
    create: XOR<userCreateWithoutUserlogInput, userUncheckedCreateWithoutUserlogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserlogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserlogInput, userUncheckedUpdateWithoutUserlogInput>
  }

  export type userUpdateWithoutUserlogInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutUserlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type userCreateWithoutPermissionInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutPermissionInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutPermissionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
  }

  export type permissionlogCreateWithoutPermisionInput = {
    action: string
    createdat?: Date | string
  }

  export type permissionlogUncheckedCreateWithoutPermisionInput = {
    id?: number
    action: string
    createdat?: Date | string
  }

  export type permissionlogCreateOrConnectWithoutPermisionInput = {
    where: permissionlogWhereUniqueInput
    create: XOR<permissionlogCreateWithoutPermisionInput, permissionlogUncheckedCreateWithoutPermisionInput>
  }

  export type permissionlogCreateManyPermisionInputEnvelope = {
    data: permissionlogCreateManyPermisionInput | permissionlogCreateManyPermisionInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutPermissionInput = {
    update: XOR<userUpdateWithoutPermissionInput, userUncheckedUpdateWithoutPermissionInput>
    create: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPermissionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPermissionInput, userUncheckedUpdateWithoutPermissionInput>
  }

  export type userUpdateWithoutPermissionInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type permissionlogUpsertWithWhereUniqueWithoutPermisionInput = {
    where: permissionlogWhereUniqueInput
    update: XOR<permissionlogUpdateWithoutPermisionInput, permissionlogUncheckedUpdateWithoutPermisionInput>
    create: XOR<permissionlogCreateWithoutPermisionInput, permissionlogUncheckedCreateWithoutPermisionInput>
  }

  export type permissionlogUpdateWithWhereUniqueWithoutPermisionInput = {
    where: permissionlogWhereUniqueInput
    data: XOR<permissionlogUpdateWithoutPermisionInput, permissionlogUncheckedUpdateWithoutPermisionInput>
  }

  export type permissionlogUpdateManyWithWhereWithoutPermisionInput = {
    where: permissionlogScalarWhereInput
    data: XOR<permissionlogUpdateManyMutationInput, permissionlogUncheckedUpdateManyWithoutPermisionInput>
  }

  export type permissionlogScalarWhereInput = {
    AND?: permissionlogScalarWhereInput | permissionlogScalarWhereInput[]
    OR?: permissionlogScalarWhereInput[]
    NOT?: permissionlogScalarWhereInput | permissionlogScalarWhereInput[]
    id?: IntFilter<"permissionlog"> | number
    permissionid?: IntFilter<"permissionlog"> | number
    action?: StringFilter<"permissionlog"> | string
    createdat?: DateTimeFilter<"permissionlog"> | Date | string
  }

  export type userCreateWithoutProfileInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    cookies?: cookieCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfileInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    cookies?: cookieUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfileInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type userUpsertWithoutProfileInput = {
    update: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProfileInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateWithoutProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    cookies?: cookieUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    cookies?: cookieUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCookiesInput = {
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashCreateNestedOneWithoutUserInput
    permission?: permissionCreateNestedManyWithoutPermissionInput
    userlog?: userlogCreateNestedManyWithoutUserInput
    wallet?: walletCreateNestedOneWithoutUserInput
    product?: productCreateNestedManyWithoutUserInput
    order?: orderCreateNestedManyWithoutUserInput
    profile?: users_profileCreateNestedManyWithoutProfileInput
  }

  export type userUncheckedCreateWithoutCookiesInput = {
    id?: number
    username: string
    email: string
    usecase?: usecase
    createdat?: Date | string
    passwordhash?: passwordhashUncheckedCreateNestedOneWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutPermissionInput
    userlog?: userlogUncheckedCreateNestedManyWithoutUserInput
    wallet?: walletUncheckedCreateNestedOneWithoutUserInput
    product?: productUncheckedCreateNestedManyWithoutUserInput
    order?: orderUncheckedCreateNestedManyWithoutUserInput
    profile?: users_profileUncheckedCreateNestedManyWithoutProfileInput
  }

  export type userCreateOrConnectWithoutCookiesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCookiesInput, userUncheckedCreateWithoutCookiesInput>
  }

  export type userUpsertWithoutCookiesInput = {
    update: XOR<userUpdateWithoutCookiesInput, userUncheckedUpdateWithoutCookiesInput>
    create: XOR<userCreateWithoutCookiesInput, userUncheckedCreateWithoutCookiesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCookiesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCookiesInput, userUncheckedUpdateWithoutCookiesInput>
  }

  export type userUpdateWithoutCookiesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUpdateOneWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneWithoutUserNestedInput
    product?: productUpdateManyWithoutUserNestedInput
    order?: orderUpdateManyWithoutUserNestedInput
    profile?: users_profileUpdateManyWithoutProfileNestedInput
  }

  export type userUncheckedUpdateWithoutCookiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    usecase?: EnumusecaseFieldUpdateOperationsInput | usecase
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordhash?: passwordhashUncheckedUpdateOneWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutPermissionNestedInput
    userlog?: userlogUncheckedUpdateManyWithoutUserNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUserNestedInput
    product?: productUncheckedUpdateManyWithoutUserNestedInput
    order?: orderUncheckedUpdateManyWithoutUserNestedInput
    profile?: users_profileUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type cookieCreateManyUserInput = {
    id?: number
    value: string
    createdat?: Date | string
  }

  export type permissionCreateManyPermissionInput = {
    id?: number
    name: string
    description: string
    createdat?: Date | string
  }

  export type userlogCreateManyUserInput = {
    id?: number
    action: string
    createat?: Date | string
  }

  export type productCreateManyUserInput = {
    id?: number
    name: string
    description: string
    price: number
    createdat?: Date | string
  }

  export type orderCreateManyUserInput = {
    id?: number
    productid: number
    quantity: number
    total: number
    createdat?: Date | string
  }

  export type users_profileCreateManyProfileInput = {
    id?: number
    name: string
    lastname: string
    street: string
    phone_number: string
    number_address: number
    neigh: string
  }

  export type cookieUpdateWithoutUserInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cookieUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cookieUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionUpdateWithoutPermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionlog?: permissionlogUpdateManyWithoutPermisionNestedInput
  }

  export type permissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionlog?: permissionlogUncheckedUpdateManyWithoutPermisionNestedInput
  }

  export type permissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userlogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userlogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userlogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: orderUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: orderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type orderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productid?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productid?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_profileUpdateWithoutProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
  }

  export type users_profileUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
  }

  export type users_profileUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    number_address?: IntFieldUpdateOperationsInput | number
    neigh?: StringFieldUpdateOperationsInput | string
  }

  export type team_playerCreateManyPlayeridInput = {
    id?: number
    team_id: number
  }

  export type team_playerUpdateWithoutPlayeridInput = {
    teamid?: teamUpdateOneRequiredWithoutPlayer_teamNestedInput
  }

  export type team_playerUncheckedUpdateWithoutPlayeridInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
  }

  export type team_playerUncheckedUpdateManyWithoutPlayeridInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
  }

  export type orderCreateManyProductInput = {
    id?: number
    userid: number
    quantity: number
    total: number
    createdat?: Date | string
  }

  export type orderUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletmovementCreateManyWalletInput = {
    id?: number
    amount: number
    movementtype: movementtype
    createdat?: Date | string
  }

  export type walletmovementUpdateWithoutWalletInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletmovementUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletmovementUncheckedUpdateManyWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    movementtype?: EnummovementtypeFieldUpdateOperationsInput | movementtype
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type league_teamsCreateManyLeaguesInput = {
    id?: number
    team_id: number
  }

  export type league_teamsUpdateWithoutLeaguesInput = {
    teamid?: teamUpdateOneRequiredWithoutLeague_teamsNestedInput
    statistics_team?: statistics_teamUpdateManyWithoutLeague_teamidNestedInput
  }

  export type league_teamsUncheckedUpdateWithoutLeaguesInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    statistics_team?: statistics_teamUncheckedUpdateManyWithoutLeague_teamidNestedInput
  }

  export type league_teamsUncheckedUpdateManyWithoutLeaguesInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
  }

  export type statistics_teamCreateManyLeague_teamidInput = {
    fixtures: JsonNullValueInput | InputJsonValue
    biggest: JsonNullValueInput | InputJsonValue
    goals: JsonNullValueInput | InputJsonValue
    clean_sheet: JsonNullValueInput | InputJsonValue
    failed_to_score: JsonNullValueInput | InputJsonValue
    penalty: JsonNullValueInput | InputJsonValue
    lineups: JsonNullValueInput | InputJsonValue
    cards: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUpdateWithoutLeague_teamidInput = {
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUncheckedUpdateWithoutLeague_teamidInput = {
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
  }

  export type statistics_teamUncheckedUpdateManyWithoutLeague_teamidInput = {
    fixtures?: JsonNullValueInput | InputJsonValue
    biggest?: JsonNullValueInput | InputJsonValue
    goals?: JsonNullValueInput | InputJsonValue
    clean_sheet?: JsonNullValueInput | InputJsonValue
    failed_to_score?: JsonNullValueInput | InputJsonValue
    penalty?: JsonNullValueInput | InputJsonValue
    lineups?: JsonNullValueInput | InputJsonValue
    cards?: JsonNullValueInput | InputJsonValue
  }

  export type league_teamsCreateManyTeamidInput = {
    id?: number
    league_id: number
  }

  export type team_playerCreateManyTeamidInput = {
    id?: number
    player_id: number
  }

  export type league_teamsUpdateWithoutTeamidInput = {
    leagues?: leaguesUpdateOneRequiredWithoutLeague_teamsNestedInput
    statistics_team?: statistics_teamUpdateManyWithoutLeague_teamidNestedInput
  }

  export type league_teamsUncheckedUpdateWithoutTeamidInput = {
    id?: IntFieldUpdateOperationsInput | number
    league_id?: IntFieldUpdateOperationsInput | number
    statistics_team?: statistics_teamUncheckedUpdateManyWithoutLeague_teamidNestedInput
  }

  export type league_teamsUncheckedUpdateManyWithoutTeamidInput = {
    id?: IntFieldUpdateOperationsInput | number
    league_id?: IntFieldUpdateOperationsInput | number
  }

  export type team_playerUpdateWithoutTeamidInput = {
    playerid?: football_playersUpdateOneRequiredWithoutTeam_playerNestedInput
  }

  export type team_playerUncheckedUpdateWithoutTeamidInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type team_playerUncheckedUpdateManyWithoutTeamidInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissionlogCreateManyPermisionInput = {
    id?: number
    action: string
    createdat?: Date | string
  }

  export type permissionlogUpdateWithoutPermisionInput = {
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionlogUncheckedUpdateWithoutPermisionInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionlogUncheckedUpdateManyWithoutPermisionInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}